[{"role": "summary", "content": "The code snippet tests the `create_update` functionality of a repository. It creates a document with a specific ID, metadata, and a byte array. It then reads the document, updates the metadata, and compares the actual and expected values. It also tests the read metadata functionality by retrieving the version and verifying that the value is null."}, {"role": "code", "content": "public void test_create_update() throws IOException {\n  final String id=\"test\";\n  final Map<String,Object> metadata=new HashMap<String,Object>();\n  metadata.put(FileMetadataSchema.ID,id);\n  metadata.put(\"foo\",\"bar\");\n  final int version0;\n  final long createTime0;\n  final byte[] expected0=new byte[]{1,2,3};\n{\n    version0=repo.create(metadata);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version0));\n    assertEquals(\"version\",0,version0);\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime0=doc.getVersionCreateTime();\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version0,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"bar\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    repo.copyStream(id,version0,new ByteArrayInputStream(expected0));\n    assertEquals(\"version0\",expected0,read(repo.inputStream(id,version0)));\n  }\n  final int version1;\n  final long createTime1;\n  final byte[] expected1=new byte[]{4,5,6};\n{\n    metadata.put(\"foo\",\"baz\");\n    DocumentImpl doc1=new DocumentImpl(metadata);\n    doc1.copyStream(expected1);\n    version1=repo.update(doc1);\n    assertEquals(\"version\",1,version1);\n    metadata.put(FileMetadataSchema.VERSION,Integer.valueOf(version1));\n    RepositoryDocumentImpl doc=(RepositoryDocumentImpl)repo.read(id);\n    createTime1=doc.getVersionCreateTime();\n    assertNotSame(\"createTime\",0L,createTime1);\n    assertNotSame(\"createTime\",createTime0,createTime1);\n    Map<String,Object> actual=doc.asMap();\n    assertEquals(\"id\",id,actual.get(FileMetadataSchema.ID));\n    assertEquals(\"version\",version1,actual.get(FileMetadataSchema.VERSION));\n    assertEquals(\"user property\",\"baz\",actual.get(\"foo\"));\n    assertEquals(\"size\",metadata.size(),actual.size());\n    assertEquals(\"version1\",expected1,read(repo.inputStream(id,version1)));\n    assertEquals(\"version0\",new byte[]{},read(repo.inputStream(id,version0)));\n{\n      ITPS tps=repo.readMetadata(id,createTime1 - 1L);\n      ITPV tpv=tps.get(FileMetadataSchema.VERSION);\n      assertEquals(\"version\",null,tpv.getValue());\n    }\n  }\n}\n"}]
[{"role": "summary", "content": "This function returns a pointer to the `MimeDecConfig` structure, which is the singleton instance of the configuration for the MIME decoding process."}, {"role": "code", "content": "MimeDecConfig * MimeDecGetConfig(void)\n{\n    return &mime_dec_config;\n}"}]
[{"role": "summary", "content": "This method constructs a URI from its components: scheme, authority, path, query, and fragment. It first checks if the path is relative and throws an exception if it is. It then builds the URI string by appending the scheme, authority, path, query, and fragment, using the provided encoders. Finally, it parses the URI string to ensure it is valid."}, {"role": "code", "content": "public URI(String scheme,String authority,String path,String query,String fragment) throws URISyntaxException {\n  if (scheme != null && path != null && !path.isEmpty() && path.charAt(0) != '/') {\n    throw new URISyntaxException(path,\"Relative path\");\n  }\n  StringBuilder uri=new StringBuilder();\n  if (scheme != null) {\n    uri.append(scheme);\n    uri.append(':');\n  }\n  if (authority != null) {\n    uri.append(\"//\");\n    AUTHORITY_ENCODER.appendEncoded(uri,authority);\n  }\n  if (path != null) {\n    PATH_ENCODER.appendEncoded(uri,path);\n  }\n  if (query != null) {\n    uri.append('?');\n    ALL_LEGAL_ENCODER.appendEncoded(uri,query);\n  }\n  if (fragment != null) {\n    uri.append('#');\n    ALL_LEGAL_ENCODER.appendEncoded(uri,fragment);\n  }\n  parseURI(uri.toString(),false);\n}\n"}]
[{"role": "summary", "content": "The `StreamTcpInlineMode` function checks if the `STREAMTCP_INIT_FLAG_INLINE` flag is set in the `stream_config` structure. If it is, the function returns `1`; otherwise, it returns `0`."}, {"role": "code", "content": "int StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}"}]
[{"role": "summary", "content": "This function writes data to a specified address in a NFP CPP structure. It aligns the write to a safe area and writes the data in chunks. If the write is not successful, it returns the error code. If the data is written correctly, it returns the number of bytes written."}, {"role": "code", "content": "int nfp_cpp_write(struct nfp_cpp *cpp, u32 destination,\n\t\t  unsigned long long address,\n\t\t  const void *kernel_vaddr, size_t length)\n{\n\tsize_t n, offset;\n\tint ret;\n\n\tfor (offset = 0; offset < length; offset += n) {\n\t\tunsigned long long w_addr = address + offset;\n\n\t\t/* make first write smaller to align to safe window */\n\t\tn = min_t(size_t, length - offset,\n\t\t\t  ALIGN(w_addr + 1, NFP_CPP_SAFE_AREA_SIZE) - w_addr);\n\n\t\tret = __nfp_cpp_write(cpp, destination, address + offset,\n\t\t\t\t      kernel_vaddr + offset, n);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret != n)\n\t\t\treturn offset + n;\n\t}\n\n\treturn length;\n}"}]
[{"role": "summary", "content": "This function prints \"mpidbg_interface_version_compatibility\" and returns the value of MPIDBG_INTERFACE_VERSION."}, {"role": "code", "content": "int mpidbg_interface_version_compatibility(void)\n{\n    printf(\"mpidbg_interface_version_compatibility\\n\");\n    return MPIDBG_INTERFACE_VERSION;\n}"}]
[{"role": "summary", "content": "The `addListener` method adds a `Listener` to the `mListeners` collection and notifies the `notifyServiceDiscovered` method with the `mMatchingDrones` collection when a service is discovered."}, {"role": "code", "content": "public void addListener(Listener listener){\n  mListeners.add(listener);\n  notifyServiceDiscovered(mMatchingDrones);\n}\n"}]
[{"role": "summary", "content": "This function, `write_fs`, is a static inline function that writes a 32-bit value to a specific offset in the base address of a `struct fs_dev` structure. The function takes two parameters: `dev`, a pointer to the `struct fs_dev` instance, and `offset`, an integer representing the byte offset within the device's base address where the value should be written. The value to be written is passed as an argument to the function. The function uses the `writel` system call to write the value to the specified offset in the device's base address."}, {"role": "code", "content": "static inline void write_fs (struct fs_dev *dev, int offset, u32 val)\n{\n\twritel (val, dev->base + offset);\n}"}]
[{"role": "summary", "content": "This method copies a carbon data file from the local file system to the carbon store. It measures the time taken for the copy operation and logs the process. If an IOException occurs during the copy, it throws a CarbonDataWriterException."}, {"role": "code", "content": "private void copyCarbonDataFileToCarbonStorePath(String localFileName) throws CarbonDataWriterException {\n  long copyStartTime=System.currentTimeMillis();\n  LOGGER.info(\"Copying \" + localFileName + \" --> \"+ carbonDataDirectoryPath);\n  try {\n    CarbonFile localCarbonFile=FileFactory.getCarbonFile(localFileName,FileFactory.getFileType(localFileName));\n    String carbonFilePath=carbonDataDirectoryPath + localFileName.substring(localFileName.lastIndexOf(File.separator));\n    copyLocalFileToCarbonStore(carbonFilePath,localFileName,CarbonCommonConstants.BYTEBUFFER_SIZE,getMaxOfBlockAndFileSize(fileSizeInBytes,localCarbonFile.getSize()));\n  }\n catch (  IOException e) {\n    throw new CarbonDataWriterException(\"Problem while copying file from local store to carbon store\");\n  }\n  LOGGER.info(\"Total copy time (ms) to copy file \" + localFileName + \" is \"+ (System.currentTimeMillis() - copyStartTime));\n}\n"}]
[{"role": "summary", "content": "This method attempts to parse a given `String` dateValue using a provided `Collection` of `dateFormats`. It first checks for null arguments and sets a default format if necessary. It then sanitizes the dateValue by removing single quotes. The method iterates over the dateFormats, applying each one to the dateValue using a `SimpleDateFormat` object. If a valid date is parsed successfully, it returns it; otherwise, it throws a `DateParseException`. If no format is successfully parsed, it throws an exception with the error message."}, {"role": "code", "content": "public static Date parseDate(String dateValue,Collection dateFormats) throws DateParseException {\n  if (dateValue == null) {\n    throw new IllegalArgumentException(\"dateValue is null\");\n  }\n  if (dateFormats == null) {\n    dateFormats=DEFAULT_PATTERNS;\n  }\n  if (dateValue.length() > 1 && dateValue.startsWith(\"'\") && dateValue.endsWith(\"'\")) {\n    dateValue=dateValue.substring(1,dateValue.length() - 1);\n  }\n  SimpleDateFormat dateParser=null;\n  final Iterator formatIter=dateFormats.iterator();\n  while (formatIter.hasNext()) {\n    final String format=(String)formatIter.next();\n    if (dateParser == null) {\n      dateParser=new SimpleDateFormat(format,Locale.US);\n      dateParser.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n    }\n else {\n      dateParser.applyPattern(format);\n    }\n    try {\n      return dateParser.parse(dateValue);\n    }\n catch (    final ParseException pe) {\n    }\n  }\n  throw new DateParseException(\"Unable to parse the date \" + dateValue);\n}\n"}]
[{"role": "summary", "content": "This method retrieves a list of strings from the resource string defined in the XML file, and then updates the text of a `SimpleIconFontTextView` with the concatenated list of strings."}, {"role": "code", "content": "private void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_1);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.gems_logo));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}\n"}]
[{"role": "summary", "content": "The `createMosaicDefinition` method takes an `Account` object and a `String` identifier and `String` name, along with a `MosaicProperties` object, to return a `MosaicDefinition` object."}, {"role": "code", "content": "public static MosaicDefinition createMosaicDefinition(final Account creator){\n  return createMosaicDefinition(creator,Utils.createMosaicId(\"alice.vouchers\",\"alice's gift vouchers\"),createMosaicProperties());\n}\n"}]
[{"role": "summary", "content": "The `removeAttribute` method removes an attribute from an `attributesList` if the attribute name matches the provided name. It iterates through the list, checks if the object is an `AttributeField`, and if so, attempts to get the attribute name. If the name matches, it removes the attribute from the list. If an exception occurs during the process, it catches it and does nothing."}, {"role": "code", "content": "public void removeAttribute(String name){\n  if (name != null)   if (attributesList != null) {\n    for (int i=0; i < attributesList.size(); i++) {\n      Object o=attributesList.elementAt(i);\n      if (o instanceof AttributeField) {\n        AttributeField a=(AttributeField)o;\n        try {\n          String n=a.getName();\n          if (n != null) {\n            if (name.equals(n)) {\n              attributesList.remove(a);\n            }\n          }\n        }\n catch (        SdpParseException e) {\n        }\n      }\n    }\n  }\n}\n"}]
[{"role": "summary", "content": "The test_DivideBigDecimalRoundingModeHALF_UP method tests the division of two large numbers using the HALF_UP rounding mode. It creates two large strings representing the numbers, converts them to BigDecimal objects, performs the division, and then asserts that the result matches a predefined string. If the result does not match, an assertion error is thrown."}, {"role": "code", "content": "public void test_DivideBigDecimalRoundingModeHALF_UP(){\n  String a=\"3736186567876876578956958765675671119238118911893939591735\";\n  String b=\"74723342238476237823787879183470\";\n  RoundingMode rm=RoundingMode.HALF_UP;\n  String c=\"50000260373164286401361913\";\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a));\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b));\n  BigDecimal result=aNumber.divide(bNumber,rm);\n  assertEquals(\"incorrect value\",c,result.toString());\n}\n"}]
[{"role": "summary", "content": "This code snippet defines a method `run` that downloads a file from a given URL and returns an `IStatus` object representing the result. The method uses an `IProgressMonitor` to report progress and handle cancellation. It handles various exceptions, such as `MalformedURLException` and `IOException`, and closes the streams when the download is complete. The `jobStatus` is set to `Status.OK_STATUS` if the download is successful, or an appropriate error status if there is an issue with the download."}, {"role": "code", "content": "public IStatus run(IProgressMonitor monitor){\n  InputStream input=null;\n  FileOutputStream output=null;\n  IStatus jobStatus=Status.OK_STATUS;\n  byte[] b=new byte[1024];\n  int bytesRead;\n  try {\n    HttpURLConnection connection=(HttpURLConnection)url.openConnection();\n    input=url.openStream();\n    long totalBytesRead=0L;\n    int responseStatusCode=connection.getResponseCode();\n    if (responseStatusCode >= HttpURLConnection.HTTP_BAD_REQUEST) {\n      jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,MessageFormat.format(\"Remote ServerError: {0} ({1})\",responseStatusCode,connection.getResponseMessage()));\n    }\n    long contentLength=connection.getContentLength();\n    output=new FileOutputStream(target);\n    monitor.beginTask(\"Downloading \" + url.toString(),(int)contentLength);\n    while (jobStatus == Status.OK_STATUS) {\n      if (contentLength > 0 && totalBytesRead >= contentLength) {\n        break;\n      }\n      bytesRead=input.read(b);\n      if (bytesRead == -1) {\n        break;\n      }\n      output.write(b,0,bytesRead);\n      totalBytesRead+=bytesRead;\n      monitor.worked(bytesRead);\n      if (monitor.isCanceled()) {\n        jobStatus=Status.CANCEL_STATUS;\n        break;\n      }\n    }\n  }\n catch (  MalformedURLException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"Malformed URL: \" + url.toExternalForm(),e);\n  }\ncatch (  IOException e) {\n    jobStatus=new Status(Status.ERROR,CorePlugin.PLUGIN_ID,\"IO error while downloading \" + url.toExternalForm(),e);\n  }\n  closeStreams(input,output);\n  return jobStatus;\n}\n"}]
[{"role": "summary", "content": "This code snippet defines a method `checkBookiesUp` that connects to a ZooKeeper instance, retrieves the number of bookies available in the `/ledgers/available` directory, and waits for the specified number of seconds (`timeout`) before returning the count. If the count of bookies is reached or exceeded, it logs the information and breaks the loop. The method also handles exceptions and ensures the ZooKeeper connection is closed properly."}, {"role": "code", "content": "public int checkBookiesUp(int count,int timeout) throws Exception {\n  ZooKeeper zkc=connectZooKeeper(zkHost,zkPort,zkTimeoutSec);\n  try {\n    int mostRecentSize=0;\n    for (int i=0; i < timeout; i++) {\n      try {\n        List<String> children=zkc.getChildren(\"/ledgers/available\",false);\n        children.remove(\"readonly\");\n        mostRecentSize=children.size();\n        if ((mostRecentSize > count) || LOG.isDebugEnabled()) {\n          LOG.info(\"Found \" + mostRecentSize + \" bookies up, \"+ \"waiting for \"+ count);\n          if ((mostRecentSize > count) || LOG.isTraceEnabled()) {\n            for (            String child : children) {\n              LOG.info(\" server: \" + child);\n            }\n          }\n        }\n        if (mostRecentSize == count) {\n          break;\n        }\n      }\n catch (      KeeperException e) {\n      }\n      Thread.sleep(1000);\n    }\n    return mostRecentSize;\n  }\n  finally {\n    zkc.close();\n  }\n}\n"}]
[{"role": "summary", "content": "The `validateCustomCatalog` method takes a `String` parameter `title` and another `String` parameter `value`, and returns a `boolean` value of `false`."}, {"role": "code", "content": "private boolean validateCustomCatalog(String title,String value){\n  return false;\n}\n"}]
[{"role": "summary", "content": "The `MsSetThreadSingleCpu()` function sets the current thread to run exclusively on a single CPU core."}, {"role": "code", "content": "void MsSetThreadSingleCpu()\n{\n\tSetThreadAffinityMask(GetCurrentThread(), 1);\n}"}]
[{"role": "summary", "content": "This method `walk` recursively traverses a directory and its subdirectories, collecting files that meet certain criteria. It first checks if the traversal should be cancelled. If not, it verifies if the directory should be handled based on the depth limit and a filter. If the directory is valid, it proceeds to handle the directory's start, check for a depth limit, and list its contents. If the contents are valid, it recursively calls itself on each child directory. If a file is encountered, it checks if the traversal should be cancelled and handles the file accordingly. Finally, it handles the directory's end and returns the collected results."}, {"role": "code", "content": "private void walk(File directory,int depth,Collection<T> results) throws IOException {\n  checkIfCancelled(directory,depth,results);\n  if (handleDirectory(directory,depth,results)) {\n    handleDirectoryStart(directory,depth,results);\n    int childDepth=depth + 1;\n    if (depthLimit < 0 || childDepth <= depthLimit) {\n      checkIfCancelled(directory,depth,results);\n      File[] childFiles=filter == null ? directory.listFiles() : directory.listFiles(filter);\n      childFiles=filterDirectoryContents(directory,depth,childFiles);\n      if (childFiles == null) {\n        handleRestricted(directory,childDepth,results);\n      }\n else {\n        for (        File childFile : childFiles) {\n          if (childFile.isDirectory()) {\n            walk(childFile,childDepth,results);\n          }\n else {\n            checkIfCancelled(childFile,childDepth,results);\n            handleFile(childFile,childDepth,results);\n            checkIfCancelled(childFile,childDepth,results);\n          }\n        }\n      }\n    }\n    handleDirectoryEnd(directory,depth,results);\n  }\n  checkIfCancelled(directory,depth,results);\n}\n"}]
[{"role": "summary", "content": "This function, `keyboard_idle_timer_cb`, is a callback for the keyboard idle timer. It checks if the USB driver is in the active state and if the NKRO (N-Key Rollover) configuration is not enabled. If both conditions are met, it starts a USB transmit to send the keyboard report if the endpoint is not busy. It then rearms the timer and continues to check the conditions. If the conditions fail, it does not rearm the timer."}, {"role": "code", "content": "static void keyboard_idle_timer_cb(void *arg) {\n    USBDriver *usbp = (USBDriver *)arg;\n\n    osalSysLockFromISR();\n\n    /* check that the states of things are as they're supposed to */\n    if (usbGetDriverStateI(usbp) != USB_ACTIVE) {\n        /* do not rearm the timer, should be enabled on IDLE request */\n        osalSysUnlockFromISR();\n        return;\n    }\n\n#ifdef NKRO_ENABLE\n    if (!keymap_config.nkro && keyboard_idle && keyboard_protocol) {\n#else  /* NKRO_ENABLE */\n    if (keyboard_idle && keyboard_protocol) {\n#endif /* NKRO_ENABLE */\n        /* TODO: are we sure we want the KBD_ENDPOINT? */\n        if (!usbGetTransmitStatusI(usbp, KEYBOARD_IN_EPNUM)) {\n            usbStartTransmitI(usbp, KEYBOARD_IN_EPNUM, (uint8_t *)&keyboard_report_sent, KEYBOARD_EPSIZE);\n        }\n        /* rearm the timer */\n        chVTSetI(&keyboard_idle_timer, 4 * MS2ST(keyboard_idle), keyboard_idle_timer_cb, (void *)usbp);\n    }\n\n    /* do not rearm the timer if the condition above fails\n     * it should be enabled again on either IDLE or SET_PROTOCOL requests */\n    osalSysUnlockFromISR();\n}"}]
[{"role": "summary", "content": "This code snippet converts a given string of ASCII characters to a string of HTML entities. It checks each character in the input string. If the character is an ampersand (&), it converts the next character to lowercase and appends an HTML entity \u00a7 to the output string. Otherwise, it appends the character itself. The function returns the resulting string."}, {"role": "code", "content": "public static String convertCodes(String string){\n  if (string == null)   return string;\n  int current=0;\n  char[] cs=string.toCharArray();\n  StringBuilder sb=new StringBuilder();\n  for (  char c : cs) {\n    if (current <= cs.length && c == '&') {\n      char tc=Character.toLowerCase(cs[current + 1]);\n      if (tc == '1' || tc == '2' || tc == '3' || tc == '4' || tc == '5' || tc == '6' || tc == '7' || tc == '8' || tc == '9' || tc == '0' || tc == 'a' || tc == 'b' || tc == 'c' || tc == 'd' || tc == 'e' || tc == 'f' || tc == 'k' || tc == 'l' || tc == 'm' || tc == 'n' || tc == 'o') {\n        sb.append(\"\u00a7\");\n      }\n else {\n        sb.append(c);\n      }\n    }\n else {\n      sb.append(c);\n    }\n    current++;\n  }\n  return sb.toString();\n}\n"}]
[{"role": "summary", "content": "This function writes the value `val` to the specified register in the OMAP4 PRM (Programming Resource Module) at the address `prm_base.va + inst + reg`. The `writel_relaxed` function is used to write the value to the memory address."}, {"role": "code", "content": "static void omap4_prm_write_inst_reg(u32 val, s16 inst, u16 reg)\n{\n\twritel_relaxed(val, prm_base.va + inst + reg);\n}"}]
[{"role": "summary", "content": "This method `doNormalize` normalizes a filename by removing redundant separators and converting them to the specified separator. It handles cases where the filename might contain multiple separators, including system and other separators. The method returns a normalized filename or an empty string if the filename is invalid or if the separator should be kept."}, {"role": "code", "content": "private static String doNormalize(String filename,char separator,boolean keepSeparator){\n  if (filename == null) {\n    return null;\n  }\n  int size=filename.length();\n  if (size == 0) {\n    return filename;\n  }\n  int prefix=getPrefixLength(filename);\n  if (prefix < 0) {\n    return null;\n  }\n  char[] array=new char[size + 2];\n  filename.getChars(0,filename.length(),array,0);\n  char otherSeparator=separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n  for (int i=0; i < array.length; i++) {\n    if (array[i] == otherSeparator) {\n      array[i]=separator;\n    }\n  }\n  boolean lastIsDirectory=true;\n  if (array[size - 1] != separator) {\n    array[size++]=separator;\n    lastIsDirectory=false;\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == separator) {\n      System.arraycopy(array,i,array,i - 1,size - i);\n      size--;\n      i--;\n    }\n  }\n  for (int i=prefix + 1; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)) {\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      System.arraycopy(array,i + 1,array,i - 1,size - i);\n      size-=2;\n      i--;\n    }\n  }\n  outer:   for (int i=prefix + 2; i < size; i++) {\n    if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)) {\n      if (i == prefix + 2) {\n        return null;\n      }\n      if (i == size - 1) {\n        lastIsDirectory=true;\n      }\n      int j;\n      for (j=i - 4; j >= prefix; j--) {\n        if (array[j] == separator) {\n          System.arraycopy(array,i + 1,array,j + 1,size - i);\n          size-=i - j;\n          i=j + 1;\n          continue outer;\n        }\n      }\n      System.arraycopy(array,i + 1,array,prefix,size - i);\n      size-=i + 1 - prefix;\n      i=prefix + 1;\n    }\n  }\n  if (size <= 0) {\n    return \"\";\n  }\n  if (size <= prefix) {\n    return new String(array,0,size);\n  }\n  if (lastIsDirectory && keepSeparator) {\n    return new String(array,0,size);\n  }\n  return new String(array,0,size - 1);\n}\n"}]
[{"role": "summary", "content": "This function, `espconn_tcp_set_max_retran`, sets the maximum number of retransmissions for TCP connections to the specified value. It returns `ESPCONN_OK` if the value is valid (0 or 12), otherwise it returns `ESPCONN_ARG` if the value is outside the valid range."}, {"role": "code", "content": "sint8 ICACHE_FLASH_ATTR espconn_tcp_set_max_retran(uint8 num)\n{\n\tif (num == 0 || num > 12)\n\t\treturn ESPCONN_ARG;\n\n\tTCP_MAXRTX = num;\n\treturn ESPCONN_OK;\n}"}]
[{"role": "summary", "content": "The `println` method in Java prints the specified `Object` to the standard output (console) and a newline character."}, {"role": "code", "content": "public static void println(Object x){\n  out.println(x);\n}\n"}]
[{"role": "summary", "content": "The `isStable()` method returns `true` if the `myFeatures` list contains the `FEATURE_STABLE` constant."}, {"role": "code", "content": "public boolean isStable(){\n  return myFeatures.contains(FEATURE_STABLE);\n}\n"}]
[{"role": "summary", "content": "The `shutdown()` method is designed to shut down a thread pool, logging the number of tasks in each pool and checking for successful termination. It waits for tasks to complete before confirming the shutdown. The method also sets policies to prevent existing tasks from running after shutdown and continues existing periodic tasks. If an InterruptedException occurs, it prints the stack trace. The method logs the success status and the remaining tasks in each pool after the shutdown."}, {"role": "code", "content": "public void shutdown(){\n  final long begin=System.currentTimeMillis();\n  log.info(\"ThreadPoolManager: Shutting down.\");\n  log.info(\"\\t... executing \" + getTaskCount(scheduledPool) + \" scheduled tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(instantPool) + \" instant tasks.\");\n  log.info(\"\\t... executing \" + getTaskCount(longRunningPool) + \" long running tasks.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  scheduledPool.shutdown();\n  instantPool.shutdown();\n  longRunningPool.shutdown();\n  workStealingPool.shutdown();\n  boolean success=false;\n  try {\n    success|=awaitTermination(5000);\n    scheduledPool.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n    scheduledPool.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n    success|=awaitTermination(10000);\n  }\n catch (  InterruptedException e) {\n    e.printStackTrace();\n  }\n  log.info(\"\\t... success: \" + success + \" in \"+ (System.currentTimeMillis() - begin)+ \" msec.\");\n  log.info(\"\\t... \" + getTaskCount(scheduledPool) + \" scheduled tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(instantPool) + \" instant tasks left.\");\n  log.info(\"\\t... \" + getTaskCount(longRunningPool) + \" long running tasks left.\");\n  log.info(\"\\t... \" + (workStealingPool.getQueuedTaskCount() + workStealingPool.getQueuedSubmissionCount()) + \" forking tasks left.\");\n  workStealingPool.shutdownNow();\n}\n"}]
[{"role": "summary", "content": "The code snippet tests the bitwise AND operation between two byte arrays, `aBytes` and `bBytes`, and compares the result with a predefined byte array `rBytes`. It then verifies the correctness of the result by comparing each byte of the result with the corresponding byte in `rBytes`. The test also checks if the sign of the result is correct. If any byte in the result does not match the corresponding byte in `rBytes`, the test will fail."}, {"role": "code", "content": "public void testAndNotNegNegFirstLonger(){\n  byte aBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  byte bBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={73,-92,-48,4,12,6,4,32,48,64,0,8,2};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.andNot(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",1,result.signum());\n}\n"}]
[{"role": "summary", "content": "This code snippet is a method in a class that handles the onPageScrolled event. It checks if there are any decor children, and if so, it calculates the left position of each child based on its gravity and the current scroll position. It then calls `dispatchOnPageScrolled` to update the page's scroll position. If a `mPageTransformer` is available, it applies a transformation to each non-decor child based on their left position relative to the scroll position. The method also sets a flag `mCalledSuper` to true to indicate that the superclass method `onPageScrolled` has been called."}, {"role": "code", "content": "@CallSuper protected void onPageScrolled(int position,float offset,int offsetPixels){\n  if (mDecorChildCount > 0) {\n    final int scrollX=getScrollX();\n    int paddingLeft=getPaddingLeft();\n    int paddingRight=getPaddingRight();\n    final int width=getWidth();\n    final int childCount=getChildCount();\n    for (int i=0; i < childCount; i++) {\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      if (!lp.isDecor)       continue;\n      final int hgrav=lp.gravity & Gravity.HORIZONTAL_GRAVITY_MASK;\n      int childLeft=0;\nswitch (hgrav) {\ndefault :\n        childLeft=paddingLeft;\n      break;\ncase Gravity.LEFT:\n    childLeft=paddingLeft;\n  paddingLeft+=child.getWidth();\nbreak;\ncase Gravity.CENTER_HORIZONTAL:\nchildLeft=Math.max((width - child.getMeasuredWidth()) / 2,paddingLeft);\nbreak;\ncase Gravity.RIGHT:\nchildLeft=width - paddingRight - child.getMeasuredWidth();\npaddingRight+=child.getMeasuredWidth();\nbreak;\n}\nchildLeft+=scrollX;\nfinal int childOffset=childLeft - child.getLeft();\nif (childOffset != 0) {\nchild.offsetLeftAndRight(childOffset);\n}\n}\n}\ndispatchOnPageScrolled(position,offset,offsetPixels);\nif (mPageTransformer != null) {\nfinal int scrollX=getScrollX();\nfinal int childCount=getChildCount();\nfor (int i=0; i < childCount; i++) {\nfinal View child=getChildAt(i);\nfinal LayoutParams lp=(LayoutParams)child.getLayoutParams();\nif (lp.isDecor) continue;\nfinal float transformPos=(float)(child.getLeft() - scrollX) / getClientWidth();\nmPageTransformer.transformPage(child,transformPos);\n}\n}\nmCalledSuper=true;\n}\n"}]
[{"role": "summary", "content": "This code snippet defines a method `_forwardPoly` that calculates a forward-facing polynomial representation of a line segment. Here's a concise summary:\n\n- The method takes an array of raw line points, a line type, the number of segments, and a boolean indicating if the line is filled.\n- It first checks if the line is complex and returns an empty list if so.\n- It initializes variables for the line segment, including a temporary point, an azimuth variable, and an array for storing sections of the line.\n- The method then calculates the forward-facing direction of the line segment and initializes the azimuth variable.\n- It iterates through the line segment, updating the azimuth variable and adding sections to the list if necessary.\n- If the number of invalid sections equals the length of the line segment, it returns an empty list.\n- If the line is filled, it creates a filled version of the line segment by copying the forward-facing points to a new array and adding it to the result list.\n- Otherwise, it returns the forward-facing points as a list.\n\nNote: The code snippet provided is incomplete and contains some syntax errors. The method name should be `forwardPoly` instead of `_forwardPoly`, and the return type is missing."}, {"role": "code", "content": "protected ArrayList<float[]> _forwardPoly(float[] rawllpts,int ltype,int nsegs,boolean isFilled){\n  boolean DEBUG=Debug.debugging(\"proj\");\n  int len=rawllpts.length >>> 1;\n  if (len < 2)   return new ArrayList<float[]>(0);\n  if (isComplicatedLineType(ltype))   return doPolyDispatch(rawllpts,ltype,nsegs,isFilled);\n  int invalid_count=0;\n  boolean curr_invalid, prev_invalid=false;\n  Point temp=new Point();\n  AzimuthVar az_first=null, az_save=null, azVar=new AzimuthVar();\n  ArrayList<AzimuthVar> sections=new ArrayList<AzimuthVar>(128);\n  float[] x_, xs=new float[len];\n  float[] y_, ys=new float[len];\n  _forward(rawllpts[0],rawllpts[1],temp,azVar);\n  xs[0]=temp.x;\n  ys[0]=temp.y;\n  prev_invalid=azVar.invalid_forward;\n  if (prev_invalid) {\n    ++invalid_count;\n  }\n else {\n    azVar.index=0;\n    azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[0],rawllpts[1]);\n    if (!isFilled) {\n      sections.add(azVar);\n    }\n else {\n      az_first=azVar;\n    }\n    azVar=new AzimuthVar();\n  }\n  int i=0, j=0;\n  for (i=1, j=2; i < len; i++, j+=2) {\n    azVar.invalid_forward=false;\n    _forward(rawllpts[j],rawllpts[j + 1],temp,azVar);\n    curr_invalid=azVar.invalid_forward;\n    xs[i]=temp.x;\n    ys[i]=temp.y;\n    if (!curr_invalid && prev_invalid) {\n      azVar.index=i - 1;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n      azVar=new AzimuthVar();\n    }\n else     if (curr_invalid) {\n      if (!prev_invalid) {\n        azVar.index=i;\n        if (isFilled && (invalid_count == 0)) {\n          az_save=azVar;\n        }\n else {\n          sections.add(azVar);\n        }\n        azVar=new AzimuthVar();\n      }\n      ++invalid_count;\n    }\n    prev_invalid=curr_invalid;\n  }\n  if (invalid_count == 0) {\n    ArrayList<float[]> ret_val=new ArrayList<float[]>(2);\n    ret_val.add(xs);\n    ret_val.add(ys);\n    return ret_val;\n  }\n  if (invalid_count == len) {\n    return new ArrayList<float[]>(0);\n  }\n  if (!prev_invalid) {\n    if (isFilled && (az_save != null)) {\n      int l=az_save.index;\n      x_=new float[len + l];\n      y_=new float[len + l];\n      System.arraycopy(xs,0,x_,0,len);\n      System.arraycopy(ys,0,y_,0,len);\n      System.arraycopy(xs,0,x_,len,l);\n      System.arraycopy(ys,0,y_,len,l);\n      az_save.index=len + l;\n      sections.add(az_save);\n      xs=x_;\n      ys=y_;\n    }\n else {\n      if (DEBUG && isFilled && (az_save == null)) {\n        Debug.output(\"AA, filled, no-wrap!\");\n      }\n      azVar.index=i;\n      j=rawllpts.length;\n      azVar.current_azimuth=GreatCircle.sphericalAzimuth((float)centerY,(float)centerX,rawllpts[j - 2],rawllpts[j - 1]);\n      sections.add(azVar);\n    }\n  }\n else   if (az_save != null) {\n    if (DEBUG)     Debug.output(\"DD, filled!\");\n    sections.add(az_first);\n    sections.add(az_save);\n  }\n  int size=sections.size();\n  ArrayList<float[]> ret_val=new ArrayList<float[]>(size);\n  if (isFilled && (len > 2)) {\n    generateFilledPoly(xs,ys,sections,ret_val);\n    return ret_val;\n  }\n  for (j=0; j < size; j+=2) {\n    AzimuthVar az1=(AzimuthVar)sections.get(j);\n    AzimuthVar az2=(AzimuthVar)sections.get(j + 1);\n    int off1=az1.index;\n    int off2=az2.index;\n    int l=off2 - off1;\n    x_=new float[l];\n    y_=new float[l];\n    System.arraycopy(xs,off1,x_,0,l);\n    System.arraycopy(ys,off1,y_,0,l);\n    ret_val.add(x_);\n    ret_val.add(y_);\n  }\n  return ret_val;\n}\n"}]
[{"role": "summary", "content": "This method, `startAdditionalServices`, is a protected method that begins the execution of additional services. It takes two parameters: `cache`, which is presumed to be a Cache object, and `options`, which is presumed to be a Map of options. The method does not return a value and throws an exception if an error occurs."}, {"role": "code", "content": "protected void startAdditionalServices(final Cache cache,final Map<String,Object> options) throws Exception {\n}\n"}]
[{"role": "summary", "content": "The `ExecMaterializesOutput` function checks the `NodeTag` of a node to determine if it should materialize its output. It returns `true` if the node is of one of the specified types (T_Material, T_FunctionScan, T_TableFuncScan, T_CteScan, T_NamedTuplestoreScan, T_WorkTableScan, or T_Sort), and `false` otherwise."}, {"role": "code", "content": "ExecMaterializesOutput(NodeTag plantype)\n{\n\tswitch (plantype)\n\t{\n\t\tcase T_Material:\n\t\tcase T_FunctionScan:\n\t\tcase T_TableFuncScan:\n\t\tcase T_CteScan:\n\t\tcase T_NamedTuplestoreScan:\n\t\tcase T_WorkTableScan:\n\t\tcase T_Sort:\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn false;\n}"}]
[{"role": "summary", "content": "This function sets an error for a QEMUFile object by passing the error code to the internal function qemu_file_set_error_obj()."}, {"role": "code", "content": "void qemu_file_set_error(QEMUFile *f, int ret)\n{\n    qemu_file_set_error_obj(f, ret, NULL);\n}"}]
[{"role": "summary", "content": "The `oredCriteria.add(criteria);` method in the code snippet adds a `Criteria` object to an `OredCriteria` collection. This method is part of a class that presumably implements a sorting or filtering mechanism, likely for a database query or a search algorithm. The `Criteria` object likely contains one or more `Criteria` instances that define the conditions for the sorting or filtering. By adding the `Criteria` object to the `OredCriteria` collection, the collection is expanded to include the conditions specified by the `Criteria` object, allowing for more complex and precise sorting or filtering operations."}, {"role": "code", "content": "public void or(Criteria criteria){\n  oredCriteria.add(criteria);\n}\n"}]
[{"role": "summary", "content": "The `runFinalization` method is a static method that calls the `RUNTIME.runFinalization()` method."}, {"role": "code", "content": "public static void runFinalization(){\n  RUNTIME.runFinalization();\n}\n"}]
[{"role": "summary", "content": "The `resetPSRs` method clears all elements from the `pilotRolls` collection."}, {"role": "code", "content": "public void resetPSRs(){\n  pilotRolls.removeAllElements();\n}\n"}]
[{"role": "summary", "content": "The `japi_shift_process` function sends the string \"SHIFTPROCESS\" to a serial device identified by `sd`."}, {"role": "code", "content": "japi_shift_process(int sd)\n{\n  do_send(sd, \"SHIFTPROCESS\\n\");\n}"}]
[{"role": "summary", "content": "This method adds a new pair to the `mappings` list, which contains a `MatcherResponseSourcePair` object, where the `Matcher` is used to match requests and the `ResponseSource` is used to generate responses."}, {"role": "code", "content": "private void mapRequestToResponses(Matcher<Request> requestMatcher,ResponseSource responses){\n  mappings.add(new MatcherResponseSourcePair(requestMatcher,responses));\n}\n"}]
[{"role": "summary", "content": "The `format` method takes an `Object` parameter `o` and returns its `toString` method result. This method is used to convert an object to a string representation."}, {"role": "code", "content": "protected String format(Object o){\n  return o.toString();\n}\n"}]
[{"role": "summary", "content": "The `isStringType` method checks if the given `Type` object represents a `java.lang.String` type by comparing it with the `RefType` constant `v(\"java.lang.String\")`."}, {"role": "code", "content": "public static boolean isStringType(Type t){\n  return t.equals(RefType.v(\"java.lang.String\"));\n}\n"}]
[{"role": "summary", "content": "This code snippet is a method in a class that handles layouting children within a view hierarchy. It calculates the width of each column, measures and positions child views, and updates the layout records accordingly. It also handles touch and motion events to update the selector position if necessary."}, {"role": "code", "content": "final void layoutChildren(boolean queryAdapter){\n  final int paddingLeft=getPaddingLeft();\n  final int paddingRight=getPaddingRight();\n  final int itemMargin=mItemMargin;\n  final int colWidth=(getWidth() - paddingLeft - paddingRight- itemMargin * (mColCount - 1)) / mColCount;\n  mColWidth=colWidth;\n  int rebuildLayoutRecordsBefore=-1;\n  int rebuildLayoutRecordsAfter=-1;\n  Arrays.fill(mItemBottoms,Integer.MIN_VALUE);\n  final int childCount=getChildCount();\n  int amountRemoved=0;\n  for (int i=0; i < childCount; i++) {\n    View child=getChildAt(i);\n    LayoutParams lp=(LayoutParams)child.getLayoutParams();\n    final int col=lp.column;\n    final int position=mFirstPosition + i;\n    final boolean needsLayout=queryAdapter || child.isLayoutRequested();\n    if (queryAdapter) {\n      View newView=obtainView(position,child);\n      if (newView == null) {\n        removeViewAt(i);\n        if (i - 1 >= 0)         invalidateLayoutRecordsAfterPosition(i - 1);\n        amountRemoved++;\n        continue;\n      }\n else       if (newView != child) {\n        removeViewAt(i);\n        addView(newView,i);\n        child=newView;\n      }\n      lp=(LayoutParams)child.getLayoutParams();\n    }\n    final int span=Math.min(mColCount,lp.span);\n    final int widthSize=colWidth * span + itemMargin * (span - 1);\n    if (needsLayout) {\n      final int widthSpec=MeasureSpec.makeMeasureSpec(widthSize,MeasureSpec.EXACTLY);\n      final int heightSpec;\n      if (lp.height == LayoutParams.WRAP_CONTENT) {\n        heightSpec=MeasureSpec.makeMeasureSpec(0,MeasureSpec.UNSPECIFIED);\n      }\n else {\n        heightSpec=MeasureSpec.makeMeasureSpec(lp.height,MeasureSpec.EXACTLY);\n      }\n      child.measure(widthSpec,heightSpec);\n    }\n    int childTop=mItemBottoms[col] > Integer.MIN_VALUE ? mItemBottoms[col] + mItemMargin : child.getTop();\n    if (span > 1) {\n      int lowest=childTop;\n      for (int j=col + 1; j < col + span; j++) {\n        final int bottom=mItemBottoms[j] + mItemMargin;\n        if (bottom > lowest) {\n          lowest=bottom;\n        }\n      }\n      childTop=lowest;\n    }\n    final int childHeight=child.getMeasuredHeight();\n    final int childBottom=childTop + childHeight;\n    final int childLeft=paddingLeft + col * (colWidth + itemMargin);\n    final int childRight=childLeft + child.getMeasuredWidth();\n    child.layout(childLeft,childTop,childRight,childBottom);\n    for (int j=col; j < col + span; j++) {\n      mItemBottoms[j]=childBottom;\n    }\n    final LayoutRecord rec=mLayoutRecords.get(position);\n    if (rec != null && rec.height != childHeight) {\n      rec.height=childHeight;\n      rebuildLayoutRecordsBefore=position;\n    }\n    if (rec != null && rec.span != span) {\n      rec.span=span;\n      rebuildLayoutRecordsAfter=position;\n    }\n  }\n  for (int i=0; i < mColCount; i++) {\n    if (mItemBottoms[i] == Integer.MIN_VALUE) {\n      mItemBottoms[i]=mItemTops[i];\n    }\n  }\n  if (rebuildLayoutRecordsBefore >= 0 || rebuildLayoutRecordsAfter >= 0) {\n    if (rebuildLayoutRecordsBefore >= 0) {\n      invalidateLayoutRecordsBeforePosition(rebuildLayoutRecordsBefore);\n    }\n    if (rebuildLayoutRecordsAfter >= 0) {\n      invalidateLayoutRecordsAfterPosition(rebuildLayoutRecordsAfter);\n    }\n    for (int i=0; i < (childCount - amountRemoved); i++) {\n      final int position=mFirstPosition + i;\n      final View child=getChildAt(i);\n      final LayoutParams lp=(LayoutParams)child.getLayoutParams();\n      LayoutRecord rec=mLayoutRecords.get(position);\n      if (rec == null) {\n        rec=new LayoutRecord();\n        mLayoutRecords.put(position,rec);\n      }\n      rec.column=lp.column;\n      rec.height=child.getHeight();\n      rec.id=lp.id;\n      rec.span=Math.min(mColCount,lp.span);\n    }\n  }\n  if (this.mSelectorPosition != INVALID_POSITION) {\n    View child=getChildAt(mMotionPosition - mFirstPosition);\n    if (child != null)     positionSelector(mMotionPosition,child);\n  }\n else   if (mTouchMode > TOUCH_MODE_DOWN) {\n    View child=getChildAt(mMotionPosition - mFirstPosition);\n    if (child != null)     positionSelector(mMotionPosition,child);\n  }\n else {\n    mSelectorRect.setEmpty();\n  }\n}\n"}]
[{"role": "summary", "content": "This method adds a new header to the request object. It ensures that both the key and value are not null before adding them to the headers map."}, {"role": "code", "content": "public Request header(String key,String value){\n  Objects.requireNonNull(key);\n  Objects.requireNonNull(value);\n  _headers.put(key,value);\n  return this;\n}\n"}]
[{"role": "summary", "content": "This function writes the value of a given MSR (Model-Specific Register) to the specified memory location. It uses the `wrmsrl_safe` function to ensure the write operation is successful. The function takes two parameters: `msr` (the MSR number) and `m` (a pointer to a `msr` structure containing the desired MSR value)."}, {"role": "code", "content": "int msr_write(u32 msr, struct msr *m)\n{\n\treturn wrmsrl_safe(msr, m->q);\n}"}]
[{"role": "summary", "content": "The `isInNeedOfForm` method checks if a given `UIComponent` is an instance of `ActionSource`, `ActionSource2`, or `EditableValueHolder`."}, {"role": "code", "content": "private static boolean isInNeedOfForm(UIComponent component){\n  return (component instanceof ActionSource || component instanceof ActionSource2 || component instanceof EditableValueHolder);\n}\n"}]
[{"role": "summary", "content": "The code snippet defines a method `construct` that takes an array of strings (`args`) as input and returns a `Generator<ICircle>`. The method uses the `UniformGenerator` class, which is presumably a custom generator class, to create a new instance of it based on the first argument in the `args` array, which is expected to be a string representing a double value."}, {"role": "code", "content": "@Override public Generator<ICircle> construct(String[] args){\n  return new UniformGenerator(Double.valueOf(args[0]));\n}\n"}]
[{"role": "summary", "content": "This method converts a long integer to a binary string representation. It uses a StringBuilder to build the binary string. The method iterates 64 times, appending ':' after every 7th bit and '1' or '0' to the StringBuilder based on whether the current bit is the least significant bit or not. It then shifts the long integer to the left by 1 bit and continues until the integer is zero. Finally, it asserts that the integer is zero and returns the binary string."}, {"role": "code", "content": "public static String toBits(final long x){\n  final StringBuilder sb=new StringBuilder();\n  long t=x;\n  for (int i=0; i < 64; i++) {\n    if ((i & 7) == 0 && i > 0) {\n      sb.append(\":\");\n    }\n    sb.append(t < 0 ? \"1\" : \"0\");\n    t=t << 1;\n  }\n  assert t == 0;\n  return sb.toString();\n}\n"}]
[{"role": "summary", "content": "The code snippet tests the functionality of the `and` operation on two `BigInteger` objects, `aNumber` and `bNumber`, which represent byte arrays. The `result` is a new `BigInteger` object that holds the result of the bitwise AND operation between `aNumber` and `bNumber`. The test asserts that the sign of the result is correct and that the result is equal to the corresponding byte array."}, {"role": "code", "content": "public void testNegNegFirstShorter(){\n  byte aBytes[]={-2,-3,-4,-4,5,14,23,39,48,57,66,5,14,23};\n  byte bBytes[]={-128,9,56,100,-2,-76,89,45,91,3,-15,35,26,-117,23,87,-25,-75};\n  int aSign=-1;\n  int bSign=-1;\n  byte rBytes[]={-1,127,-10,-57,-101,1,2,2,2,-96,-16,8,-40,-59,68,-88,-88,16,73};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  BigInteger bNumber=new BigInteger(bSign,bBytes);\n  BigInteger result=aNumber.and(bNumber);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=result.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,result.signum());\n}\n"}]
[{"role": "summary", "content": "This function duplicates the state of the unwind stack. It iterates through the stack, creating a new state object and copying the current state into it. If memory allocation fails, it prints an error message and returns NULL. If the stack is empty, it returns the first state object. Otherwise, it links the new state to the previous one and updates the first and prev pointers accordingly."}, {"role": "code", "content": "dup_state_stack (struct unw_reg_state *rs)\n{\n\tstruct unw_reg_state *copy, *prev = NULL, *first = NULL;\n\n\twhile (rs) {\n\t\tcopy = alloc_reg_state();\n\t\tif (!copy) {\n\t\t\tprintk(KERN_ERR \"unwind.dup_state_stack: out of memory\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(copy, rs, sizeof(*copy));\n\t\tif (first)\n\t\t\tprev->next = copy;\n\t\telse\n\t\t\tfirst = copy;\n\t\trs = rs->next;\n\t\tprev = copy;\n\t}\n\treturn first;\n}"}]
[{"role": "summary", "content": "This function scrolls the cursor in a portal based on the specified direction and count. It calls the `_SPI_cursor_operation` function with the portal, direction, count, and an optional receiver."}, {"role": "code", "content": "SPI_scroll_cursor_move(Portal portal, FetchDirection direction, long count)\n{\n\t_SPI_cursor_operation(portal, direction, count, None_Receiver);\n}"}]
[{"role": "summary", "content": "This function initializes the `virLastErr` thread-local variable by calling `virThreadLocalInit` to set it up and `virLastErrFreeData` to free any previously allocated data for `virLastErr`."}, {"role": "code", "content": "virErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"}]
[{"role": "summary", "content": "This function, `dev_mc_add_global`, takes a `struct net_device` pointer `dev` and a pointer to a `const unsigned char` array `addr`. It calls the `__dev_mc_add` function with `dev` and `addr` as arguments, but with the additional argument `true` to indicate that the address is global. The function returns the result of `__dev_mc_add`."}, {"role": "code", "content": "int dev_mc_add_global(struct net_device *dev, const unsigned char *addr)\n{\n\treturn __dev_mc_add(dev, addr, true);\n}"}]
[{"role": "summary", "content": "The provided code snippet is a constructor for a class named `BootPanel`. It initializes the components of the `BootPanel` class using the `initComponents()` method, which is typically called to initialize the user interface components when a new instance of the class is created."}, {"role": "code", "content": "public BootPanel(){\n  initComponents();\n}\n"}]
[{"role": "summary", "content": "This method checks if the context for a given window number is set to \"AutoNew\" in the properties. It first throws an exception if the context is null. It then retrieves the context value for the specified window number, checking if it is \"Y\". If it is, the method returns true; otherwise, it returns false. If the context is not set to \"AutoNew\", it calls itself recursively to check the context for other windows."}, {"role": "code", "content": "public static boolean isAutoNew(Properties ctx,int WindowNo){\n  if (ctx == null)   throw new IllegalArgumentException(\"Require Context\");\n  String s=getContext(ctx,WindowNo,\"AutoNew\",false);\n  if (s != null) {\n    if (s.equals(\"Y\"))     return true;\n else     return false;\n  }\n  return isAutoNew(ctx);\n}\n"}]
[{"role": "summary", "content": "The `IoTHubTransportMqtt_Unsubscribe_DeviceMethod` function is a helper function that calls the `IoTHubTransport_MQTT_Common_Unsubscribe_DeviceMethod` function to unsubscribe a device from a MQTT topic."}, {"role": "code", "content": "static void IoTHubTransportMqtt_Unsubscribe_DeviceMethod(IOTHUB_DEVICE_HANDLE handle)\n{\n    IoTHubTransport_MQTT_Common_Unsubscribe_DeviceMethod(handle);\n}"}]
[{"role": "summary", "content": "This function copies the socket settings from the client socket (`clcsock->sk`) to the server socket (`smc->sk`) for the `smc_sock` object. The settings are copied using the `SK_FLAGS_CLC_TO_SMC` flag."}, {"role": "code", "content": "static void smc_copy_sock_settings_to_smc(struct smc_sock *smc)\n{\n\tsmc_copy_sock_settings(&smc->sk, smc->clcsock->sk, SK_FLAGS_CLC_TO_SMC);\n}"}]
[{"role": "summary", "content": "This function attempts to create a new `DeviceState` object for a given `BusState` object and name. If the creation is successful, it returns the `DeviceState` pointer. If the creation fails, it reports an error and terminates the program."}, {"role": "code", "content": "DeviceState *qdev_create(BusState *bus, const char *name)\n{\n    DeviceState *dev;\n\n    dev = qdev_try_create(bus, name);\n    if (!dev) {\n        if (bus) {\n            error_report(\"Unknown device '%s' for bus '%s'\", name,\n                         object_get_typename(OBJECT(bus)));\n        } else {\n            error_report(\"Unknown device '%s' for default sysbus\", name);\n        }\n        abort();\n    }\n\n    return dev;\n}"}]
[{"role": "summary", "content": "This method `refresh` takes a `long` parameter `expirationDateMs` and returns a new `HeldLocksGrant` object with the same `grantId`, `creationDateMs`, `expirationDateMs`, `lockMap`, `lockTimeout`, and `versionId` as the original `HeldLocksGrant` object."}, {"role": "code", "content": "public HeldLocksGrant refresh(long expirationDateMs){\n  return new HeldLocksGrant(grantId,creationDateMs,expirationDateMs,lockMap,lockTimeout,versionId);\n}\n"}]
[{"role": "summary", "content": "This function disconnects a Roccat device with the specified minor number. It first acquires a lock to prevent concurrent access to the device structure. It then checks if the device exists and sets its `exist` flag to 0. Next, it deletes the device from the list of devices. After that, it releases the lock. If the device is open, it closes the HID handle and wakes up the waiting thread. If the device is not open, it frees the device structure."}, {"role": "code", "content": "void roccat_disconnect(int minor)\n{\n\tstruct roccat_device *device;\n\n\tmutex_lock(&devices_lock);\n\tdevice = devices[minor];\n\tmutex_unlock(&devices_lock);\n\n\tdevice->exist = 0; /* TODO exist maybe not needed */\n\n\tdevice_destroy(device->dev->class, MKDEV(roccat_major, minor));\n\n\tmutex_lock(&devices_lock);\n\tdevices[minor] = NULL;\n\tmutex_unlock(&devices_lock);\n\n\tif (device->open) {\n\t\thid_hw_close(device->hid);\n\t\twake_up_interruptible(&device->wait);\n\t} else {\n\t\tkfree(device);\n\t}\n}"}]
[{"role": "summary", "content": "This method calculates the minimum layout size for a container by determining the minimum width and height based on the container's insets. It ensures that the calculated size does not exceed the container's available space."}, {"role": "code", "content": "public Dimension minimumLayoutSize(Container target){\n  Dimension size;\nsynchronized (this) {\n    checkContainer(target);\n    checkRequests();\n    size=new Dimension(xTotal.minimum,yTotal.minimum);\n  }\n  Insets insets=target.getInsets();\n  size.width=(int)Math.min((long)size.width + (long)insets.left + (long)insets.right,Integer.MAX_VALUE);\n  size.height=(int)Math.min((long)size.height + (long)insets.top + (long)insets.bottom,Integer.MAX_VALUE);\n  return size;\n}\n"}]
[{"role": "summary", "content": "This function, `rproc_auto_boot_callback`, is a callback function designed to handle the auto-boot process for a Raspberry Pi. It takes a pointer to a `struct firmware` object (`fw`) and a context (`void *context`). The function initializes a `struct rproc` pointer to the context (`rproc = context`). It then calls the `rproc_boot` function on the `rproc` pointer to initiate the auto-boot process. Finally, it releases the `firmware` object (`release_firmware(fw)`) to free any allocated resources."}, {"role": "code", "content": "static void rproc_auto_boot_callback(const struct firmware *fw, void *context)\n{\n\tstruct rproc *rproc = context;\n\n\trproc_boot(rproc);\n\n\trelease_firmware(fw);\n}"}]
[{"role": "summary", "content": "This test case checks if a `BigInteger` object is correctly constructed with a negative sign and a byte array representation of its digits. It compares the resulting byte array with the expected byte array and asserts that the sign of the `BigInteger` matches the expected sign."}, {"role": "code", "content": "public void testConstructorSignBytesNegative3(){\n  byte aBytes[]={-12,56,100};\n  int aSign=-1;\n  byte rBytes[]={-1,11,-57,-100};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=aNumber.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",-1,aNumber.signum());\n}\n"}]
[{"role": "summary", "content": "This method creates a new `StringBuilder` object, then iterates `count` times, appending a random character from `CHARACTERS` to the `StringBuilder`. Finally, it returns the resulting string as a `String`."}, {"role": "code", "content": "public static String generateStringOfCharacters(int count){\n  StringBuilder sb=new StringBuilder();\n  for (int i=0; i < count; i++) {\n    sb.append(CHARACTERS.charAt((int)(Math.random() * CHARACTERS.length())));\n  }\n  return sb.toString();\n}\n"}]
[{"role": "summary", "content": "This code snippet creates a list of GridField objects based on a SQL query that retrieves fields from a specific AD_Tab_ID. It then populates the list with GridFieldVO objects, which are created using the provided context. The resulting GridField objects are stored in an array and returned as the final output."}, {"role": "code", "content": "public static GridField[] createFields(Properties ctx,int WindowNo,int TabNo,int AD_Tab_ID){\n  ArrayList<GridFieldVO> listVO=new ArrayList<GridFieldVO>();\n  int AD_Window_ID=0;\n  boolean readOnly=false;\n  String sql=GridFieldVO.getSQL(ctx);\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,AD_Tab_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      GridFieldVO vo=GridFieldVO.create(ctx,WindowNo,TabNo,AD_Window_ID,AD_Tab_ID,readOnly,rs);\n      listVO.add(vo);\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n  GridField[] retValue=new GridField[listVO.size()];\n  for (int i=0; i < listVO.size(); i++)   retValue[i]=new GridField((GridFieldVO)listVO.get(i));\n  return retValue;\n}\n"}]
[{"role": "summary", "content": "The `FormatSpecifierParser` constructor takes a `String` parameter `format` and initializes two instance variables: `this.format` with the value of `format`, and `this.length` with the length of `format`."}, {"role": "code", "content": "FormatSpecifierParser(String format){\n  this.format=format;\n  this.length=format.length();\n}\n"}]
[{"role": "summary", "content": "The `clear` method clears the current scope by finding all elements matching the specified CSS selector and then iterating over them, setting them to `null`. It returns itself to allow for chaining of method calls.\n\n```java\npublic AemParsys clear() {\n  List<WebElement> list = currentScope.findElements(By.cssSelector(SELECTOR_FOR_COMPONENT_IN_PARSYS));\n  list.forEach(null);\n  return this;\n}\n```"}, {"role": "code", "content": "public AemParsys clear(){\n  List<WebElement> list=currentScope.findElements(By.cssSelector(SELECTOR_FOR_COMPONENT_IN_PARSYS));\n  list.forEach(null);\n  return this;\n}\n"}]
[{"role": "summary", "content": "This function updates the effective user ID (`euid`), effective group ID (`egid`), and user ID (`uid`) of the calling process. It first retrieves the current values of `euid` and `egid`. Then, it sets the new values using `OURSYS_setresgid` and `OURSYS_setresuid` system calls. If either call fails, it rolls back the changes by restoring the original `egid` and `uid` values using `OURSYS_setresgid` and `OURSYS_setresuid` system calls, respectively, and returns the original error number. If both calls are successful, it returns 0."}, {"role": "code", "content": "static int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}"}]
[{"role": "summary", "content": "The `isServerTransaction` method checks if the current object is an instance of `SIPServerTransaction`."}, {"role": "code", "content": "protected boolean isServerTransaction(){\n  return this instanceof SIPServerTransaction;\n}\n"}]
[{"role": "summary", "content": "This function, `dss_check_settings_apply`, calls `dss_check_settings_low` with the argument `true`. The purpose of this function is to check the settings for the DSS (Display Streaming System) overlay and apply any necessary changes."}, {"role": "code", "content": "static int dss_check_settings_apply(struct omap_overlay_manager *mgr)\n{\n\treturn dss_check_settings_low(mgr, true);\n}"}]
[{"role": "summary", "content": "This method calculates the number of transitions between two points on a 2D image. It first determines the differences in x and y coordinates between the two points. If the y-coordinate difference is greater than the x-coordinate difference, it swaps the coordinates. It then calculates the differences in x and y for the number of transitions needed. It iterates through the image, checking if the color of the pixel at each point is different from the previous point. If it is, it increments the transition count and updates the color check. If the error exceeds 0, it adjusts the y-coordinate and the error accordingly. Finally, it returns a new ResultPointsAndTransitions object containing the original points and the number of transitions."}, {"role": "code", "content": "private ResultPointsAndTransitions transitionsBetween(ResultPoint from,ResultPoint to){\n  int fromX=(int)from.getX();\n  int fromY=(int)from.getY();\n  int toX=(int)to.getX();\n  int toY=(int)to.getY();\n  boolean steep=Math.abs(toY - fromY) > Math.abs(toX - fromX);\n  if (steep) {\n    int temp=fromX;\n    fromX=fromY;\n    fromY=temp;\n    temp=toX;\n    toX=toY;\n    toY=temp;\n  }\n  int dx=Math.abs(toX - fromX);\n  int dy=Math.abs(toY - fromY);\n  int error=-dx >> 1;\n  int ystep=fromY < toY ? 1 : -1;\n  int xstep=fromX < toX ? 1 : -1;\n  int transitions=0;\n  boolean inBlack=image.get(steep ? fromY : fromX,steep ? fromX : fromY);\n  for (int x=fromX, y=fromY; x != toX; x+=xstep) {\n    boolean isBlack=image.get(steep ? y : x,steep ? x : y);\n    if (isBlack != inBlack) {\n      transitions++;\n      inBlack=isBlack;\n    }\n    error+=dy;\n    if (error > 0) {\n      if (y == toY) {\n        break;\n      }\n      y+=ystep;\n      error-=dx;\n    }\n  }\n  return new ResultPointsAndTransitions(from,to,transitions);\n}\n"}]
[{"role": "summary", "content": "The function `exe_context` takes a context `c` and returns the bitwise OR of `c_atomic`, `c_executable`, and `c_constant` flags. This means it combines the flags to create a new context that includes all three."}, {"role": "code", "content": "context exe_context(context c)\n{\n  return c & (c_atomic | c_executable | c_constant);\n}"}]
[{"role": "summary", "content": "This method, `renderFrame`, is a native function that takes an array of pixels (`pixels`), a pointer to a GIF file (`gifFileInPtr`), and an array of meta data (`metaData`) as input. It returns a boolean value indicating whether the rendering was successful. The method is likely used to display a GIF image on a screen or elsewhere."}, {"role": "code", "content": "private static native boolean renderFrame(int[] pixels,long gifFileInPtr,int[] metaData);\n"}]
[{"role": "summary", "content": "This method updates or creates a source entry for a user. It checks for null values in the provided parameters and handles them accordingly. If the entry does not exist, it creates a new one with the provided details, cleans up the URL and title, and sets the modTime and createTime. If the user cannot modify the entry, it throws an error. The method returns the updated or created source entry."}, {"role": "code", "content": "public Entry updateOrCreateSource(User user,String id,String url,String title,Long modTime,Long createTime,boolean isAdmin,Errors errors){\n  if (user == null) {\n    Errors.add(errors,errorMessages.errorUserIsNull());\n    return null;\n  }\n  if (url == null) {\n    Errors.add(errors,errorMessages.errorUrlIsNull());\n    return null;\n  }\n  Entry source=getEntryByUserIdAndUrl(user.getId(),url);\n  if (source == null) {\n    if (url.isEmpty()) {\n      Errors.add(errors,errorMessages.errorUrlIsEmpty());\n      return null;\n    }\n    if (title == null) {\n      Errors.add(errors,errorMessages.errorTitleIsNull());\n      return null;\n    }\n    if (title.isEmpty()) {\n      Errors.add(errors,errorMessages.errorTitleIsEmpty());\n      return null;\n    }\n    if (modTime == null) {\n      Errors.add(errors,errorMessages.errorModTimeIsNull());\n      return null;\n    }\n    if (createTime == null) {\n      Errors.add(errors,errorMessages.errorCreateTimeIsNull());\n      return null;\n    }\n    if (id != null && !idGenerator.isIdWellFormed(id)) {\n      Errors.add(errors,errorMessages.errorIdIsInvalid());\n      return null;\n    }\n    if (createTime.longValue() > modTime.longValue()) {\n      modTime=createTime;\n    }\n    if (url != null) {\n      url=cleanUpText(url);\n    }\n    if (title != null) {\n      title=cleanUpText(title);\n    }\n    source=new Entry();\n    source.setDb(db);\n    if (id == null) {\n      id=idGenerator.getAnotherId();\n    }\n    source.setId(id);\n    source.setSourceUrl(url);\n    source.setSourceTitle(title);\n    source.setCreateTime(createTime);\n    source.setType(Constants.source);\n    source.setUserId(user.getId());\n    db.persistEntry(source);\n  }\n else   if (!canUserModifyEntry(user,source,isAdmin)) {\n    Errors.add(errors,errorMessages.errorUserIsNotEntitledToModifyTheSource());\n    return null;\n  }\n  source.setModTime(modTime);\n  return source;\n}\n"}]
[{"role": "summary", "content": "This method unpacks a CMap from a packed string. It creates a new array of 0x10000 characters, initializes two pointers, and iterates through the packed string. It counts the number of characters in each block and assigns the corresponding character to the map array. The method returns the unpacked CMap."}, {"role": "code", "content": "private static char[] zzUnpackCMap(String packed){\n  char[] map=new char[0x10000];\n  int i=0;\n  int j=0;\n  while (i < 150) {\n    int count=packed.charAt(i++);\n    char value=packed.charAt(i++);\n    do     map[j++]=value;\n while (--count > 0);\n  }\n  return map;\n}\n"}]
[{"role": "summary", "content": "This code snippet formats a floating-point number into a string with a specified number of digits, including a decimal point if necessary. It handles negative numbers, zeros, and separates thousands if required. The function returns a formatted string representation of the number."}, {"role": "code", "content": "public static String formatNumber(float number,int digitCount,boolean separateThousands){\n  char[] out=new char[35];\n  boolean neg=false;\n  if (number == 0) {\n    return \"0\";\n  }\n  boolean zero=false;\n  if (number < 1 && number > -1) {\n    zero=true;\n  }\n  if (number < 0) {\n    neg=true;\n    number=-number;\n  }\n  if (digitCount > POW_10.length) {\n    digitCount=POW_10.length - 1;\n  }\n  number*=POW_10[digitCount];\n  long lval=Math.round(number);\n  int ind=out.length - 1;\n  int charCount=0;\n  boolean decimalPointAdded=false;\n  while (lval != 0 || charCount < (digitCount + 1)) {\n    int digit=(int)(lval % 10);\n    lval=lval / 10;\n    out[ind--]=(char)(digit + '0');\n    charCount++;\n    if (charCount == digitCount) {\n      out[ind--]=',';\n      charCount++;\n      decimalPointAdded=true;\n    }\n else     if (separateThousands && lval != 0 && charCount > digitCount) {\n      if (decimalPointAdded) {\n        if ((charCount - digitCount) % 4 == 0) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n else {\n        if ((charCount - digitCount) % 4 == 3) {\n          out[ind--]='.';\n          charCount++;\n        }\n      }\n    }\n  }\n  if (zero) {\n    out[ind--]='0';\n    charCount+=1;\n  }\n  if (neg) {\n    out[ind--]='-';\n    charCount+=1;\n  }\n  int start=out.length - charCount;\n  return String.valueOf(out,start,out.length - start);\n}\n"}]
[{"role": "summary", "content": "This code snippet defines a method `encode` that takes a list of `AclEntry` objects and a long address as parameters. It encodes each `AclEntry` into a binary format, storing the entry's principal, type, permissions, and flags in a buffer. The method uses unsafe operations to ensure efficient memory access."}, {"role": "code", "content": "private static void encode(List<AclEntry> acl,long address){\n  long offset=address;\n  for (  AclEntry ace : acl) {\n    int flags=0;\n    UserPrincipal who=ace.principal();\n    if (!(who instanceof UnixUserPrincipals.User))     throw new ProviderMismatchException();\n    UnixUserPrincipals.User user=(UnixUserPrincipals.User)who;\n    int uid;\n    if (user.isSpecial()) {\n      uid=-1;\n      if (who == UnixUserPrincipals.SPECIAL_OWNER)       flags|=ACE_OWNER;\n else       if (who == UnixUserPrincipals.SPECIAL_GROUP)       flags|=(ACE_GROUP | ACE_IDENTIFIER_GROUP);\n else       if (who == UnixUserPrincipals.SPECIAL_EVERYONE)       flags|=ACE_EVERYONE;\n else       throw new AssertionError(\"Unable to map special identifier\");\n    }\n else {\n      if (user instanceof UnixUserPrincipals.Group) {\n        uid=user.gid();\n        flags|=ACE_IDENTIFIER_GROUP;\n      }\n else {\n        uid=user.uid();\n      }\n    }\n    int type;\nswitch (ace.type()) {\ncase ALLOW:\n      type=ACE_ACCESS_ALLOWED_ACE_TYPE;\n    break;\ncase DENY:\n  type=ACE_ACCESS_DENIED_ACE_TYPE;\nbreak;\ncase AUDIT:\ntype=ACE_SYSTEM_AUDIT_ACE_TYPE;\nbreak;\ncase ALARM:\ntype=ACE_SYSTEM_ALARM_ACE_TYPE;\nbreak;\ndefault :\nthrow new AssertionError(\"Unable to map ACE type\");\n}\nSet<AclEntryPermission> aceMask=ace.permissions();\nint mask=0;\nif (aceMask.contains(AclEntryPermission.READ_DATA)) mask|=ACE_READ_DATA;\nif (aceMask.contains(AclEntryPermission.WRITE_DATA)) mask|=ACE_WRITE_DATA;\nif (aceMask.contains(AclEntryPermission.APPEND_DATA)) mask|=ACE_APPEND_DATA;\nif (aceMask.contains(AclEntryPermission.READ_NAMED_ATTRS)) mask|=ACE_READ_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.WRITE_NAMED_ATTRS)) mask|=ACE_WRITE_NAMED_ATTRS;\nif (aceMask.contains(AclEntryPermission.EXECUTE)) mask|=ACE_EXECUTE;\nif (aceMask.contains(AclEntryPermission.DELETE_CHILD)) mask|=ACE_DELETE_CHILD;\nif (aceMask.contains(AclEntryPermission.READ_ATTRIBUTES)) mask|=ACE_READ_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.WRITE_ATTRIBUTES)) mask|=ACE_WRITE_ATTRIBUTES;\nif (aceMask.contains(AclEntryPermission.DELETE)) mask|=ACE_DELETE;\nif (aceMask.contains(AclEntryPermission.READ_ACL)) mask|=ACE_READ_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_ACL)) mask|=ACE_WRITE_ACL;\nif (aceMask.contains(AclEntryPermission.WRITE_OWNER)) mask|=ACE_WRITE_OWNER;\nif (aceMask.contains(AclEntryPermission.SYNCHRONIZE)) mask|=ACE_SYNCHRONIZE;\nSet<AclEntryFlag> aceFlags=ace.flags();\nif (aceFlags.contains(AclEntryFlag.FILE_INHERIT)) flags|=ACE_FILE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.DIRECTORY_INHERIT)) flags|=ACE_DIRECTORY_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.NO_PROPAGATE_INHERIT)) flags|=ACE_NO_PROPAGATE_INHERIT_ACE;\nif (aceFlags.contains(AclEntryFlag.INHERIT_ONLY)) flags|=ACE_INHERIT_ONLY_ACE;\nunsafe.putInt(offset + OFFSETOF_UID,uid);\nunsafe.putInt(offset + OFFSETOF_MASK,mask);\nunsafe.putShort(offset + OFFSETOF_FLAGS,(short)flags);\nunsafe.putShort(offset + OFFSETOF_TYPE,(short)type);\noffset+=SIZEOF_ACE_T;\n}\n}\n"}]
[{"role": "summary", "content": "This code snippet defines a method `referenceToAttribute` that takes a string `attrib` and a boolean `includeDummies`. It processes the string to remove backslashes, check for dollar signs, and clean up nested braces. If the string is not properly formatted, it returns `null`."}, {"role": "code", "content": "@Nullable private static String referenceToAttribute(String attrib,boolean includeDummies){\n  while (attrib.startsWith(\"\\\\\\\\\")) {\n    attrib=attrib.substring(2);\n  }\n  if (attrib.startsWith(\"\\\\$\")) {\n    if (includeDummies) {\n      attrib=attrib.substring(1);\n    }\n else     return null;\n  }\n  if (!StringUtil.startsWithChar(attrib,'$')) {\n    return null;\n  }\n  attrib=attrib.substring(1);\n  if (StringUtil.startsWithChar(attrib,'{')) {\n    String cleanAttribute=null;\n    for (int i=1; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '.') {\n        cleanAttribute=null;\n        break;\n      }\n else       if (currChar == '}') {\n        cleanAttribute=attrib.substring(1,i);\n        break;\n      }\n    }\n    attrib=cleanAttribute;\n  }\n else {\n    for (int i=0; i < attrib.length(); i++) {\n      char currChar=attrib.charAt(i);\n      if (currChar == '{' || currChar == '}' || currChar == '.') {\n        attrib=attrib.substring(0,i);\n        break;\n      }\n    }\n  }\n  return attrib;\n}\n"}]
[{"role": "summary", "content": "This function, `Symbol_count`, returns the count of symbols from an object `x2a`. If `x2a` is not `nullptr`, it returns the value of `x2a->count`. Otherwise, it returns 0."}, {"role": "code", "content": "int Symbol_count()\n{\n  return x2a ? x2a->count : 0;\n}"}]
[{"role": "summary", "content": "The `last_window()` function checks if there is a window on the first tabpage and if the next tabpage is the last one in the list."}, {"role": "code", "content": "last_window()\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}"}]
[{"role": "summary", "content": "This function checks if the `am_tablesync_worker()` function is currently running. If it is, it calls `process_syncing_tables_for_sync(current_lsn)`. If not, it calls `process_syncing_tables_for_apply(current_lsn)`."}, {"role": "code", "content": "process_syncing_tables(XLogRecPtr current_lsn)\n{\n\tif (am_tablesync_worker())\n\t\tprocess_syncing_tables_for_sync(current_lsn);\n\telse\n\t\tprocess_syncing_tables_for_apply(current_lsn);\n}"}]
[{"role": "summary", "content": "This function checks if the machine is compatible with the MPC834xMDS chip by calling `of_machine_is_compatible(\"MPC834xMDS\")`. If the machine is compatible, it returns 1; otherwise, it returns 0."}, {"role": "code", "content": "static int __init mpc834x_mds_probe(void)\n{\n\treturn of_machine_is_compatible(\"MPC834xMDS\");\n}"}]
[{"role": "summary", "content": "The `eckeydh_can_do` function checks if the provided `type` is either `MBEDTLS_PK_ECKEY` or `MBEDTLS_PK_ECKEY_DH`."}, {"role": "code", "content": "static int eckeydh_can_do( mbedtls_pk_type_t type )\n{\n    return( type == MBEDTLS_PK_ECKEY ||\n            type == MBEDTLS_PK_ECKEY_DH );\n}"}]
[{"role": "summary", "content": "The function `die_will_crash` checks for conditions that might cause a system to crash. It returns `true` if any of the following conditions are met:\n- `should_fadump_crash()` returns `true`.\n- `kexec_should_crash(current)` returns `true`.\n- The system is in an interrupt state (`in_interrupt()`) or is in a panic mode (`panic_on_oops`).\n- The current process (`current->pid`) is not running or is a global initialization process (`is_global_init(current)`)."}, {"role": "code", "content": "bool die_will_crash(void)\n{\n\tif (should_fadump_crash())\n\t\treturn true;\n\tif (kexec_should_crash(current))\n\t\treturn true;\n\tif (in_interrupt() || panic_on_oops ||\n\t\t\t!current->pid || is_global_init(current))\n\t\treturn true;\n\n\treturn false;\n}"}]
[{"role": "summary", "content": "This method handles the end of an element in an XML document. It checks if the element is in an entity reference, pops namespaces from the prefix map, and writes the closing tag. It also processes attributes, closes CDATA sections, and updates the context and state variables accordingly. If there is a tracer, it fires a start element event. After processing, it updates the state variables and context."}, {"role": "code", "content": "public void endElement(String namespaceURI,String localName,String name) throws org.xml.sax.SAXException {\n  if (m_inEntityRef)   return;\n  m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth,null);\n  try {\n    final java.io.Writer writer=m_writer;\n    if (m_elemContext.m_startTagOpen) {\n      if (m_tracer != null)       super.fireStartElem(m_elemContext.m_elementName);\n      int nAttrs=m_attributes.getLength();\n      if (nAttrs > 0) {\n        processAttributes(m_writer,nAttrs);\n        m_attributes.clear();\n      }\n      if (m_spaceBeforeClose)       writer.write(\" />\");\n else       writer.write(\"/>\");\n    }\n else {\n      if (m_cdataTagOpen)       closeCDATA();\n      if (shouldIndent())       indent(m_elemContext.m_currentElemDepth - 1);\n      writer.write('<');\n      writer.write('/');\n      writer.write(name);\n      writer.write('>');\n    }\n  }\n catch (  IOException e) {\n    throw new SAXException(e);\n  }\n  if (!m_elemContext.m_startTagOpen && m_doIndent) {\n    m_ispreserve=m_preserves.isEmpty() ? false : m_preserves.pop();\n  }\n  m_isprevtext=false;\n  if (m_tracer != null)   super.fireEndElem(name);\n  m_elemContext=m_elemContext.m_prev;\n}\n"}]
[{"role": "summary", "content": "This function sets the size of the PE auxiliary memory to a given value. It checks if the size is negative and returns if it is. Otherwise, it stores the size in the `eeh_pe_aux_size` variable."}, {"role": "code", "content": "void eeh_set_pe_aux_size(int size)\n{\n\tif (size < 0)\n\t\treturn;\n\n\teeh_pe_aux_size = size;\n}"}]
[{"role": "summary", "content": "The `InitServerLast` function initializes the server by setting up bio_init, threaded I/O, and configuring the background thread for JEMalloc. It also calculates the initial memory usage by using `zalloc_used_memory()`."}, {"role": "code", "content": "void InitServerLast() {\n    bioInit();\n    initThreadedIO();\n    set_jemalloc_bg_thread(server.jemalloc_bg_thread);\n    server.initial_memory_usage = zmalloc_used_memory();\n}"}]
[{"role": "summary", "content": "The `init` method in the `GuiManualHerblore` class is designed to initialize a list of `ManualWidgetBase` objects. It iterates over each object in the `widgets` list and calls the `init` method on each one, passing the `manual` parameter."}, {"role": "code", "content": "public void init(GuiManualHerblore manual){\n  for (  ManualWidgetBase widget : widgets)   widget.init(manual);\n}\n"}]
[{"role": "summary", "content": "This code implements a solver for the least squares support vector regression (L2R-L1L2-SVR) problem. It uses a gradient descent algorithm with a penalty term for the number of support vectors. The algorithm iteratively updates the weights and the parameters to minimize the objective function. The code also includes a feature selection step to determine which features are most important for the prediction. The final objective value and the number of support vectors are reported."}, {"role": "code", "content": "private static void solve_l2r_l1l2_svr(Problem prob,double[] w,Parameter param){\n  int l=prob.l;\n  double C=param.C;\n  double p=param.p;\n  int w_size=prob.n;\n  double eps=param.eps;\n  int i, s, iter=0;\n  int max_iter=1000;\n  int active_size=l;\n  int[] index=new int[l];\n  double d, G, H;\n  double Gmax_old=Double.POSITIVE_INFINITY;\n  double Gmax_new, Gnorm1_new;\n  double Gnorm1_init=0;\n  double[] beta=new double[l];\n  double[] QD=new double[l];\n  double[] y=prob.y;\n  double[] lambda=new double[]{0.5 / C};\n  double[] upper_bound=new double[]{Double.POSITIVE_INFINITY};\n  if (param.solverType == SolverType.L2R_L1LOSS_SVR_DUAL) {\n    lambda[0]=0;\n    upper_bound[0]=C;\n  }\n  for (i=0; i < l; i++) {\n    beta[i]=0;\n  }\n  for (i=0; i < w_size; i++) {\n    w[i]=0;\n  }\n  for (i=0; i < l; i++) {\n    QD[i]=0;\n    for (    Feature xi : prob.x[i]) {\n      double val=xi.getValue();\n      QD[i]+=val * val;\n      w[xi.getIndex() - 1]+=beta[i] * val;\n    }\n    index[i]=i;\n  }\n  while (iter < max_iter) {\n    Gmax_new=0;\n    Gnorm1_new=0;\n    for (i=0; i < active_size; i++) {\n      int j=i + random.nextInt(active_size - i);\n      swap(index,i,j);\n    }\n    for (s=0; s < active_size; s++) {\n      i=index[s];\n      G=-y[i] + lambda[GETI_SVR(i)] * beta[i];\n      H=QD[i] + lambda[GETI_SVR(i)];\n      for (      Feature xi : prob.x[i]) {\n        int ind=xi.getIndex() - 1;\n        double val=xi.getValue();\n        G+=val * w[ind];\n      }\n      double Gp=G + p;\n      double Gn=G - p;\n      double violation=0;\n      if (beta[i] == 0) {\n        if (Gp < 0) {\n          violation=-Gp;\n        }\n else         if (Gn > 0) {\n          violation=Gn;\n        }\n else         if (Gp > Gmax_old && Gn < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] >= upper_bound[GETI_SVR(i)]) {\n        if (Gp > 0) {\n          violation=Gp;\n        }\n else         if (Gp < -Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] <= -upper_bound[GETI_SVR(i)]) {\n        if (Gn < 0) {\n          violation=-Gn;\n        }\n else         if (Gn > Gmax_old) {\n          active_size--;\n          swap(index,s,active_size);\n          s--;\n          continue;\n        }\n      }\n else       if (beta[i] > 0) {\n        violation=Math.abs(Gp);\n      }\n else {\n        violation=Math.abs(Gn);\n      }\n      Gmax_new=Math.max(Gmax_new,violation);\n      Gnorm1_new+=violation;\n      if (Gp < H * beta[i]) {\n        d=-Gp / H;\n      }\n else       if (Gn > H * beta[i]) {\n        d=-Gn / H;\n      }\n else {\n        d=-beta[i];\n      }\n      if (Math.abs(d) < 1.0e-12) {\n        continue;\n      }\n      double beta_old=beta[i];\n      beta[i]=Math.min(Math.max(beta[i] + d,-upper_bound[GETI_SVR(i)]),upper_bound[GETI_SVR(i)]);\n      d=beta[i] - beta_old;\n      if (d != 0) {\n        for (        Feature xi : prob.x[i]) {\n          w[xi.getIndex() - 1]+=d * xi.getValue();\n        }\n      }\n    }\n    if (iter == 0) {\n      Gnorm1_init=Gnorm1_new;\n    }\n    iter++;\n    if (iter % 10 == 0) {\n      info(\".\");\n    }\n    if (Gnorm1_new <= eps * Gnorm1_init) {\n      if (active_size == l) {\n        break;\n      }\n else {\n        active_size=l;\n        info(\"*\");\n        Gmax_old=Double.POSITIVE_INFINITY;\n        continue;\n      }\n    }\n    Gmax_old=Gmax_new;\n  }\n  info(\"%noptimization finished, #iter = %d%n\",iter);\n  if (iter >= max_iter) {\n    info(\"%nWARNING: reaching max number of iterations%nUsing -s 11 may be faster%n%n\");\n  }\n  double v=0;\n  int nSV=0;\n  for (i=0; i < w_size; i++) {\n    v+=w[i] * w[i];\n  }\n  v=0.5 * v;\n  for (i=0; i < l; i++) {\n    v+=p * Math.abs(beta[i]) - y[i] * beta[i] + 0.5 * lambda[GETI_SVR(i)] * beta[i]* beta[i];\n    if (beta[i] != 0) {\n      nSV++;\n    }\n  }\n  info(\"Objective value = %g%n\",v);\n  info(\"nSV = %d%n\",nSV);\n}\n"}]
[{"role": "summary", "content": "This function calculates the maximum delay by subtracting the base RTT from the maximum RTT in the `ca` structure."}, {"role": "code", "content": "static inline u32 max_delay(const struct illinois *ca)\n{\n\treturn ca->max_rtt - ca->base_rtt;\n}"}]
[{"role": "summary", "content": "This method refills the yy_buffer when necessary, copying the current content to a new buffer if the current position exceeds the buffer's length. It then reads new data from the input source and updates the end position of the buffer. If the read operation fails (i.e., returns a negative number), the method returns true, indicating an error. Otherwise, it returns false and updates the end position."}, {"role": "code", "content": "private boolean yy_refill() throws java.io.IOException {\n  if (yy_startRead > 0) {\n    System.arraycopy(yy_buffer,yy_startRead,yy_buffer,0,yy_endRead - yy_startRead);\n    yy_endRead-=yy_startRead;\n    yy_currentPos-=yy_startRead;\n    yy_markedPos-=yy_startRead;\n    yy_pushbackPos-=yy_startRead;\n    yy_startRead=0;\n  }\n  if (yy_currentPos >= yy_buffer.length) {\n    char newBuffer[]=new char[yy_currentPos * 2];\n    System.arraycopy(yy_buffer,0,newBuffer,0,yy_buffer.length);\n    yy_buffer=newBuffer;\n  }\n  int numRead=yy_reader.read(yy_buffer,yy_endRead,yy_buffer.length - yy_endRead);\n  if (numRead < 0) {\n    return true;\n  }\n else {\n    yy_endRead+=numRead;\n    return false;\n  }\n}\n"}]
[{"role": "summary", "content": "This function opens a configuration file for a virtual private server (vpsid) with the given extension (ext). If the function fails to locate the configuration directory, it returns -1. Otherwise, it creates a new string with the path to the configuration file and returns it."}, {"role": "code", "content": "openvzLocateConfFileDefault(int vpsid, char **conffile, const char *ext)\n{\n    char *confdir;\n    int ret = 0;\n\n    confdir = openvzLocateConfDir();\n    if (confdir == NULL)\n        return -1;\n\n    *conffile = g_strdup_printf(\"%s/%d.%s\", confdir, vpsid, ext ? ext : \"conf\");\n\n    VIR_FREE(confdir);\n    return ret;\n}"}]
[{"role": "summary", "content": "This code tests the `IgnitePredicate` functionality by loading classes from different class loaders and executing a task that filters nodes based on a predicate. It asserts that the predicate correctly identifies the local node and that the results are consistent across different class loaders."}, {"role": "code", "content": "@SuppressWarnings(\"unchecked\") public void testProjectionPredicateDifferentClassLoaders() throws Exception {\n  final Ignite ignite3=startGrid(3);\n  URL[] clsLdrUrls;\n  try {\n    clsLdrUrls=new URL[]{new URL(GridTestProperties.getProperty(\"p2p.uri.cls\"))};\n  }\n catch (  MalformedURLException e) {\n    throw new RuntimeException(\"Define property p2p.uri.cls\",e);\n  }\n  ClassLoader ldr1=new URLClassLoader(clsLdrUrls,getClass().getClassLoader());\n  Class taskCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.JobStealingTask\");\n  Class nodeFilterCls=ldr1.loadClass(\"org.apache.ignite.tests.p2p.ExcludeNodeFilter\");\n  IgnitePredicate<ClusterNode> nodeFilter=(IgnitePredicate<ClusterNode>)nodeFilterCls.getConstructor(UUID.class).newInstance(ignite2.cluster().localNode().id());\n  Map<UUID,Integer> ret=(Map<UUID,Integer>)executeAsync(compute(ignite1.cluster().forPredicate(nodeFilter)),taskCls,null).get(TASK_EXEC_TIMEOUT_MS);\n  assert ret != null;\n  assert ret.get(ignite1.cluster().localNode().id()) != null && ret.get(ignite1.cluster().localNode().id()) == 2 : ret.get(ignite1.cluster().localNode().id());\n  assert ret.get(ignite3.cluster().localNode().id()) != null && ret.get(ignite3.cluster().localNode().id()) == 2 : ret.get(ignite3.cluster().localNode().id());\n}\n"}]
[{"role": "summary", "content": "This method attempts to convert an integer to a specific type based on the value of `t`. It uses a switch statement to determine the type and casts the input accordingly. If the type is not recognized, it throws an exception with an error message."}, {"role": "code", "content": "public Object castToType(int t,XPathContext support) throws javax.xml.transform.TransformerException {\n  Object result;\nswitch (t) {\ncase CLASS_STRING:\n    result=str();\n  break;\ncase CLASS_NUMBER:\nresult=new Double(num());\nbreak;\ncase CLASS_NODESET:\nresult=iter();\nbreak;\ncase CLASS_BOOLEAN:\nresult=new Boolean(bool());\nbreak;\ncase CLASS_UNKNOWN:\nresult=m_obj;\nbreak;\ndefault :\nerror(XPATHErrorResources.ER_CANT_CONVERT_TO_TYPE,new Object[]{getTypeString(),Integer.toString(t)});\nresult=null;\n}\nreturn result;\n}\n"}]
[{"role": "summary", "content": "The `journalRebuildRequired` method checks if a journal rebuild is necessary. It returns `true` if the number of redundant operations (`redundantOpCount`) is greater than or equal to the `redundantOpCompactThreshold` (2000) and also if the `redundantOpCount` is greater than or equal to the size of the `lruEntries` collection."}, {"role": "code", "content": "private boolean journalRebuildRequired(){\n  final int redundantOpCompactThreshold=2000;\n  return redundantOpCount >= redundantOpCompactThreshold && redundantOpCount >= lruEntries.size();\n}\n"}]
[{"role": "summary", "content": "This method, `fixGPSTimeStamp`, corrects the GPS timestamp in an XMP (Extensible Metadata Interchange) node by ensuring the date and time are in the correct format. It first searches for the `exif:GPSTimeStamp` node and converts its value to a `XMPDateTime` object. If the converted timestamp has a year, month, or day other than 0, it returns. If the `exif:DateTimeOriginal` or `exif:DateTimeDigitized` node is not found, it defaults to `exif:DateTimeDigitized`. It then sets the year, month, and day of the `exif:GPSTimeStamp` node to match the `exif:DateTimeOriginal` or `exif:DateTimeDigitized` node's values, and converts the `XMPDateTime` back to a string. If any error occurs during this process, it catches the exception and returns."}, {"role": "code", "content": "private static void fixGPSTimeStamp(XMPNode exifSchema) throws XMPException {\n  XMPNode gpsDateTime=XMPNodeUtils.findChildNode(exifSchema,\"exif:GPSTimeStamp\",false);\n  if (gpsDateTime == null) {\n    return;\n  }\n  try {\n    XMPDateTime binGPSStamp;\n    XMPDateTime binOtherDate;\n    binGPSStamp=XMPUtils.convertToDate(gpsDateTime.getValue());\n    if (binGPSStamp.getYear() != 0 || binGPSStamp.getMonth() != 0 || binGPSStamp.getDay() != 0) {\n      return;\n    }\n    XMPNode otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeOriginal\",false);\n    if (otherDate == null) {\n      otherDate=XMPNodeUtils.findChildNode(exifSchema,\"exif:DateTimeDigitized\",false);\n    }\n    binOtherDate=XMPUtils.convertToDate(otherDate.getValue());\n    Calendar cal=binGPSStamp.getCalendar();\n    cal.set(Calendar.YEAR,binOtherDate.getYear());\n    cal.set(Calendar.MONTH,binOtherDate.getMonth());\n    cal.set(Calendar.DAY_OF_MONTH,binOtherDate.getDay());\n    binGPSStamp=new XMPDateTimeImpl(cal);\n    gpsDateTime.setValue(XMPUtils.convertFromDate(binGPSStamp));\n  }\n catch (  XMPException e) {\n    return;\n  }\n}\n"}]
[{"role": "summary", "content": "The `descriptorForFieldSignature` method takes a `String` parameter representing a field signature and returns a new `String` by replacing all periods (`.`) with slashes (\"/\"). This method is likely used to format a field's signature for display or storage purposes, where periods are typically used to separate different parts of a name."}, {"role": "code", "content": "private static String descriptorForFieldSignature(String signature){\n  return signature.replace('.','/');\n}\n"}]
[{"role": "summary", "content": "The `formatMillis` method converts a given number of milliseconds into a string formatted as hours, minutes, and seconds. It divides the milliseconds by 3600000 to get the number of hours, then by 60000 to get the number of minutes, and finally by 1000 to get the number of seconds. It then checks if the number of hours is greater than 0 and appends it to the result string, followed by the number of minutes and seconds. If the number of minutes is greater than 9, it appends it directly; otherwise, it appends \"0\" followed by the number of minutes. Finally, it appends the number of seconds and returns the formatted string."}, {"role": "code", "content": "public static String formatMillis(int millis){\n  String result=\"\";\n  int hr=millis / 3600000;\n  millis%=3600000;\n  int min=millis / 60000;\n  millis%=60000;\n  int sec=millis / 1000;\n  if (hr > 0) {\n    result+=hr + \":\";\n  }\n  if (min >= 0) {\n    if (min > 9) {\n      result+=min + \":\";\n    }\n else {\n      result+=\"0\" + min + \":\";\n    }\n  }\n  if (sec > 9) {\n    result+=sec;\n  }\n else {\n    result+=\"0\" + sec;\n  }\n  return result;\n}\n"}]
[{"role": "summary", "content": "The function `twa_command_mapped` checks if a command is not mapped correctly or if it exceeds the minimum SGL length. It returns `true` if the command is not mapped properly or if the buffer length is greater than or equal to `TW_MIN_SGL_LENGTH`."}, {"role": "code", "content": "static bool twa_command_mapped(struct scsi_cmnd *cmd)\n{\n\treturn scsi_sg_count(cmd) != 1 ||\n\t\tscsi_bufflen(cmd) >= TW_MIN_SGL_LENGTH;\n}"}]
[{"role": "summary", "content": "This function sets the digital audio interface format for the WM8753 audio codec. It reads the PCM register value, then sets the appropriate bit in the voice register based on the `fmt` parameter. The `fmt` parameter determines the interface format, which can be one of several standard formats like I2S, RIGHT_J, LEFT_J, DSP_A, or DSP_B. The function returns 0 on success and -EINVAL on failure."}, {"role": "code", "content": "static int wm8753_vdac_adc_set_dai_fmt(struct snd_soc_component *component,\n\t\tunsigned int fmt)\n{\n\tu16 voice = snd_soc_component_read32(component, WM8753_PCM) & 0x01ec;\n\n\t/* interface format */\n\tswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\n\tcase SND_SOC_DAIFMT_I2S:\n\t\tvoice |= 0x0002;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_RIGHT_J:\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_LEFT_J:\n\t\tvoice |= 0x0001;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_A:\n\t\tvoice |= 0x0003;\n\t\tbreak;\n\tcase SND_SOC_DAIFMT_DSP_B:\n\t\tvoice |= 0x0013;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsnd_soc_component_write(component, WM8753_PCM, voice);\n\treturn 0;\n}"}]
[{"role": "summary", "content": "The `toIPv4Address` method converts a string representation of an IPv4 address into an integer. It first checks if the input string is null or not properly formatted (containing exactly four groups of digits separated by periods). If the input is valid, it converts each group of digits into an integer and checks if each value is between 0 and 255 (inclusive). If any value is out of range, it throws an `IllegalArgumentException`. If all values are valid, it returns the integer representation of the IPv4 address."}, {"role": "code", "content": "public static int toIPv4Address(String ipAddress){\n  if (ipAddress == null)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  String[] octets=ipAddress.split(\"\\\\.\");\n  if (octets.length != 4)   throw new IllegalArgumentException(\"Specified IPv4 address must\" + \"contain 4 sets of numerical digits separated by periods\");\n  int result=0;\n  for (int i=0; i < 4; ++i) {\n    int oct=Integer.valueOf(octets[i]);\n    if (oct > 255 || oct < 0)     throw new IllegalArgumentException(\"Octet values in specified\" + \" IPv4 address must be 0 <= value <= 255\");\n    result|=oct << ((3 - i) * 8);\n  }\n  return result;\n}\n"}]
[{"role": "summary", "content": "This function writes an array of doubles to a TIFF file based on the sample count per pixel. It first checks if the number of samples exceeds the available buffer size. If so, it allocates a new buffer. It then retrieves the value for the specified tag from the TIFF file and writes it to the buffer. Finally, it writes the array to the TIFF file using the TIFFWriteAnyArray function. If the buffer is not the original one, it is freed."}, {"role": "code", "content": "TIFFWritePerSampleAnys(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir)\n{\n\tdouble buf[10], v;\n\tdouble* w = buf;\n\tint i, status;\n\tint samples = (int) tif->tif_dir.td_samplesperpixel;\n\n\tif (samples > NITEMS(buf))\n\t\tw = (double*) _TIFFmalloc(samples * sizeof (double));\n\tTIFFGetField(tif, tag, &v);\n\tfor (i = 0; i < samples; i++)\n\t\tw[i] = v;\n\tstatus = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}"}]
