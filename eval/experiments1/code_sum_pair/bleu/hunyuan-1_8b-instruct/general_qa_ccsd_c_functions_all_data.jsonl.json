{"index": 79, "input": "**User**: \nvoid fork_handler(void)\n{\n\tforce_flush_all();\n\n\tschedule_tail(current->thread.prev_sched);\n\n\t/*\n\t * XXX: if interrupt_end() calls schedule, this call to\n\t * arch_switch_to isn't needed. We could want to apply this to\n\t * improve performance. -bb\n\t */\n\tarch_switch_to(current);\n\n\tcurrent->thread.prev_sched = NULL;\n\n\tuserspace(&current->thread.regs.regs, current_thread_info()->aux_fp_regs);\n}", "extracted_prediction": "<answer>\nThis `fork_handler` function is responsible for initializing and transitioning a newly created thread into the kernel's task scheduler. Here's a breakdown:\n\n1. **`force_flush_all()`**: Likely forces a forced flushing operation (e.g., clearing kernel buffers or updating memory) before proceeding.  \n2. **`schedule_tail(current->thread.prev_sched)`**: Schedules the previous scheduler for the \"tail\" of the thread's stack (a lower part of the stack).  \n3. **`arch_switch_to(current)`**: Switches the kernel's task scheduler to the newly created thread (`current`), replacing the old scheduler.  \n4. **`current->thread.prev_sched = NULL`**: Clears the reference to the previous scheduler, ensuring no leftover references remain.  \n5. **`userspace(...)`**: Initializes the thread's user-space registers and auxiliary floating-point registers (for shared memory access) using kernel-provided information.  \n\nThe function prepares the environment for the new thread, including resetting its scheduler reference and populating user-space register data. The comment notes it may not be strictly necessary if `interrupt_end()` already schedules a new thread, but optimizations like this could improve performance.\n</answer>"}
{"index": 881, "input": "**User**: \nstatic void cert_policy_destroy(x509_cert_policy_t *this)\n{\n\tfree(this->oid.ptr);\n\tfree(this->cps_uri);\n\tfree(this->unotice_text);\n\tfree(this);\n}", "extracted_prediction": "<answer>\nThe `cert_policy_destroy` function deallocates all dynamically allocated resources associated with an `x509_cert_policy_t` object, including its OID (Object Identifier), Common Name URI, Uniception text, and the object itself. It frees these memory allocations to free up resources managed by the certificate policy.\n</answer>"}
{"index": 682, "input": "**User**: \nvoid modbus_set_bits_from_byte(uint8_t *dest, int idx, const uint8_t value)\n{\n    int i;\n\n    for (i=0; i < 8; i++) {\n        dest[idx+i] = (value & (1 << i)) ? 1 : 0;\n    }\n}", "extracted_prediction": "<answer>\nThe `modbus_set_bits_from_byte` function takes a destination byte pointer, an index, and a value. It iterates over the 8 bits of the value, setting the corresponding bit in the destination byte at position `idx+i` (where `i` ranges from 0 to 7). If the `i`-th bit of the value is set (1), the `i`-th bit of the destination byte at `dest[idx+i]` is set to 1; otherwise, it is set to 0. This effectively copies specific bits from the input value into the destination byte at the specified index.\n</answer>"}
{"index": 119, "input": "**User**: \nnextPowerOfTwo(int x)\n{\n    int val = 1;\n    while (val < x) {\n        val *= 2;\n    }\n    return val;\n}", "extracted_prediction": "<answer>\nThe `nextPowerOfTwo` function calculates the smallest power of two that is strictly greater than the input integer `x`. It initializes a variable `val` to 1 and repeatedly doubles `val` in a loop until `val` is no longer less than `x`. The final value of `val` is returned as the result.\n</answer>"}
{"index": 533, "input": "**User**: \nvoid clusterBroadcastPause(robj *qname, uint32_t flags) {\n    clusterSendPause(qname,flags,server.cluster->nodes);\n}", "extracted_prediction": "<answer>\nThe `clusterBroadcastPause` function sends a pause signal to cluster nodes. It takes a queue name (`qname`), flags, and the list of cluster nodes (`server.cluster->nodes`) as inputs, then invokes `clusterSendPause` to propagate the pause notification across the cluster.\n</answer>"}
{"index": 153, "input": "**User**: \ncredential_factory_t *credential_factory_create()\n{\n\tprivate_credential_factory_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.create = _create,\n\t\t\t.create_builder_enumerator = _create_builder_enumerator,\n\t\t\t.add_builder = _add_builder,\n\t\t\t.remove_builder = _remove_builder,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.constructors = linked_list_create(),\n\t\t.recursive = thread_value_create(NULL),\n\t\t.lock = rwlock_create(RWLOCK_TYPE_DEFAULT),\n\t);\n\n\treturn &this->public;\n}", "extracted_prediction": "<answer>\nThis function `credential_factory_create()` initializes and returns a new `credential_factory_t` object. It configures the object by setting up initialization logic (e.g., creating builder enumerators, managing builders via `add_builder`/`remove_builder`), linking constructors to a linked list, enabling recursion, and initializing a mutex (`rwlock`) for thread safety. The returned pointer points to the newly constructed object.\n</answer>"}
{"index": 736, "input": "**User**: \nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)\n{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));\n  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)\n  {\n    /* Drive the SMBusAlert pin Low */\n    I2Cx->CR1 |= I2C_SMBusAlert_Low;\n  }\n  else\n  {\n    /* Drive the SMBusAlert pin High  */\n    I2Cx->CR1 &= I2C_SMBusAlert_High;\n  }\n}", "extracted_prediction": "<answer>\nThis function configures the I2C peripheral's control register (CR1) based on the `I2C_SMBusAlert` parameter, using assertions to validate input values. It drives the SMBus alert pin low or high by setting/resetting specific bits in the I2Cx register's CR1 bit field.\n</answer>"}
{"index": 185, "input": "**User**: \nget_sortgrouplist_exprs(List *sgClauses, List *targetList)\n{\n\tList\t   *result = NIL;\n\tListCell   *l;\n\n\tforeach(l, sgClauses)\n\t{\n\t\tSortGroupClause *sortcl = (SortGroupClause *) lfirst(l);\n\t\tNode\t   *sortexpr;\n\n\t\tsortexpr = get_sortgroupclause_expr(sortcl, targetList);\n\t\tresult = lappend(result, sortexpr);\n\t}\n\treturn result;\n}", "extracted_prediction": "<answer>\nThe provided Go function `get_sortgrouplist_exprs` processes a list of `SortGroupClause` objects (`sgClauses`) to generate a list of sort-related expressions (`sortexpr`). It iterates over each `SortGroupClause`, retrieves a corresponding sort expression from the current clause and the `targetList` using `get_sortgroupclause_expr`, and appends these expressions to the result list. The final result contains all extracted sort expressions derived from the input clauses.\n</answer>"}
{"index": 432, "input": "**User**: \nenum ice_status ice_clear_pf_cfg(struct ice_hw *hw)\n{\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_clear_pf_cfg);\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n}", "extracted_prediction": "<answer>\nThis code defines an enum `ice_status` containing `ice_clear_pf_cfg`, which includes a nested struct `ice_aq_desc`. Inside this struct, `ice_fill_dflt_direct_cmd_desc` initializes it with `ice_aqc_opc_clear_pf_cfg`. Finally, it invokes `ice_aq_send_cmd` to send the command, passing the `hw` pointer (an `ice_hw` structure), the initialized `ice_aq_desc`, and returning the result.\n</answer>"}
{"index": 259, "input": "**User**: \nstatic void igc_configure_tx(struct igc_adapter *adapter)\n{\n\tint i;\n\n\tfor (i = 0; i < adapter->num_tx_queues; i++)\n\t\tigc_configure_tx_ring(adapter, adapter->tx_ring[i]);\n}", "extracted_prediction": "<answer>\nThis function iterates over each transaction queue in an `igc_adapter` and configures them using `igc_configure_tx_ring`, passing the adapter and the corresponding ring from the adapter's transaction queue list.\n</answer>"}
{"index": 231, "input": "**User**: \nvoid test_merge_trees_trivial__initialize(void)\n{\n\trepo = cl_git_sandbox_init(TEST_REPO_PATH);\n}", "extracted_prediction": "<answer>\nThis function initializes a git sandbox using `cl_git_sandbox_init` with the path specified by `TEST_REPO_PATH`, part of a test suite for verifying the behavior of merging trivial trees.\n</answer>"}
{"index": 607, "input": "**User**: \nmptsas_del_device_component_by_os(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct mptsas_device_info\t*sas_info, *next;\n\n\t/*\n\t * Set is_cached flag\n\t */\n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t\tlist) {\n\t\tif (sas_info->os.channel == channel && sas_info->os.id == id)\n\t\t\tsas_info->is_cached = 1;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `mptsas_del_device_component_by_os` deletes a MPT (Management Point Technology) device component from the system. It iterates over a list of MPT device components associated with the input structure (`ioc`), checks if a component matches the specified `channel` and `id`, and marks it as \"cached\" by setting `sas_info->is_cached = 1`. This likely optimizes deletion by avoiding unnecessary operations on already cached components.\n</answer>"}
{"index": 338, "input": "**User**: \nvoid radix__flush_all_lpid(unsigned int lpid)\n{\n\t_tlbie_lpid(lpid, RIC_FLUSH_ALL);\n}", "extracted_prediction": "<answer>\nThis function `radix__flush_all_lpid` is responsible for flushing all LPI (length pointer) information for a given length pointer `lpid`. It uses the low-order type information (`_tlbie_`) macro and a flag `RIC_FLUSH_ALL` to ensure all associated flush operations are executed for the specified length pointer.\n</answer>"}
{"index": 315, "input": "**User**: \nvoid _SlDrvHandleGeneralEvents(SlDeviceEvent_t *slGeneralEvent)\n{\n    _u8 i;\n\n    /* Iterate over all the extenal libs handlers */\n    for ( i = 0 ; i < sizeof(general_callbacks)/sizeof(general_callbacks[0]) ; i++ )\n    {\n        if (EVENT_PROPAGATION_BLOCK == general_callbacks[i](slGeneralEvent) )\n\t\t{\n        \t/* exit immediately and do not call the user specific handler as well */\n            return;\n\t\t}\n    }\n\n/* At last call the Application specific handler if registered */\n#ifdef sl_GeneralEvtHdlr\n    sl_GeneralEvtHdlr(slGeneralEvent);\n#endif\n\n}", "extracted_prediction": "<answer>\nThis function `_SlDrvHandleGeneralEvents` handles events related to the \"general\" aspect of a device. It iterates over external libs handlers, checking if any match the event using `EVENT_PROPAGATION_BLOCK`. If a match is found, it exits early without invoking the user-specific handler. Finally, it conditionally calls an Application-specific handler (`sl_GeneralEvtHdlr`) if registered for the general event.\n</answer>"}
{"index": 788, "input": "**User**: \nvoid s3c2410_iotiming_getbank(struct s3c_cpufreq_config *cfg,\n\t\t\t      struct s3c2410_iobank_timing *bt)\n{\n\tunsigned long bankcon = bt->bankcon;\n\tunsigned long hclk = cfg->freq.hclk_tns;\n\n\tbt->tcah = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcah_SHIFT);\n\tbt->tcoh = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcoh_SHIFT);\n\tbt->tcos = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcos_SHIFT);\n\tbt->tacs = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tacs_SHIFT);\n\tbt->tacc = get_tacc(hclk, bankcon >> S3C2410_BANKCON_Tacc_SHIFT);\n}", "extracted_prediction": "<answer>\nThis function configures the timing parameters (`tcah`, `tcoh`, `tcos`, `tacs`, `tacc`) for an IoT OOBank timing structure (`s3c2410_iobank_timing`). It retrieves the clock frequency (`hclk_tns`) and bank configuration (`bankcon`) from input parameters, then extracts the current clock signal state (shifted by specific constants) to update the timing parameters. This sets the timing constraints for the OOBank bank based on the system clock frequency and bank-specific timing configurations.\n</answer>"}
{"index": 320, "input": "**User**: \nunsigned int cxgb4_port_viid(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->viid;\n}", "extracted_prediction": "<answer>\nThe function `cxgb4_port_viid` returns the `viid` (unique identifier) of the port associated with the provided `net_device` struct.\n</answer>"}
{"index": 870, "input": "**User**: \nvoid SDIO_SendCEATACmd(FunctionalState NewState)\n{ \n  /* Check the parameters */\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  \n  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;\n}", "extracted_prediction": "<answer>\nThe function `SDIO_SendCEATACmd` validates the input state parameter (`FunctionalState NewState`) using `assert_param(IS_FUNCTIONAL_STATE(NewState))`, then stores the validated state value into the memory location `CMD_ATACMD_BB` (an `uint32_t` pointer).\n</answer>"}
{"index": 228, "input": "**User**: \nstatic void vmw_swap_notify(struct ttm_buffer_object *bo)\n{\n\tvmw_bo_swap_notify(bo);\n\t(void) ttm_bo_wait(bo, false, false);\n}", "extracted_prediction": "<answer>\nThis static function `vmw_swap_notify` is responsible for initiating swap notifications on a `ttm_buffer_object`. It first calls an internal swap notification handler (`vmw_bo_swap_notify`) and then waits for the buffer to become available using `ttm_bo_wait`, ensuring proper swap operations occur only after the buffer is ready.\n</answer>"}
{"index": 65, "input": "**User**: \nget_range_subtype(Oid rangeOid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(rangeOid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = rngtup->rngsubtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}", "extracted_prediction": "<answer>\nThe `get_range_subtype` function retrieves the subtype of a given range object by its OID. It uses `SearchSysCache1` to fetch metadata about the range, checks if the retrieval is valid, and returns the range's subtype (as an `Oid`) or `InvalidOid` if the range is not found.\n</answer>"}
{"index": 52, "input": "**User**: \nstatic enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)\n{\n\tif (!ap_suspend_flag)\n\t\ttasklet_schedule(&ap_tasklet);\n\treturn HRTIMER_NORESTART;\n}", "extracted_prediction": "<answer>\nThis function `hrtimer_restart` checks if `ap_suspend_flag` is unset. If true, it schedules a tasklet to restart the timer and returns `HRTIMER_NORESTART` to prevent automatic timer restart. The `unused` parameter is a placeholder (likely unused) as the timer is not actively managed here.\n</answer>"}
{"index": 98, "input": "**User**: \nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\n{\n\tif (!vha->vha_tgt.qla_tgt)\n\t\treturn 0;\n\n\tif (vha->fc_vport) {\n\t\tqlt_release(vha->vha_tgt.qla_tgt);\n\t\treturn 0;\n\t}\n\n\t/* free left over qfull cmds */\n\tqlt_init_term_exchange(vha);\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe03c, \"Unregistering target for host %ld(%p)\",\n\t    vha->host_no, ha);\n\tqlt_release(vha->vha_tgt.qla_tgt);\n\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThe `qlt_remove_target` function unregisters a target associated with an SCIQLA_Host structure. It first checks if the target is null; if so, returns 0. If the host has a FC_VPORT, it releases any leftover commands and exits. Otherwise, it initializes a term exchange mechanism and uses `ql932g` to unregister the target with parameters including the host identifier and target address. Finally, it releases the target resource and returns 0.\n</answer>"}
{"index": 729, "input": "**User**: \nxo_style_is_encoding (xo_handle_t *xop)\n{\n    if (xo_style(xop) == XO_STYLE_JSON\n\t|| xo_style(xop) == XO_STYLE_XML\n\t|| xo_style(xop) == XO_STYLE_SDPARAMS\n\t|| xo_style(xop) == XO_STYLE_ENCODER)\n\treturn 1;\n    return 0;\n}", "extracted_prediction": "<answer>\nThe function `xo_style_is_encoding` checks whether the encoding style of an XOP structure (`xo_handle_t *xop`) is one of the specified styles: JSON, XML, SDPARAMS, or ENCODER. It returns `1` if the style matches any of these, and `0` otherwise.\n</answer>"}
{"index": 380, "input": "**User**: \nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}", "extracted_prediction": "<answer>\nThe `ext4_journalled_invalidatepage` function is a kernel function that calls `__ext4_journalled_invalidatepage` to invalidate data within an ext4 filesystem page. It takes a `struct page*` (pointer to the filesystem page), an `offset` (starting position on the page), and a `length` (number of bytes to invalidate). If the return value of `__ext4_journalled_invalidatepage` is negative, it triggers a warning via `WARN_ON`.\n</answer>"}
{"index": 779, "input": "**User**: \nclear_bridge_list(void)\n{\n  if (!bridge_list)\n    bridge_list = smartlist_create();\n  SMARTLIST_FOREACH(bridge_list, bridge_info_t *, b, tor_free(b));\n  smartlist_clear(bridge_list);\n}", "extracted_prediction": "<answer>\nThis function `clear_bridge_list` initializes or clears a bridge list structure. If `bridge_list` is empty (NULL), it creates a new smartlist. It then iterates over all elements in the list, freeing each element, and finally removes the list from memory.\n</answer>"}
{"index": 582, "input": "**User**: \nvoid llhdeg2rad(const double llh_deg[3], double llh_rad[3]) {\n  llh_rad[0] = llh_deg[0] * D2R;\n  llh_rad[1] = llh_deg[1] * D2R;\n  llh_rad[2] = llh_deg[2];\n}", "extracted_prediction": "<answer>\nThis function `llhdeg2rad` converts an array of three floating-point values from degrees to radians. It takes two arrays of size 3: `llh_deg` (degrees) and `llh_rad` (resulting radians). Each element in `llh_deg` is multiplied by a constant `D2R` (likely the conversion factor between degrees and radians, e.g., Ï€/180) to produce the corresponding element in `llh_rad`. The function performs element-wise conversion without additional logic.\n</answer>"}
{"index": 162, "input": "**User**: \nvoid  OS_EventWaitListInit (OS_EVENT *pevent)\n{\n    INT8U  i;\n\n\n    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */\n    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {\n        pevent->OSEventTbl[i] = 0u;\n    }\n}", "extracted_prediction": "<answer>\nThis function initializes the event wait list structure (`OS_EVENT` pointer). It sets the event group index to `0u` (indicating no task waiting on events) and clears all entries in the event table (`OSEventTbl`) within the specified size (`OS_EVENT_TBL_SIZE`).\n</answer>"}
{"index": 754, "input": "**User**: \nrender_tile_lookup( Render *render, VipsRect *area )\n{\n\treturn( (Tile *) g_hash_table_lookup( render->tiles, area ) );\n}", "extracted_prediction": "<answer>\nThis function retrieves a `Tile` from a hash table stored in `render->tiles`, using the `VipsRect` as the key for lookup. It calls `g_hash_table_lookup` to search for the tile matching the specified area.\n</answer>"}
{"index": 601, "input": "**User**: \nSPI_scroll_cursor_move(Portal portal, FetchDirection direction, long count)\n{\n\t_SPI_cursor_operation(portal, direction, count, None_Receiver);\n}", "extracted_prediction": "<answer>\nThis function invokes SPI_cursor_operation to move the cursor in a specified direction (left, right, up, or down) over a portal by a given count of steps.\n</answer>"}
{"index": 955, "input": "**User**: \nstatic int rtctime_dsleep (lua_State *L)\n{\n  uint32_t us = luaL_checknumber (L, 1);\n  do_sleep_opt (L, 2);\n  rtctime_deep_sleep_us (us); // does not return\n  return 0;\n}", "extracted_prediction": "<answer>\nThis Lua function `rtctime_dsleep` pauses execution for a specified duration (2 milliseconds) and then performs a deep sleep using `rtctime_deep_sleep_us`. It retrieves a number of microseconds (`us`) from the input state, passes it to the sleep function, and returns no value. The core purpose is to delay the current operation by a configurable microsecond interval after a short sleep.\n</answer>"}
{"index": 490, "input": "**User**: \nvoid* CMSEXPORT cmsGetContextUserData(cmsContext ContextID)\n{\n    return _cmsContextGetClientChunk(ContextID, UserPtr);\n}", "extracted_prediction": "<answer>\nThe `CMSEXPORT cmsGetContextUserData(cmsContext ContextID)` function retrieves a user data chunk from the context associated with the given `ContextID`. It calls `_cmsContextGetClientChunk` with the `ContextID` and `UserPtr` parameters, returning the result as a `void*` pointer. This function likely fetches user-specific context data stored in client chunks.\n</answer>"}
{"index": 122, "input": "**User**: \nskipbl(void)\n{\n\tint c;\n\n\tif( termch != 0 ){\n\t\tc = termch;\n\t\ttermch = 0;\n\t} else\n\t\tc = inchar();\n\twhile( c == ' ' || c == '\\t' )\n\t\tc = inchar();\n\treturn c;\n}", "extracted_prediction": "<answer>\nThis function skips leading whitespace (spaces and tabs) from input and returns the first non-whitespace character encountered. It reads characters from standard input until a non-whitespace character is found, then returns that character. If no non-whitespace character is found, it returns `'\\0'` (end-of-string).\n</answer>"}
{"index": 211, "input": "**User**: \nget_guctype(const char *varname)\n{\n\tPQExpBufferData query_buffer;\n\tchar\t   *e_varname;\n\tPGresult   *result;\n\tchar\t   *guctype = NULL;\n\n\te_varname = escape_string(varname);\n\n\tinitPQExpBuffer(&query_buffer);\n\tappendPQExpBuffer(&query_buffer,\n\t\t\t\t\t  \"SELECT vartype FROM pg_catalog.pg_settings \"\n\t\t\t\t\t  \"WHERE pg_catalog.lower(name) = pg_catalog.lower('%s')\",\n\t\t\t\t\t  e_varname);\n\n\tresult = exec_query(query_buffer.data);\n\ttermPQExpBuffer(&query_buffer);\n\tfree(e_varname);\n\n\tif (PQresultStatus(result) == PGRES_TUPLES_OK && PQntuples(result) > 0)\n\t\tguctype = pg_strdup(PQgetvalue(result, 0, 0));\n\n\tPQclear(result);\n\n\treturn guctype;\n}", "extracted_prediction": "<answer>\nThis Go function `get_guctype` retrieves the `vartype` (variable type) from PostgreSQL's `pg_settings` table. It takes an input `varname`, escapes special characters, constructs a SQL query to fetch the type, executes it, and returns the type value. Key steps include escaping the input, querying `pg_settings` with a case-insensitive name filter matching the escaped input, and returning the first matching `vartype`.\n</answer>"}
{"index": 751, "input": "**User**: \nstatic int unicodeClose(sqlite3_tokenizer_cursor *pCursor){\n  unicode_cursor *pCsr = (unicode_cursor *) pCursor;\n  sqlite3_free(pCsr->zToken);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}", "extracted_prediction": "<answer>\nThis function `unicodeClose` safely closes a SQLite tokenizer cursor by converting it to an `unicode_cursor`, freeing its token (`zToken`) and the cursor itself, then returning `SQLITE_OK` to indicate success.\n</answer>"}
{"index": 761, "input": "**User**: \nvoid print_key(uint8_t *client_id)\n{\n    uint32_t j;\n\n    for (j = 0; j < 32; j++) {\n        printf(\"%02hhX\", client_id[j]);\n    }\n}", "extracted_prediction": "<answer>\nThis C function `print_key` takes a pointer to a 32-byte array (`uint8_t *client_id`) and prints each byte as a two-digit hexadecimal string (e.g., \"00\", \"01\",..., \"FF\") sequentially. It iterates 32 times, formatting each byte using `printf(\"%02hhX\", client_id[j])`, where `%02hhX` ensures each byte is displayed with leading zeros and uppercase hex digits.\n</answer>"}
{"index": 194, "input": "**User**: \nstatic void fixup_unlock_powerup_lock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tif (cfip->FeatureSupport&32) {\n\t\tprintk(KERN_INFO \"Using auto-unlock on power-up/resume\\n\" );\n\t\tmtd->flags |= MTD_POWERUP_LOCK;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `fixup_unlock_powerup_lock` checks if the device supports the `MF_UF` (Automatic Unlock) feature (bit 32 in `cfi_pri_intelext`) when initializing the power-up/resume lock mechanism. If enabled, it prints a kernel message and enables `MTD_POWERUP_LOCK` in the device's flags to automatically unlock the power-up or resume state.\n</answer>"}
{"index": 449, "input": "**User**: \nstatic grp_stack_item* grp_stack_append(\n  grp_stack_item* last, grp_stack_data data\n) {\n  /* first create a new stack item, and copy data to it */\n  grp_stack_item* new_item = (grp_stack_item*) malloc(sizeof(grp_stack_item));\n  new_item->data = data;\n  if(last) {\n    /* attach this item between the \"last\" item and its \"next\" item */\n    new_item->next = last->next;\n    new_item->prev = last;\n    last->next->prev = new_item;\n    last->next = new_item;\n  } else {\n    /* stack is empty, so \"next\" and \"previous\" both point back to it */\n    new_item->next = new_item;\n    new_item->prev = new_item;\n  }\n  return new_item;\n}", "extracted_prediction": "<answer>\nThis function `grp_stack_append` dynamically creates and appends a new stack item to an existing stack. It allocates memory for the new item, copies the provided data, and links it to the last item in the stack. If the stack is not empty, the new item is attached between the last item and its next item, updating pointers to maintain adjacency. If the stack is empty, the new item becomes the root of the stack.\n</answer>"}
{"index": 26, "input": "**User**: \nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}", "extracted_prediction": "<answer>\nThis function retrieves a hard disk UUID from the VMware virtual box configuration by location. It iterates through all disks in the machine's media registry, checks each disk against the specified location using `virVBoxSnapshotConfHardDiskByLocation`, and returns the UUID of the first matching hard disk. If no match is found, it returns `NULL`.\n</answer>"}
{"index": 319, "input": "**User**: \nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) |\n\t\t\t   DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) &\n\t\t\t   ~(DUPS1_GATING_DIS | DUPS2_GATING_DIS));\n}", "extracted_prediction": "<answer>\nThis function `skl_wa_827` toggles the gating bits on/off for an MIPS processor's I915 clock controller. It uses `CLKGATE_DIS_PSL` to read/write the clock gating state to the specified `pipe`, with `DUPS1_GATING_DIS` and `DUPS2_GATING_DIS` as the toggle bits. If `enable` is true, it writes the current gating state OR-ing the toggle bits; if false, it writes the inverse AND-ing them. This adjusts the clock generation gating configuration dynamically.\n</answer>"}
{"index": 920, "input": "**User**: \nMarkCurrentTransactionIdLoggedIfAny(void)\n{\n\tif (FullTransactionIdIsValid(CurrentTransactionState->fullTransactionId))\n\t\tCurrentTransactionState->didLogXid = true;\n}", "extracted_prediction": "<answer>\nThis function checks if the current transaction's `fullTransactionId` is valid. If valid, it sets the `didLogXid` flag in the `CurrentTransactionState` to `true`, indicating that at least one transaction ID has been logged.\n</answer>"}
{"index": 829, "input": "**User**: \nretransmit_job_t *retransmit_job_create(uint32_t message_id,ike_sa_id_t *ike_sa_id)\n{\n\tprivate_retransmit_job_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.job_interface = {\n\t\t\t\t.execute = _execute,\n\t\t\t\t.get_priority = _get_priority,\n\t\t\t\t.destroy = _destroy,\n\t\t\t},\n\t\t},\n\t\t.message_id = message_id,\n\t\t.ike_sa_id = ike_sa_id->clone(ike_sa_id),\n\t);\n\n\treturn &this->public;\n}", "extracted_prediction": "<answer>\nThe `retransmit_job_create` function initializes and returns a public object of type `retransmit_job_t`. It takes a `message_id` (uint32_t) and an `ike_sa_id` (pointer), clones the `ike_sa_id`, and sets up a job interface with execution, priority management, and destruction capabilities. The returned object points to the initialized public instance.\n</answer>"}
{"index": 522, "input": "**User**: \nvoid sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  pParse->nErr++;\n  sqliteFree(pParse->zErrMsg);\n  va_start(ap, zFormat);\n  pParse->zErrMsg = sqlite3VMPrintf(zFormat, ap);\n  va_end(ap);\n}", "extracted_prediction": "<answer>\nThis function `sqlite3ErrorMsg` handles SQLite error message generation. It increments an error counter (`pParse->nErr`), frees the previously allocated error message string (`sqliteFree(pParse->zErrMsg)`), then prints a formatted error message using SQLite's `sqlite3VMPrintf` with the provided format string (`zFormat`) via the variable argument list (`va_start`, `va_end`). Finally, it frees the variable arguments after printing. The goal is to provide structured, user-friendly error messages based on the input format string while properly managing memory.\n</answer>"}
{"index": 252, "input": "**User**: \nxpc_check_remote_hb(void)\n{\n\tstruct xpc_partition *part;\n\tshort partid;\n\tenum xp_retval ret;\n\n\tfor (partid = 0; partid < xp_max_npartitions; partid++) {\n\n\t\tif (xpc_exiting)\n\t\t\tbreak;\n\n\t\tif (partid == xp_partition_id)\n\t\t\tcontinue;\n\n\t\tpart = &xpc_partitions[partid];\n\n\t\tif (part->act_state == XPC_P_AS_INACTIVE ||\n\t\t    part->act_state == XPC_P_AS_DEACTIVATING) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = xpc_arch_ops.get_remote_heartbeat(part);\n\t\tif (ret != xpSuccess)\n\t\t\tXPC_DEACTIVATE_PARTITION(part, ret);\n\t}\n}", "extracted_prediction": "<answer>\nThis function `xpc_check_remote_hb` iterates through all XPC partitions, skipping the current partition (`xp_partition_id`) and inactive/deactivating ones. For each active partition, it attempts to execute a remote heartbeat operation via `xpc_arch_ops.get_remote_heartbeat()`. If the operation fails (`ret!= xpSuccess`), it deactivates the partition using `XPC_DEACTIVATE_PARTITION()`. The loop terminates when `xpc_exiting` is detected.\n</answer>"}
{"index": 932, "input": "**User**: \nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThis function creates a persistent keyring under the user namespace (`struct user_namespace`). It allocates a keyring with the name `.persistent_register`, initializes it with the current user credentials, grants read/write access via `KEY_USR_VIEW`, and links it to the user namespace. If allocation succeeds, it stores the keyring in `ns->persistent_keyring_register` and returns success (0); otherwise, returns the allocation error.\n</answer>"}
{"index": 942, "input": "**User**: \nTIFFWritePerSampleAnys(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir)\n{\n\tdouble buf[10], v;\n\tdouble* w = buf;\n\tint i, status;\n\tint samples = (int) tif->tif_dir.td_samplesperpixel;\n\n\tif (samples > NITEMS(buf))\n\t\tw = (double*) _TIFFmalloc(samples * sizeof (double));\n\tTIFFGetField(tif, tag, &v);\n\tfor (i = 0; i < samples; i++)\n\t\tw[i] = v;\n\tstatus = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}", "extracted_prediction": "<answer>\nThis function `TIFFWritePerSampleAnys` writes data to a TIFF file per sample. It takes a `TIFF*` pointer, a `TIFFDataType` type, a `tag`, and a `TIFFDirEntry` directory entry. It dynamically allocates a buffer sized for the number of samples (from the TIFF directory), copies the data from the specified `tag` into this buffer, and writes the data using `TIFFWriteAnyArray`. Memory is freed after the operation.\n</answer>"}
{"index": 205, "input": "**User**: \nenumerator_t *enumerator_create_nested(enumerator_t *outer,\n\t\t\t\t\tenumerator_t *(inner_constructor)(void *outer, void *data),\n\t\t\t\t\tvoid *data, void (*destructor)(void *data))\n{\n\tnested_enumerator_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.enumerate = enumerator_enumerate_default,\n\t\t\t.venumerate = _enumerate_nested,\n\t\t\t.destroy = _destroy_nested,\n\t\t},\n\t\t.outer = outer,\n\t\t.create_inner = inner_constructor,\n\t\t.data = data,\n\t\t.destructor = destructor,\n\t);\n\treturn &this->public;\n}", "extracted_prediction": "<answer>\nThis function creates a new enumerator by initializing it with specified enumerator functions, outer enumerator, inner constructor, data pointer, and destructor. It returns a pointer to the initialized enumerator object.\n</answer>"}
{"index": 508, "input": "**User**: \nstatic void list_splice_entire_tail(struct list_head *from,\n\t\t\t\t    struct list_head *to)\n{\n\tstruct list_head *from_last = from->prev;\n\n\tlist_splice_tail(from_last, to);\n\tlist_add_tail(from_last, to);\n}", "extracted_prediction": "<answer>\nThis function splices the entire tail of the list head `from` into the list head `to`. It first identifies the node immediately preceding `from` (stored as `from_last`), removes this node from the list using `list_splice_tail`, and then appends it to the end of `to` using `list_add_tail`, effectively transferring the tail of `from` to the end of `to`.\n</answer>"}
{"index": 181, "input": "**User**: \nint dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs)\n{\n\telf_core_copy_regs(elfregs, task_pt_regs(t));\n\treturn 1;\n}", "extracted_prediction": "<answer>\nThis function `dump_task_regs` copies the task's register information from a `task_struct` into an `elf_gregset_t` structure via `elf_core_copy_regs`, then returns 1 to signal successful execution.\n</answer>"}
{"index": 925, "input": "**User**: \nvoid ge_p2_dbl(ge_p1p1 *r,const ge_p2 *p)\n{\n  fe t0;\n#include \"ge_p2_dbl.h\"\n}", "extracted_prediction": "<answer>\nThis function `ge_p2_dbl` is likely responsible for converting 2D points between coordinate systems. It takes pointers to two coordinate structures (`ge_p1p1` and `ge_p2`) and includes a temporary struct `t0` for internal processing. The function's name suggests it handles double-precision point conversions, possibly involving transformation logic or coordinate system conversion algorithms.\n</answer>"}
{"index": 247, "input": "**User**: \nstatic inline void refill_rspq(struct adapter *adapter,\n\t\t\t       const struct sge_rspq *q, unsigned int credits)\n{\n\trmb();\n\tt3_write_reg(adapter, A_SG_RSPQ_CREDIT_RETURN,\n\t\t     V_RSPQ(q->cntxt_id) | V_CREDITS(credits));\n}", "extracted_prediction": "<answer>\nThis function `refill_rspq` updates the `A_SG_RSPQ_CREDIT_RETURN` register in the system's RMB (Return Message Buffer) by combining the current value from the `sge_rspq` structure's `cntxt_id` field with the provided `credits` value. It first resets the RMB buffer (`rmb()`) to ensure a clean state before writing the combined bitmask into the target register.\n</answer>"}
{"index": 511, "input": "**User**: \nmp_obj_t mp_obj_new_str_copy(const mp_obj_type_t *type, const byte* data, size_t len) {\n    mp_obj_str_t *o = m_new_obj(mp_obj_str_t);\n    o->base.type = type;\n    o->len = len;\n    if (data) {\n        o->hash = qstr_compute_hash(data, len);\n        byte *p = m_new(byte, len + 1);\n        o->data = p;\n        memcpy(p, data, len * sizeof(byte));\n        p[len] = '\\0'; // for now we add null for compatibility with C ASCIIZ strings\n    }\n    return MP_OBJ_FROM_PTR(o);\n}", "extracted_prediction": "<answer>\nThe `mp_obj_new_str_copy` function creates a new string object (`mp_obj_str_t`) from a copy of a given string. It initializes the object with the specified type and length, processes input data (if provided) by hashing it and allocating memory for the byte array, copying the data into the allocated buffer, and adding a null terminator. Finally, it returns the object as a pointer compatible with `MP_OBJ_FROM_PTR`.\n</answer>"}
{"index": 110, "input": "**User**: \nvoid SaveRegisteredItems( void ) {\n\tchar\tstring[MAX_ITEMS+1];\n\tint\t\ti;\n\tint\t\tcount;\n\n\tcount = 0;\n\tfor ( i = 0 ; i < bg_numItems ; i++ ) {\n\t\tif ( itemRegistered[i] ) {\n\t\t\tcount++;\n\t\t\tstring[i] = '1';\n\t\t} else {\n\t\t\tstring[i] = '0';\n\t\t}\n\t}\n\tstring[ bg_numItems ] = 0;\n\n\tG_Printf( \"%i items registered\\n\", count );\n\ttrap_SetConfigstring(CS_ITEMS, string);\n}", "extracted_prediction": "<answer>\nThis C function `SaveRegisteredItems` counts the number of registered items in an array `itemRegistered` and prints the count. It uses a string buffer (`string`) to store the binary representation of the count, clears it afterward, and ensures the string is cleared via a trap before printing. The loop iterates through `itemRegistered`, toggling values in `string` to represent the count, then prints the total count.\n</answer>"}
{"index": 254, "input": "**User**: \nvoid OS_COM_Send1(OS_U8 c) {\n  OS_USEPARA(c);           // Avoid compiler warning\n  OS_COM_ClearTxActive();  // Let embOS know that Tx is not busy\n}", "extracted_prediction": "<answer>\nThe `OS_COM_Send1` function prepares for a transmission by enabling parallel processing (`OS_USEPARA(c)`) to avoid compiler warnings and explicitly marking the transmission channel as inactive (`OS_COM_ClearTxActive()`).\n</answer>"}
{"index": 656, "input": "**User**: \nvoid hash_free(hash_t *hash)\n{\n#ifdef KAZLIB_OBSOLESCENT_DEBUG\n    assert (\"call to obsolescent function hash_free()\" && 0);\n#endif\n    hash_free_nodes(hash);\n    hash_destroy(hash);\n}", "extracted_prediction": "<answer>\nThe `hash_free` function is responsible for freeing the internal nodes of a hash table and then destroying the hash object itself. In debug mode, it asserts that calling `hash_free` is a bug due to its obsolescence. The function first calls `hash_free_nodes` to clean up unused entries in the hash table, then invokes `hash_destroy` to deallocate the hash structure.\n</answer>"}
{"index": 152, "input": "**User**: \nvoid rio_local_set_device_id(struct rio_mport *port, u16 did)\n{\n\trio_local_write_config_32(port, RIO_DID_CSR,\n\t\t\t\t  RIO_SET_DID(port->sys_size, did));\n}", "extracted_prediction": "<answer>\nThis function sets the device ID for a network port. It writes a 16-bit value (`did`) to the device ID register of the port, using the port's system size to determine the register location. The result is stored in the local configuration area of the port's hardware.\n</answer>"}
{"index": 294, "input": "**User**: \nstatic void mchip_cont_compression_start(void)\n{\n\tmchip_hic_stop();\n\tmchip_vrj_setup(0x3f);\n\tmchip_subsample();\n\tmchip_set_framerate();\n\tmchip_dma_setup(meye.mchip_dmahandle);\n\n\tmeye.mchip_mode = MCHIP_HIC_MODE_CONT_COMP;\n\n\tmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_CONT_COMP);\n\tmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\n\n\tmchip_delay(MCHIP_HIC_CMD, 0);\n}", "extracted_prediction": "<answer>\nThis function `mchip_cont_compression_start` initializes and starts the high-speed clock (cont compression) in a chip. It performs the following steps:  \n1. Stops the high-speed clock using `mchip_hic_stop()`.  \n2. Configures VRJ (Virtuous Real-Time Jitter) settings with `mchip_vrj_setup(0x3f)`.  \n3. Subsamples the data with `mchip_subsample()`.  \n4. Sets the frame rate with `mchip_set_framerate()`.  \n5. Configures DMA for handle `meye` with `mchip_dma_setup(meye.mchip_dmahandle)`.  \n6. Enables the high-speed clock mode (`MCHIP_HIC_MODE_CONT_COMP`) and confirms it via `mchip_set()`.  \n7. Starts the high-speed clock command (`MCHIP_HIC_CMD_START`) and delays briefly with `mchip_delay()`.\n</answer>"}
{"index": 947, "input": "**User**: \nSDL_SYS_JoystickUpdate(SDL_Joystick * joystick)\n{\n    return;\n}", "extracted_prediction": "<answer>\nThe `SDL_SYS_JoystickUpdate` function is a placeholder implementation that takes a pointer to a SDL_Joystick object as input but returns no value. It likely serves as a stub or placeholder for future updates to the SDL Joystick subsystem handling.\n</answer>"}
{"index": 538, "input": "**User**: \nstatic struct net_device *br2684_find_dev(const struct br2684_if_spec *s)\n{\n\tstruct list_head *lh;\n\tstruct net_device *net_dev;\n\tswitch (s->method) {\n\tcase BR2684_FIND_BYNUM:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (BRPRIV(net_dev)->number == s->spec.devnum)\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\tcase BR2684_FIND_BYIFNAME:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (!strncmp(net_dev->name, s->spec.ifname, IFNAMSIZ))\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\t}\n\treturn NULL;\n}", "extracted_prediction": "<answer>\nThis function `br2684_find_dev` searches for a network device in a list (`br2684_devs`) based on either the device's number or name specified in the input `struct br2684_if_spec`. It returns the matching `struct net_device` or `NULL` if no match is found.  \n\n- **`BR2684_FIND_BYNUM`**: Iterates through the list, checks if the device's number matches `s->spec.devnum`, and returns the device if found.  \n- **`BR2684_FIND_BYIFNAME`**: Iterates through the list, checks if the device's name matches `s->spec.ifname` (case-sensitive), and returns the device if found.  \n\nBoth cases return the first matching device encountered in the list.\n</answer>"}
{"index": 268, "input": "**User**: \nstatic void gtkui_update(int target)\n{\n    switch (target) {\n        case UI_UPDATE_HOSTLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_host_list, NULL);\n            break;\n        case UI_UPDATE_PLUGINLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_plugin_list, NULL);\n            break;\n    }\n\n}", "extracted_prediction": "<answer>\nThis function `gtkui_update` is triggered by a `target` integer parameter. When either `UI_UPDATE_HOSTLIST` or `UI_UPDATE_PLUGINLIST` cases are matched, it schedules the execution of `gtkui_refresh_host_list` (for host list updates) or `gtkui_refresh_plugin_list` (for plugin list updates) using `g_idle_add`, with no associated user data passed to the scheduled function.\n</answer>"}
{"index": 471, "input": "**User**: \nvoid kim_st_list_protocols(struct st_data_s *st_gdata, void *buf)\n{\n\tseq_printf(buf, \"[%d]\\nBT=%c\\nFM=%c\\nGPS=%c\\n\",\n\t\t\tst_gdata->protos_registered,\n\t\t\tst_gdata->is_registered[0x04] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x08] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x09] == true ? 'R' : 'U');\n}", "extracted_prediction": "<answer>\nThe `kim_st_list_protocols` function populates a buffer with a formatted string describing registered protocols. It outputs a header `[N]` (where `N` is the count of registered protocols) followed by lines like `BT=C`, `FM=C`, `GPS=C`, where `C` is either `'R'` (registered) or `'U'` (unregistered). The status of each protocol (`BT`, `FM`, `GPS`) is determined by checking the corresponding bit in the `is_registered` array (e.g., `is_registered[0x04]` checks the 4th bit for `BT`).\n</answer>"}
{"index": 218, "input": "**User**: \nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->autoneg_stat)\n\t\tmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\n\telse\n\t\t*auto_neg = 0;\n}", "extracted_prediction": "<answer>\nThis function `hns_mac_get_autoneg` initializes an auto-negative MAC driver control mechanism. It retrieves a driver handle (`mac_ctrl_drv`) from the provided callback (`mac_cb`). If the driver has an active auto-negative status (`mac_ctrl_drv->autoneg_stat`), it triggers the status update via `mac_ctrl_drv->autoneg_stat`. Otherwise, it sets the `auto_neg` parameter to zero.\n</answer>"}
{"index": 376, "input": "**User**: \nstatic int findEnd(const char *z, int *pnLine){\n  int n = 0;\n  while( z[n] && (strncmp(z+n,\"--end\",5) || !ISSPACE(z[n+5])) ){\n    n += tokenLength(z+n, pnLine);\n  }\n  return n;\n}", "extracted_prediction": "<answer>\nThe `findEnd` function scans through a string (`z`) to count the number of tokens encountered until it finds the substring \"--end\". It uses `ISSPACE` to check for trailing spaces and increments the token counter (`pnLine`) based on the length of the token following each character. The loop exits when either \"--end\" is found or a space follows it. The return value is the total number of tokens scanned during this process.\n</answer>"}
{"index": 419, "input": "**User**: \nstatic void dwc2_kill_all_urbs(struct dwc2_hsotg *hsotg)\n{\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_waiting);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_active);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_ready);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_assigned);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_queued);\n}", "extracted_prediction": "<answer>\nThis static function `dwc2_kill_all_urbs` is responsible for killing all Universal Resource Bus (URB) resources associated with the `dwc2_hsotg` structure. It explicitly iterates over several lists within the `hsotg` struct (`non_periodic_sched_inactive`, `non_periodic_sched_waiting`, etc.) and calls `dwc2_kill_urbs_in_qh_list` to deactivate or terminate each entry in these lists. These urbs are likely part of the system's scheduling or task management logic, with the lists covering inactive, waiting, active, periodic, and queued resources.\n</answer>"}
{"index": 368, "input": "**User**: \nint isapnp_present(void)\n{\n\tstruct pnp_card *card;\n\n\tpnp_for_each_card(card) {\n\t\tif (card->protocol == &isapnp_protocol)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThe `isapnp_present` function checks if any card in the list has the APNP protocol. It iterates through all cards, returning `1` (true) if a card with the protocol defined in `isapnp_protocol` is found; otherwise, it returns `0` (false).\n</answer>"}
{"index": 556, "input": "**User**: \nstatic void win32_load_config(char *conf)\n{\n\tcf_config_file = conf;\n\tinit_objects();\n\tload_config();\n}", "extracted_prediction": "<answer>\nThis static function initializes and loads a Windows configuration file using the provided path. It stores the file path in a static variable (`cf_config_file`), initializes relevant objects, and then reads the configuration from the specified file.\n</answer>"}
{"index": 58, "input": "**User**: \nstatic int is_number(const char* s) {\n  size_t i;\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\n  return 1;\n}", "extracted_prediction": "<answer>\nThe `is_number` function checks if a string `s` contains only numeric characters (digits '0'-'9'). It returns `1` (true) if all characters in `s` are digits, and `0` (false) otherwise. The check uses `strchr` to verify each character against the numeric digit set.\n</answer>"}
{"index": 217, "input": "**User**: \nstatic int wm8996_get_retune_mobile_block(const char *name)\n{\n\tif (strcmp(name, \"DSP1 EQ Mode\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"DSP2 EQ Mode\") == 0)\n\t\treturn 1;\n\treturn -EINVAL;\n}", "extracted_prediction": "<answer>\nThis function `wm8996_get_retune_mobile_block` checks if the input `name` matches either \"DSP1 EQ Mode\" or \"DSP2 EQ Mode\". Returns `0` for \"DSP1 EQ Mode\", `1` for \"DSP2 EQ Mode\", and `-EINVAL` if the input name is invalid.\n</answer>"}
{"index": 658, "input": "**User**: \nint StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}", "extracted_prediction": "<answer>\nThe `StreamTcpInlineMode` function returns 1 if the `STREAMTCP_INIT_FLAG_INLINE` flag is set in the `stream_config` structure, and 0 otherwise. This indicates whether the TCP stream configuration is set to inline mode.\n</answer>"}
{"index": 574, "input": "**User**: \npublic_key_t *botan_ed_public_key_adopt(botan_pubkey_t key)\n{\n\tprivate_public_key_t *this;\n\n\tthis = create_empty();\n\tthis->key = key;\n\n\treturn &this->public;\n}", "extracted_prediction": "<answer>\nThis function creates a new `public_t` object, initializes its `key` field with the provided `botan_pubkey_t` key, and returns a pointer to this newly created object.\n</answer>"}
{"index": 696, "input": "**User**: \nstatic void sama5d2_piobu_set(struct gpio_chip *chip, unsigned int pin,\n\t\t\t      int value)\n{\n\tif (!value)\n\t\tvalue = PIOBU_LOW;\n\telse\n\t\tvalue = PIOBU_HIGH;\n\n\tsama5d2_piobu_write_value(chip, pin, PIOBU_SOD, value);\n}", "extracted_prediction": "<answer>\nThis function `sama5d2_piobu_set` configures the output direction of a GPIO pin to either low (default when no value is provided) or high (when a non-zero value is specified). It does this by writing the target value to the GPIO chip's output direction register (PIOBU_SOD) using the provided pin number. If no value is passed, it defaults to `PIOBU_LOW`; otherwise, it uses `PIOBU_HIGH`.\n</answer>"}
{"index": 306, "input": "**User**: \nstatic bool create_aead(private_tls_crypto_t *this, suite_algs_t *algs)\n{\n\tthis->aead_in = tls_aead_create_aead(algs->encr, algs->encr_size);\n\tthis->aead_out = tls_aead_create_aead(algs->encr, algs->encr_size);\n\tif (!this->aead_in || !this->aead_out)\n\t{\n\t\tDBG1(DBG_TLS, \"selected TLS transforms %N-%u not supported\",\n\t\t\t encryption_algorithm_names, algs->encr, algs->encr_size * 8);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "extracted_prediction": "<answer>\nThis function creates two AAD (Authentication Data Authenticated Encryption) streams (`aead_in` and `aead_out`) using the TLS AAD authentication encryption algorithm. It validates that both streams are successfully initialized (non-null) and logs an error if either is invalid. Returns `true` on success, `false` otherwise.\n</answer>"}
{"index": 841, "input": "**User**: \nstatic struct qxl_rect *drawable_set_clipping(struct qxl_device *qdev,\n\t\t\t\t\t      unsigned int num_clips,\n\t\t\t\t\t      struct qxl_bo *clips_bo)\n{\n\tstruct qxl_clip_rects *dev_clips;\n\tint ret;\n\n\tret = qxl_bo_kmap(clips_bo, (void **)&dev_clips);\n\tif (ret) {\n\t\treturn NULL;\n\t}\n\tdev_clips->num_rects = num_clips;\n\tdev_clips->chunk.next_chunk = 0;\n\tdev_clips->chunk.prev_chunk = 0;\n\tdev_clips->chunk.data_size = sizeof(struct qxl_rect) * num_clips;\n\treturn (struct qxl_rect *)dev_clips->chunk.data;\n}", "extracted_prediction": "<answer>\nThis function `drawable_set_clipping` allocates and initializes a `struct qxl_clip_rects` in the QXL device's buffer to manage multiple clipping rectangles. It maps the required data into the device's memory using `qxl_bo_kmap`, sets the number of rectangles (`num_rects`), initializes chunk pointers and data size (`data_size`), and returns the allocated data as a `struct qxl_rect`. If mapping fails, it returns `NULL`.\n</answer>"}
{"index": 433, "input": "**User**: \nxmlSecMSCryptoTransformHmacSha256GetKlass(void) {\n    return(&xmlSecMSCryptoHmacSha256Klass);\n}", "extracted_prediction": "<answer>\nThis function is a getter for the `xmlSecMSCryptoHmacSha256Klass` struct, returning a pointer to it. It is part of the Microsoft XML Security Message Service (MSMSharedProtocolSecurity) API, likely used for handling HMAC-SHA256 transformations in message security protocols.\n</answer>"}
{"index": 195, "input": "**User**: \nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}", "extracted_prediction": "<answer>\nThis function `flush_sigqueue_mask` updates the pending signal queue entries to ensure only signals matching the provided `sigset_t` mask are processed. It first creates a temporary signal set (`sigset_t m`) from the input mask and the current signal pending list. If the temporary set is empty, it exits early. Otherwise, it updates the actual signal pending list to include only signals in the mask. Finally, it iterates over the pending list, removes entries whose signals are no longer in the mask, and frees the associated signal queue structures.\n</answer>"}
{"index": 979, "input": "**User**: \ntask_energy(\n\ttask_t\ttask)\n{\n\tuint64_t energy = 0;\n\tthread_t thread;\n\n\ttask_lock(task);\n\tenergy += task->task_energy;\n\n\tqueue_iterate(&task->threads, thread, thread_t, task_threads) {\n\t\tspl_t x;\n\t\tx = splsched();\n\t\tthread_lock(thread);\n\t\tenergy += ml_energy_stat(thread);\n\t\tthread_unlock(thread);\n\t\tsplx(x);\n\t}\n\n\ttask_unlock(task);\n\treturn energy;\n}", "extracted_prediction": "<answer>\nThis function calculates the total energy consumed by a task and its associated threads. It starts by locking the task, adding the task's own energy (`task->task_energy`) to `energy`. Then, it iterates over all threads in the task using `queue_iterate`, locks each thread, adds the thread's energy (`ml_energy_stat(thread)`) to `energy`, unlocks the thread, and unlocks the scheduler. Finally, it returns the accumulated total energy.\n</answer>"}
{"index": 760, "input": "**User**: \naddr_policy_permits_address(uint32_t addr, uint16_t port,\n                            smartlist_t *policy)\n{\n  tor_addr_t a;\n  tor_addr_from_ipv4h(&a, addr);\n  return addr_policy_permits_tor_addr(&a, port, policy);\n}", "extracted_prediction": "<answer>\nThis function `addr_policy_permits_address` takes a network address (`addr`), a port number (`port`), and a policy (`policy`). It converts the address to a `tor_addr_t` structure using `tor_addr_from_ipv4h`, then checks if the policy permits the given address and port, returning the result.\n</answer>"}
{"index": 405, "input": "**User**: \nconvert_language_name(text *languagename)\n{\n\tchar\t   *langname = text_to_cstring(languagename);\n\n\treturn get_language_oid(langname, false);\n}", "extracted_prediction": "<answer>\nThis function `convert_language_name` takes a text string and a language name as input, converts the language name into a C-style null-terminated string using `text_to_cstring`, retrieves the associated object identifier (OID) from the converted string via `get_language_oid`, and returns the OID.\n</answer>"}
{"index": 714, "input": "**User**: \nvoid flush_tlb_mm(struct mm_struct *mm)\n{\n\ton_each_cpu(ipi_flush_tlb_all, NULL, 1);\n}", "extracted_prediction": "<answer>\nThis function flushes the translation lookaside buffer (TLB) for all processors in the system. It iterates over each CPU using `on_each_cpu` and invokes the `ipi_flush_tlb_all` interrupt/task priority flush function, enabling TLB invalidation when a TLB miss occurs. The third argument (`1`) likely indicates the flush operation is active.\n</answer>"}
{"index": 204, "input": "**User**: \nstatic inline void t_gen_add_flag(TCGv d, int flag)\n{\n    TCGv c;\n\n    c = tcg_temp_new();\n    t_gen_mov_TN_preg(c, PR_CCS);\n    /* Propagate carry into d.  */\n    tcg_gen_andi_tl(c, c, 1 << flag);\n    if (flag) {\n        tcg_gen_shri_tl(c, c, flag);\n    }\n    tcg_gen_add_tl(d, d, c);\n    tcg_temp_free(c);\n}", "extracted_prediction": "<answer>\nThe `t_gen_add_flag` function takes a `TCGv` object `d` and an integer `flag`, then performs the following operations:  \n\n1. **Create a temporary `TCGv` object** (`c`) using `tcg_temp_new()`.  \n2. **Move the flag bits into `c`** via `tcg_gen_andi_tl(c, c, 1 << flag)` (propagates carry into `d`).  \n3. **Generate a shift register** for the flag if `flag` is non-zero (`tcg_gen_shri_tl(c, c, flag)`).  \n4. **Add the shifted flag to `d`** using `tcg_gen_add_tl(d, d, c)`.  \n5. **Free the temporary `c`** with `tcg_temp_free(c)`.\n</answer>"}
{"index": 613, "input": "**User**: \nstatic int core_dump_signal(int sig)\n{\n    switch (sig) {\n    case TARGET_SIGABRT:\n    case TARGET_SIGFPE:\n    case TARGET_SIGILL:\n    case TARGET_SIGQUIT:\n    case TARGET_SIGSEGV:\n    case TARGET_SIGTRAP:\n    case TARGET_SIGBUS:\n        return (1);\n    default:\n        return (0);\n    }\n}", "extracted_prediction": "<answer>\nThis C function `core_dump_signal` checks if a given signal (`sig`) indicates a critical kernel error condition. It returns `1` (active) for signals such as `SIGABRT`, `SIGFPE`, `SIGILL`, `SIGQUIT`, `SIGSEGV`, `SIGTRAP`, or `SIGBUS`, indicating the kernel should trigger core dumps to handle the error. For other signals, it returns `0` (inactive).\n</answer>"}
{"index": 663, "input": "**User**: \ncreateTempGistContext(void)\n{\n\treturn AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t \"GiST temporary context\",\n\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n}", "extracted_prediction": "<answer>\nThe `createTempGistContext` function initializes a temporary GiST (Graphics International Technology) memory context by allocating it with default size settings using the current memory context. It returns an `AllocSetContextCreate` function call to configure the context.\n</answer>"}
{"index": 237, "input": "**User**: \nstatic char* CFArrayALPNCopyFirst(CFArrayRef alpnArray)\n{\n    CFIndex count = CFArrayGetCount(alpnArray);\n\n    if (count <= 0)\n        return NULL;\n\n    CFStringRef alpnVal = CFArrayGetValueAtIndex(alpnArray, 0);\n    return FromCFString(alpnVal, kCFStringEncodingASCII);\n}", "extracted_prediction": "<answer>\nThis function `CFArrayALPNCopyFirst` retrieves the first element of a given `CFArrayRef` (an array of CFTypeRef) and converts it to a `CString` using ASCII encoding. It first checks if the array is empty or null (returning `NULL` in such cases), then fetches the first element (index 0) via `CFArrayGetValueAtIndex`, and finally converts the retrieved `CFStringRef` to a `CString` using `FromCFString`. The result is returned as a `char*` pointer to the converted string.\n</answer>"}
{"index": 437, "input": "**User**: \nlast_window()\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}", "extracted_prediction": "<answer>\nThe `last_window()` function checks if a window exists (via `one_window()`) and if the `first_tabpage` is at the end of the tablist (i.e., its `next` pointer is `NULL`). It returns `true` only if both conditions are satisfied.\n</answer>"}
{"index": 866, "input": "**User**: \nbr_i62_modpow_opt_as_i31(uint32_t *x31, const unsigned char *e, size_t elen,\n\tconst uint32_t *m31, uint32_t m0i31, uint32_t *tmp, size_t twlen)\n{\n\t/*\n\t * As documented, this function expects the 'tmp' argument to be\n\t * 64-bit aligned. This is OK since this function is internal (it\n\t * is not part of BearSSL's public API).\n\t */\n\treturn br_i62_modpow_opt(x31, e, elen, m31, m0i31,\n\t\t(uint64_t *)tmp, twlen >> 1);\n}", "extracted_prediction": "<answer>\nThis function `br_i62_modpow_opt_as_i31` is an optimized variant of `br_i62_modpow_opt`, designed to compute modular exponentiation with a 32-bit result (`uint32_t`). It takes input parameters including a 32-bit value (`x31`), exponent (`e`), length (`elen`), base (`m31`), modulus (`m0i31`), and a temporary buffer (`tmp`) that must be **64-bit aligned** (aligned to `uint64_t` boundary). The internal implementation uses `tmp` to store intermediate results, with the final result returned as a 32-bit integer. The `twlen >> 1` adjusts the alignment of the temporary buffer to fit the 64-bit alignment requirement.\n</answer>"}
{"index": 743, "input": "**User**: \nvoid lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)\n{\n    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);\n\n    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);\n}", "extracted_prediction": "<answer>\nThis function sets the Y coordinate of a specified LV object. It first asserts the object is valid, then updates its position using its current X coordinate (from `lv_obj_get_x`) and the provided Y value (`y`).\n</answer>"}
{"index": 945, "input": "**User**: \nvoid default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state); }", "extracted_prediction": "<answer>\nThis function updates the default layer state by setting it to the address of the provided `layer_state_t` parameter. It copies the current state into itself using `default_layer_state_set`, effectively initializing the default layer state from the input state.\n</answer>"}
{"index": 392, "input": "**User**: \nstatic void pcmuio_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\n\tchip->enabled_mask = 0;\n\tchip->active = 0;\n\ts->async->inttrig = NULL;\n\n\t/* disable all intrs for this subdev.. */\n\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\n}", "extracted_prediction": "<answer>\nThis function `pcmuio_stop_intr` stops asynchronous interrupt handling for a specific subdevice in a Comedium video device. It:  \n1. Disables interrupt features (`chip->enabled_mask = 0`, `chip->active = 0`) for the target subdevice.  \n2. Clears the asynchronous interrupt trigger (`s->async->inttrig = NULL`).  \n3. Marks the interrupt enable bit in the deviceâ€™s memory using `PCMUIO_PAGE_ENAB` to ensure interrupts are disabled.  \n\n**Parameters**:  \n- `dev`: Pointer to the Comedium video device.  \n- `s`: Pointer to the target subdevice.\n</answer>"}
{"index": 786, "input": "**User**: \nINT MtAsicSetMacMaxLen(RTMP_ADAPTER *pAd)\n{\n\t/* Not support for HIF_MT */\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThe `MtAsicSetMacMaxLen` function is a C function that attempts to set the maximum length (`maxLen`) for a network adapter (`RTMP_ADAPTER`). It explicitly states it does not support the `HIF_MT` configuration. The function returns `0` to indicate failure. \n\n**Summary:**  \nA function to configure a network adapter's maximum length, with no support for `HIF_MT`, returning `0` on failure.\n</answer>"}
{"index": 149, "input": "**User**: \nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\n{\n\tstruct snd_interval t;\n\tt.empty = 0;\n\tt.min = t.max = val;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(i, &t);\n}", "extracted_prediction": "<answer>\nThis function `snd_interval_refine_set` initializes and configures a `struct snd_interval` structure to refine interval settings. It sets `t.min` and `t.max` to the provided `val`, initializes `t.empty` to 0, `t.openmin` and `t.openmax` to 0, and sets `t.integer` to 1 before calling `snd_interval_refine` to apply these changes to the interval structure.\n</answer>"}
{"index": 454, "input": "**User**: \nbool intel_gvt_in_force_nonpriv_whitelist(struct intel_gvt *gvt,\n\t\t\t\t\t  unsigned int offset)\n{\n\treturn in_whitelist(offset);\n}", "extracted_prediction": "<answer>\nThe `intel_gvt_in_force_nonpriv_whitelist` function checks if the Intel GVT (Global Transaction Vector) is being forced by a nonprivilege whitelist. It takes a pointer to an Intel GVT structure (`struct intel_gvt *gvt`) and an offset, then returns a boolean indicating whether the whitelist at the specified offset enforces this condition.\n</answer>"}
{"index": 3, "input": "**User**: \nvoid sqlite3SrcListAddAlias(SrcList *pList, Token *pToken){\n  if( pList && pList->nSrc>0 ){\n    pList->a[pList->nSrc-1].zAlias = sqlite3NameFromToken(pToken);\n  }\n}", "extracted_prediction": "<answer>\nThis function `sqlite3SrcListAddAlias` adds a SQLite-compatible alias to the last source entry in a `SrcList`. It checks if the list is non-empty (`pList` is valid and has at least one source), then updates the `zAlias` field of the last source entry in the list to the value derived from the current token via `sqlite3NameFromToken(pToken)`.\n</answer>"}
{"index": 91, "input": "**User**: \nstatic void spapr_machine_2_11_class_options(MachineClass *mc)\n{\n    SpaprMachineClass *smc = SPAPR_MACHINE_CLASS(mc);\n\n    spapr_machine_2_12_class_options(mc);\n    smc->default_caps.caps[SPAPR_CAP_HTM] = SPAPR_CAP_ON;\n    compat_props_add(mc->compat_props, hw_compat_2_11, hw_compat_2_11_len);\n}", "extracted_prediction": "<answer>\nThis function configures a machine class (`spapr_machine_2_11_class_options`) for the Spapr framework, specifically targeting 2.1 compatibility. It retrieves the machine class from the input pointer, calls a 2.2-compatible method, enables a hash table capability (`SPAPR_CAP_ON`), and adds a 2.1-compatible compatibility property to the machine class's properties.\n</answer>"}
{"index": 295, "input": "**User**: \nstatic void _sba_process_pending_requests(struct sba_device *sba)\n{\n\tint ret;\n\tu32 count;\n\tstruct sba_request *req;\n\n\t/* Process few pending requests */\n\tcount = SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL;\n\twhile (!list_empty(&sba->reqs_pending_list) && count) {\n\t\t/* Get the first pending request */\n\t\treq = list_first_entry(&sba->reqs_pending_list,\n\t\t\t\t       struct sba_request, node);\n\n\t\t/* Try to make request active */\n\t\tif (!_sba_active_request(sba, req))\n\t\t\tbreak;\n\n\t\t/* Send request to mailbox channel */\n\t\tret = sba_send_mbox_request(sba, req);\n\t\tif (ret < 0) {\n\t\t\t_sba_pending_request(sba, req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount--;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `_sba_process_pending_requests` iterates through pending SBA (System Block Architecture) requests stored in `sba->reqs_pending_list`. For each unprocessed request, it checks if the request is still active using `_sba_active_request`. If active, it sends the request to the mailbox via `sba_send_mbox_request`. If sending fails, it logs the failure and stops processing further requests. The loop terminates when all pending requests are processed or no more active requests remain.\n</answer>"}
{"index": 464, "input": "**User**: \nstatic int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned cpu = dev->id;\n\tint ret;\n\n\tdev_dbg(dev, \"%s: adding CPU%u\\n\", __func__, cpu);\n\n\tif (cpu_online(cpu)) {\n\t\tret = cpufreq_online(cpu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Create sysfs link on CPU registration */\n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy)\n\t\tadd_cpu_dev_symlink(policy, cpu);\n\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThis function `cpufreq_add_dev` adds a sysfs link for the CPU's cpufreq policy. It first verifies the CPU is online, then creates a sysfs entry for the current CPU's cpufreq policy via `per_cpu()`, and logs the action. Returns 0 on success; non-zero on failure.\n</answer>"}
{"index": 915, "input": "**User**: \nstatic void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)\n{\n\tu32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;\n\n\tif (mask & IXGBE_GSSR_TOKEN_SM)\n\t\tixgbe_put_phy_token(hw);\n\n\tif (hmask)\n\t\tixgbe_release_swfw_sync_X540(hw, hmask);\n}", "extracted_prediction": "<answer>\nThis function `ixgbe_release_swfw_sync_x550em_a` is responsible for releasing a sync token associated with the `swfw` component on the `X550E` device. It checks if the provided `mask` includes the `IXGBE_GSSR_TOKEN_SM` flag:  \n\n- If `mask` contains `IXGBE_GSSR_TOKEN_SM`, it first releases the sync token (`ixgbe_put_phy_token`) and then proceeds to release the `swfw` sync mechanism (`ixgbe_release_swfw_sync_X540`).  \n- If `mask` does not include `IXGBE_GSSR_TOKEN_SM`, it directly releases the `swfw` sync mechanism without releasing the sync token.  \n\nThe `hmask` variable (derived from `mask` via `mask & ~IXGBE_GSSR_TOKEN_SM`) indicates whether the sync token was part of the mask.\n</answer>"}
{"index": 708, "input": "**User**: \nmrb_str_setbyte(mrb_state *mrb, mrb_value str)\n{\n  mrb_int pos, byte;\n  mrb_int len;\n\n  mrb_get_args(mrb, \"ii\", &pos, &byte);\n\n  len = RSTRING_LEN(str);\n  if (pos < -len || len <= pos)\n    mrb_raisef(mrb, E_INDEX_ERROR, \"index %i out of string\", pos);\n  if (pos < 0)\n    pos += len;\n\n  mrb_str_modify(mrb, mrb_str_ptr(str));\n  byte &= 0xff;\n  RSTRING_PTR(str)[pos] = (unsigned char)byte;\n  return mrb_fixnum_value((unsigned char)byte);\n}", "extracted_prediction": "<answer>\nThis function `mrb_str_setbyte` modifies a specific byte in a string. It first validates the index to ensure it's within bounds, adjusts the index if negative, and then updates the string's internal data structure. The byte is masked to 8 bits before writing to the string. Returns the modified byte as a fixnum value. Errors are raised for invalid indices.\n</answer>"}
{"index": 703, "input": "**User**: \nvoid Close(vlc_object_t *object)\n{\n    intf_thread_t *intf = (intf_thread_t*)object;\n    intf_sys_t *sys = intf->p_sys;\n\n    var_DelCallback(sys->playlist, \"input-current\", PlaylistEvent, intf);\n\n    if (sys->input != NULL) {\n        vlc_cancel(sys->thread);\n        vlc_join(sys->thread, NULL);\n    }\n\n    net_Close(sys->fd);\n    free(sys);\n}", "extracted_prediction": "<answer>\nThis function `Close` deallocates and cleans up a VLC playback thread. It removes the input callback from the playlist, checks if there's an active input, cancels the playback thread, re-joins it to no longer track playback, closes the network connection, and frees the associated resources.\n</answer>"}
{"index": 969, "input": "**User**: \nstatic void scoll_base_module_construct(mca_scoll_base_module_t *m)\n{\n    /* Collective function pointers */\n    m->scoll_barrier = NULL;\n    m->scoll_broadcast = NULL;\n    m->scoll_collect = NULL;\n    m->scoll_reduce = NULL;\n    m->scoll_alltoall = NULL;\n    m->scoll_module_enable = NULL;\n}", "extracted_prediction": "<answer>\nThis static function initializes the `MCA_SCOLL_BASE_MODULE_T` structure by setting all collective operation function pointers (`scoll_barrier`, `scoll_broadcast`, etc.) to `NULL`. These function pointers are placeholders for future implementation of collective operations (e.g., barrier synchronization, broadcast messaging) that will be configured during module initialization.\n</answer>"}
{"index": 11, "input": "**User**: \nstatic enum ap_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_WAIT_NONE;\n}", "extracted_prediction": "<answer>\nThis code defines a static enum value `ap_sm_nop` (likely representing \"No Operation\" or \"Skipped\") within the `ap_wait` enum type. It is used by the `ap_queue` structure (`struct ap_queue *aq`) to indicate that no wait condition is required, returning the constant `AP_WAIT_NONE`.\n</answer>"}
{"index": 667, "input": "**User**: \nstatic const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\n\t/* We expect the OpenSSL library to construct GEN_DNS extension objects as\n\t   ASN1_IA5STRING values. Check we got the right union member. */\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\n\t/* Safe to treat as an ASCII string possibly holding a DNS name */\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\n\treturn dnsname;\n}", "extracted_prediction": "<answer>\nThis function `tls_dns_name` extracts a DNS name from a `GENERAL_NAME` structure. It first verifies the ASN1 value type of the subjectAltName (`gn->d.ia5`) is valid (asnron1_IA5STRING), then checks for internal null bytes in the string, and finally converts the ASN1 string to a `char*` (returning it; otherwise, returns `NULL` with warnings).\n</answer>"}
{"index": 8, "input": "**User**: \nstatic int ni65_open(struct net_device *dev)\n{\n\tstruct priv *p = dev->ml_priv;\n\tint irqval = request_irq(dev->irq, ni65_interrupt,0,\n                        cards[p->cardno].cardname,dev);\n\tif (irqval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d (irqval=%d).\\n\",\n\t\t          dev->name,dev->irq, irqval);\n\t\treturn -EAGAIN;\n\t}\n\n\tif(ni65_lance_reinit(dev))\n\t{\n\t\tnetif_start_queue(dev);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfree_irq(dev->irq,dev);\n\t\treturn -EAGAIN;\n\t}\n}", "extracted_prediction": "<answer>\nThe `ni65_open` function handles opening the ni65 network device in the Linux kernel. It first attempts to request an interrupt for the device using `request_irq`. If the interrupt cannot be requested (returns `-EAGAIN`), it logs an error and exits. If successful, it checks if the device needs reinitialization (`ni65_lance_reinit`). If not, it frees the allocated IRQ and exits. If reinitialization is required, it starts a netif queue. The summary captures the interrupt request, failure handling, reinitialization check, and IRQ cleanup logic.\n</answer>"}
