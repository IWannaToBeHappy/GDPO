{"index": 102, "input": "**User**: \nstatic int __init disable_timer_pin_setup(char *arg)\n{\n\tdisable_timer_pin_1 = 1;\n\treturn 0;\n}", "extracted_prediction": "This function, `disable_timer_pin_setup`, initializes a timer pin to be disabled. It sets `disable_timer_pin_1` to 1. The function returns 0, indicating successful setup."}
{"index": 294, "input": "**User**: \nstatic void mchip_cont_compression_start(void)\n{\n\tmchip_hic_stop();\n\tmchip_vrj_setup(0x3f);\n\tmchip_subsample();\n\tmchip_set_framerate();\n\tmchip_dma_setup(meye.mchip_dmahandle);\n\n\tmeye.mchip_mode = MCHIP_HIC_MODE_CONT_COMP;\n\n\tmchip_set(MCHIP_HIC_MODE, MCHIP_HIC_MODE_CONT_COMP);\n\tmchip_set(MCHIP_HIC_CMD, MCHIP_HIC_CMD_START);\n\n\tmchip_delay(MCHIP_HIC_CMD, 0);\n}", "extracted_prediction": "This function starts the MCHIP compression mode by stopping the HIC, setting up the VRJ, subsampling, setting the framerate, and configuring the DMA. It then sets the mode to CONT_COMP and starts the HIC with the appropriate command. The function also delays the HIC command to ensure proper operation."}
{"index": 803, "input": "**User**: \nstatic void mchip_load_tables(void)\n{\n\tint i;\n\tint length;\n\tu16 *tables;\n\n\ttables = jpeg_huffman_tables(&length);\n\tfor (i = 0; i < length; i++)\n\t\twritel(tables[i], meye.mchip_mmregs + MCHIP_VRJ_TABLE_DATA);\n\n\ttables = jpeg_quantisation_tables(&length, meye.params.quality);\n\tfor (i = 0; i < length; i++)\n\t\twritel(tables[i], meye.mchip_mmregs + MCHIP_VRJ_TABLE_DATA);\n}", "extracted_prediction": "This function loads JPEG tables into the MCHIP memory. It first retrieves the lengths of the tables using `jpeg_huffman_tables` and then iterates over the tables, writing each to the specified memory address using `writel`. It does the same for the quantisation tables, also using the provided function and writing each to the same memory address."}
{"index": 310, "input": "**User**: \nstatic void rs_close(struct tty_struct *tty, struct file * filp)\n{\n\tspin_lock_bh(&timer_lock);\n\tif (tty->count == 1)\n\t\tdel_timer_sync(&serial_timer);\n\tspin_unlock_bh(&timer_lock);\n}", "extracted_prediction": "This function closes a serial port by synchronizing the timer and removing it if the port is in use. It uses a spinlock to ensure thread safety."}
{"index": 387, "input": "**User**: \nnetworkstatus_parse_flavor_name(const char *flavname)\n{\n  if (!strcmp(flavname, \"ns\"))\n    return FLAV_NS;\n  else if (!strcmp(flavname, \"microdesc\"))\n    return FLAV_MICRODESC;\n  else\n    return -1;\n}", "extracted_prediction": "This function, `networkstatus_parse_flavor_name`, takes a string `flavname` as input and returns a constant integer representing the flavor name. It checks if the input string matches \"ns\" or \"microdesc\" and returns the corresponding constant integer. If the string does not match either, it returns -1."}
{"index": 218, "input": "**User**: \nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->autoneg_stat)\n\t\tmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\n\telse\n\t\t*auto_neg = 0;\n}", "extracted_prediction": "This function, `hns_mac_get_autoneg`, retrieves the auto-negotiation status of a network interface from the `mac_cb` structure. It then checks if the auto-negotiation status is active. If it is, it calls the `autoneg_stat` function on the `mac_ctrl_drv` object to update the `auto_neg` pointer with the current status. If the auto-negotiation is not active, it sets `auto_neg` to 0."}
{"index": 162, "input": "**User**: \nvoid  OS_EventWaitListInit (OS_EVENT *pevent)\n{\n    INT8U  i;\n\n\n    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */\n    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {\n        pevent->OSEventTbl[i] = 0u;\n    }\n}", "extracted_prediction": "The `OS_EventWaitListInit` function initializes an event wait list by setting the event group to 0 and clearing the event table with all values set to 0."}
{"index": 77, "input": "**User**: \nstatic inline void set_cpu_wakeup_addr(unsigned int cpu_id, u32 addr)\n{\n\tstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\n\n\tif (pm_info->wkup_sar_addr)\n\t\twritel_relaxed(addr, pm_info->wkup_sar_addr);\n}", "extracted_prediction": "This function sets the wakeup address for a specific CPU on an OMAP4 platform. It first retrieves the CPU PM information using the CPU ID. If the PM information has a 'wkup_sar_addr' field, it writes the provided address to that field."}
{"index": 290, "input": "**User**: \nstatic int calipso_sock_setattr(struct sock *sk,\n\t\t\t\tconst struct calipso_doi *doi_def,\n\t\t\t\tconst struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct ipv6_opt_hdr *old, *new;\n\tstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\n\n\told = NULL;\n\tif (txopts)\n\t\told = txopts->hopopt;\n\n\tnew = calipso_opt_insert(old, doi_def, secattr);\n\ttxopt_put(txopts);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tret_val = calipso_opt_update(sk, new);\n\n\tkfree(new);\n\treturn ret_val;\n}", "extracted_prediction": "This function sets attributes for a Calipso socket using the provided `doi_def` and `secattr`. It first checks if there are existing options in the `txopts` structure. If so, it copies the options to a new structure using `calipso_opt_insert`. If the new structure is not `PTR_ERR`, it updates the socket's options with `calipso_opt_update`. Finally, it frees the old options and returns the result."}
{"index": 352, "input": "**User**: \nstatic void quirk_vt82c598_id(struct pci_dev *dev)\n{\n\tpci_write_config_byte(dev, 0xfc, 0);\n\tpci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);\n}", "extracted_prediction": "This function writes 0x00 to the ID register of the PCI device and reads the device ID from the configuration space."}
{"index": 406, "input": "**User**: \nstatic int __init nforce2_init(void)\n{\n\t/* TODO: do we need to detect the processor? */\n\n\t/* detect chipset */\n\tif (nforce2_detect_chipset()) {\n\t\tpr_info(\"No nForce2 chipset\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn cpufreq_register_driver(&nforce2_driver);\n}", "extracted_prediction": "The `nforce2_init` function initializes the nForce2 chipset. It first checks if the chipset is detected. If not, it prints a message and returns `-ENODEV`. If the chipset is detected, it registers the nForce2 driver with `cpufreq_register_driver`."}
{"index": 932, "input": "**User**: \nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}", "extracted_prediction": "This function allocates a persistent key registration in the keyring for a given user namespace. It checks for errors and returns the allocated key registration if successful. If an error occurs, it returns the corresponding error code."}
{"index": 423, "input": "**User**: \nKONOHA_EXPORT(kbool_t) KonohaFactory_LoadPlatformModule(KonohaFactory *factory, const char *name, ModuleType option)\n{\n\tif(!factory->LoadPlatformModule(factory, name, option)) {\n\t\tfactory->LoggerModule.syslog_i(ErrTag, \"failed to load platform module: %s\\n\", name);\n\t\tfactory->printf_i(\"failed to load platform module: %s\\n\", name);\n\t\treturn true;\n\t}\n\treturn false;\n}", "extracted_prediction": "This function attempts to load a platform module for a KonohaFactory instance. If the loading fails, it logs an error and returns true. If successful, it returns false."}
{"index": 26, "input": "**User**: \nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}", "extracted_prediction": "This function retrieves the UUID of a hard disk by its location within a VBox snapshot configuration. It iterates through the machine's media registry to find the matching disk, then returns the UUID if found. If no disk is found, it returns NULL."}
{"index": 244, "input": "**User**: \nstatic int wacom_calc_hid_res(int logical_extents, int physical_extents,\n\t\t\t       unsigned unit, int exponent)\n{\n\tstruct hid_field field = {\n\t\t.logical_maximum = logical_extents,\n\t\t.physical_maximum = physical_extents,\n\t\t.unit = unit,\n\t\t.unit_exponent = exponent,\n\t};\n\n\treturn hidinput_calc_abs_res(&field, ABS_X);\n}", "extracted_prediction": "This function calculates the absolute resolution of a Wacom tablet using the provided logical and physical extent sizes, unit, and exponent. It returns the calculated resolution in pixels."}
{"index": 556, "input": "**User**: \nstatic void win32_load_config(char *conf)\n{\n\tcf_config_file = conf;\n\tinit_objects();\n\tload_config();\n}", "extracted_prediction": "This function initializes the configuration file path, initializes objects, and loads the configuration."}
{"index": 979, "input": "**User**: \ntask_energy(\n\ttask_t\ttask)\n{\n\tuint64_t energy = 0;\n\tthread_t thread;\n\n\ttask_lock(task);\n\tenergy += task->task_energy;\n\n\tqueue_iterate(&task->threads, thread, thread_t, task_threads) {\n\t\tspl_t x;\n\t\tx = splsched();\n\t\tthread_lock(thread);\n\t\tenergy += ml_energy_stat(thread);\n\t\tthread_unlock(thread);\n\t\tsplx(x);\n\t}\n\n\ttask_unlock(task);\n\treturn energy;\n}", "extracted_prediction": "The `task_energy` function calculates the total energy consumed by a task, including the energy used by its threads. It first acquires the task's lock and adds its energy to the total. Then, it iterates through the thread list of the task, acquiring each thread's lock, adding its energy to the total, and finally unlocking each thread. The function returns the total energy consumed by the task."}
{"index": 709, "input": "**User**: \nstatic int nv_tco_open(struct inode *inode, struct file *file)\n{\n\t/* /dev/watchdog can only be opened once */\n\tif (test_and_set_bit(0, &timer_alive))\n\t\treturn -EBUSY;\n\n\t/* Reload and activate timer */\n\ttco_timer_keepalive();\n\ttco_timer_start();\n\treturn stream_open(inode, file);\n}", "extracted_prediction": "This function attempts to open the device `/dev/watchdog`. It first checks if the timer is already active by using `test_and_set_bit(0, &timer_alive)`. If the bit is set, indicating the timer is busy, it returns -EBUSY. If not busy, it proceeds to reload and activate the timer using `tco_timer_keepalive()` and `tco_timer_start()`. Finally, it calls `stream_open(inode, file)` to open the device normally."}
{"index": 571, "input": "**User**: \nstatic void *gradcor_start( IMAGE *out, void *vptr_large, void *unrequired ){\n\n  gradcor_seq_t *seq= IM_NEW( NULL, gradcor_seq_t );\n  if( ! seq )\n    return NULL;\n\n  seq-> region_xgrad= (int*) NULL;\n  seq-> region_ygrad= (int*) NULL;\n  seq-> region_xgrad_area= 0;\n  seq-> region_ygrad_area= 0;\n\n  seq-> reg= im_region_create( (IMAGE*) vptr_large );\n  if( ! seq-> reg ){\n    im_free( (void*) seq );\n    return NULL;\n  }\n  return (void*) seq;\n}", "extracted_prediction": "This function allocates memory for a `gradcor_seq_t` structure, initializes it with default values, and creates a region from the provided `vptr_large` image. If the region creation is successful, it returns a pointer to the `gradcor_seq_t` structure; otherwise, it frees the allocated memory and returns `NULL`."}
{"index": 852, "input": "**User**: \npreviewprg_global(OPT_OP op, optval_t val)\n{\n\treplace_string(&curr_view->preview_prg_g, val.str_val);\n}", "extracted_prediction": "This function replaces the string value of `preview_prg_g` in `curr_view` with the provided string `val.str_val`."}
{"index": 227, "input": "**User**: \nstatic void tun_net_uninit(struct net_device *dev)\n{\n\ttun_detach_all(dev);\n}", "extracted_prediction": "This function, `tun_net_uninit`, uninitializes a network interface by detaching all associated tunnels."}
{"index": 141, "input": "**User**: \nstatic inline int regpairs_aligned(void *cpu_env, int num)\n{\n    switch (num) {\n    case TARGET_NR_pread64:\n    case TARGET_NR_pwrite64:\n        return 1;\n\n    default:\n        return 0;\n    }\n}", "extracted_prediction": "This function checks if the `num` parameter is one of the predefined constants `TARGET_NR_pread64` or `TARGET_NR_pwrite64`. If it is, it returns `1`; otherwise, it returns `0`."}
{"index": 585, "input": "**User**: \nstatic const char *yesno(int x)\n{\n\tstatic const char *yes = \"yes\";\n\tstatic const char *no = \"no\";\n\n\treturn x ? yes : no;\n}", "extracted_prediction": "The `yesno` function returns \"yes\" if the integer `x` is non-zero, and \"no\" otherwise."}
{"index": 136, "input": "**User**: \nvoid qemu_file_set_error(QEMUFile *f, int ret)\n{\n    qemu_file_set_error_obj(f, ret, NULL);\n}", "extracted_prediction": "This function sets an error for a QEMUFile object by passing the error code to the internal function qemu_file_set_error_obj()."}
{"index": 950, "input": "**User**: \nstatic inline unsigned char parport_ip32_read_status(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn readb(priv->regs.dsr);\n}", "extracted_prediction": "This function reads the DSR (Data Set Ready) register from the IP32 port specified by `p`. It returns the value of the DSR register as an unsigned char."}
{"index": 369, "input": "**User**: \nstatic unsigned ODDescriptorLength( unsigned *pi_data, const uint8_t **pp_data )\n{\n    unsigned int i_b;\n    unsigned int i_len = 0;\n\n    if(*pi_data == 0)\n        return 0;\n\n    do\n    {\n        i_b = **pp_data;\n        (*pp_data)++;\n        (*pi_data)--;\n        i_len = ( i_len << 7 ) + ( i_b&0x7f );\n\n    } while( i_b&0x80 && *pi_data > 0 );\n\n    if (i_len > *pi_data)\n        i_len = *pi_data;\n\n    return i_len;\n}", "extracted_prediction": "This function calculates the ODDescriptorLength of a data structure pointed to by `pi_data`. It initializes `i_len` to 0 and checks if `pi_data` is 0. If it is, the function returns 0. Otherwise, it enters a loop where it reads the next byte from `pp_data`, decrements `pi_data`, and left-shifts `i_len` by 7 and adds the least significant bit of `i_b` to it. The loop continues until `i_b` is not 0 and `pi_data` is still positive. If `i_len` exceeds `pi_data`, it is set to `pi_data`. Finally, the function returns `i_len`."}
{"index": 620, "input": "**User**: \nvoid SigGroupHeadPrintSigs(DetectEngineCtx *de_ctx, SigGroupHead *sgh)\n{\n    SCEnter();\n\n    if (sgh == NULL) {\n        SCReturn;\n    }\n\n    uint32_t u;\n\n    SCLogDebug(\"The Signatures present in this SigGroupHead are: \");\n    for (u = 0; u < (sgh->init->sig_size * 8); u++) {\n        if (sgh->init->sig_array[u / 8] & (1 << (u % 8))) {\n            SCLogDebug(\"%\" PRIu32, u);\n            printf(\"s->num %\"PRIu32\" \", u);\n        }\n    }\n\n    SCReturn;\n}", "extracted_prediction": "This function prints the signatures present in a `SigGroupHead` by iterating through each byte of the `sig_array` and checking if it contains a set bit (1). It logs the signature number and prints it to the console. If the `SigGroupHead` is `NULL`, it returns."}
{"index": 449, "input": "**User**: \nstatic grp_stack_item* grp_stack_append(\n  grp_stack_item* last, grp_stack_data data\n) {\n  /* first create a new stack item, and copy data to it */\n  grp_stack_item* new_item = (grp_stack_item*) malloc(sizeof(grp_stack_item));\n  new_item->data = data;\n  if(last) {\n    /* attach this item between the \"last\" item and its \"next\" item */\n    new_item->next = last->next;\n    new_item->prev = last;\n    last->next->prev = new_item;\n    last->next = new_item;\n  } else {\n    /* stack is empty, so \"next\" and \"previous\" both point back to it */\n    new_item->next = new_item;\n    new_item->prev = new_item;\n  }\n  return new_item;\n}", "extracted_prediction": "This function appends a new stack item to the end of a stack. If the stack is not empty, the new item is inserted between the last item and its next item. If the stack is empty, the new item becomes the only item in the stack. The function returns the new stack item."}
{"index": 58, "input": "**User**: \nstatic int is_number(const char* s) {\n  size_t i;\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\n  return 1;\n}", "extracted_prediction": "The `is_number` function checks if a given string `s` represents a number. It iterates through each character of the string and uses `strchr` to check if the character is a digit (0-9). If any character is not a digit, the function returns 0, indicating the string is not a number. If all characters are digits, it returns 1, indicating the string is a number."}
{"index": 195, "input": "**User**: \nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}", "extracted_prediction": "This function flushes the signal queue mask by merging the signal set from the mask and the sigpending structure, then iterating through the list of queued signals, removing any that are no longer in the mask, and freeing the allocated memory for each signal queue."}
{"index": 736, "input": "**User**: \nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)\n{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));\n  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)\n  {\n    /* Drive the SMBusAlert pin Low */\n    I2Cx->CR1 |= I2C_SMBusAlert_Low;\n  }\n  else\n  {\n    /* Drive the SMBusAlert pin High  */\n    I2Cx->CR1 &= I2C_SMBusAlert_High;\n  }\n}", "extracted_prediction": "The function `I2C_SMBusAlertConfig` configures the SMBusAlert pin for a specified I2C peripheral. It first checks if the parameters are valid, then sets the pin state based on the `I2C_SMBusAlert` parameter. If `I2C_SMBusAlert` is `I2C_SMBusAlert_Low`, it drives the pin low; otherwise, it drives the pin high."}
{"index": 275, "input": "**User**: \nscroll_up_dashboard (void)\n{\n  gscroll.dash--;\n}", "extracted_prediction": "The `scroll_up_dashboard` function decreases the value of `gscroll.dash` by one."}
{"index": 899, "input": "**User**: \nstatic struct gtt_range *psbfb_alloc(struct drm_device *dev, int aligned_size)\n{\n\tstruct gtt_range *backing;\n\t/* Begin by trying to use stolen memory backing */\n\tbacking = psb_gtt_alloc_range(dev, aligned_size, \"fb\", 1, PAGE_SIZE);\n\tif (backing) {\n\t\tdrm_gem_private_object_init(dev, &backing->gem, aligned_size);\n\t\treturn backing;\n\t}\n\treturn NULL;\n}", "extracted_prediction": "This function attempts to allocate a GTT range using stolen memory from the frame buffer. If successful, it initializes the GEM object for the allocated range. If not, it returns NULL."}
{"index": 594, "input": "**User**: \nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}", "extracted_prediction": "This function adds an inode to the end of the list in the inode's superblock's inode list. It uses a spinlock to ensure thread safety during the list operations."}
{"index": 569, "input": "**User**: \nvoid cxgb4_dcb_state_init(struct net_device *dev)\n{\n\tstruct port_info *pi = netdev2pinfo(dev);\n\tstruct port_dcb_info *dcb = &pi->dcb;\n\tint version_temp = dcb->dcb_version;\n\n\tmemset(dcb, 0, sizeof(struct port_dcb_info));\n\tdcb->state = CXGB4_DCB_STATE_START;\n\tif (version_temp)\n\t\tdcb->dcb_version = version_temp;\n\n\tnetdev_dbg(dev, \"%s: Initializing DCB state for port[%d]\\n\",\n\t\t    __func__, pi->port_id);\n}", "extracted_prediction": "The `cxgb4_dcb_state_init` function initializes the DCB (Data Center Bridging) state for a given port on a network device. It sets the state to `CXGB4_DCB_STATE_START` and updates the `dcb_version` if provided. It also logs a debug message indicating the port ID being initialized."}
{"index": 774, "input": "**User**: \nstatic unsigned char __init calc_idprom_cksum(struct idprom *idprom)\n{\n\tunsigned char cksum, i, *ptr = (unsigned char *)idprom;\n\n\tfor (i = cksum = 0; i <= 0x0E; i++)\n\t\tcksum ^= *ptr++;\n\n\treturn cksum;\n}", "extracted_prediction": "This function calculates the CRC-16 checksum of an IDProm device by iterating through each byte of the IDProm data, XORing it with the current checksum value, and then updating the checksum with the new byte. The checksum is returned at the end."}
{"index": 580, "input": "**User**: \nstatic void initio_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct initio_host *s = (struct initio_host *)host->hostdata;\n\tscsi_remove_host(host);\n\tfree_irq(pdev->irq, host);\n\trelease_region(s->addr, 256);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}", "extracted_prediction": "This function initializes the removal of a device by:\n1. Retrieving the SCSI host data associated with the PCI device.\n2. Removing the SCSI host from the system.\n3. Freeing the IRQ associated with the device.\n4. Releasing the memory region used by the device.\n5. Putting the SCSI host to a put state.\n6. Disabling the PCI device."}
{"index": 638, "input": "**User**: \nstatic irqreturn_t gr_irq(int irq, void *_dev)\n{\n\tstruct gr_udc *dev = _dev;\n\n\tif (!dev->irq_enabled)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_WAKE_THREAD;\n}", "extracted_prediction": "This function checks if the UDC (USB Device Controller) interrupt is enabled. If not, it returns `IRQ_NONE`. If enabled, it returns `IRQ_WAKE_THREAD` to wake up the thread handling the UDC interrupt."}
{"index": 711, "input": "**User**: \nvoid devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)\n{\n\tWARN_ON(devres_release(dev, devm_gpiod_release_array,\n\t\t\t       devm_gpiod_match_array, &descs));\n}", "extracted_prediction": "This function releases the gpiod resources associated with a gpio array on a device. It uses the `devres_release` function to release the resources, passing in the device, the release function, the match function, and the gpio descriptor array. If the release fails, it uses the `WARN_ON` macro to print a warning message."}
{"index": 696, "input": "**User**: \nstatic void sama5d2_piobu_set(struct gpio_chip *chip, unsigned int pin,\n\t\t\t      int value)\n{\n\tif (!value)\n\t\tvalue = PIOBU_LOW;\n\telse\n\t\tvalue = PIOBU_HIGH;\n\n\tsama5d2_piobu_write_value(chip, pin, PIOBU_SOD, value);\n}", "extracted_prediction": "This function sets the GPIO pin on the Sama5D2 SoC to a specified value (either low or high) using the PIOBU register. If the value is not specified, it defaults to PIOBU_LOW. The function writes the value to the PIOBU register for the specified pin."}
{"index": 368, "input": "**User**: \nint isapnp_present(void)\n{\n\tstruct pnp_card *card;\n\n\tpnp_for_each_card(card) {\n\t\tif (card->protocol == &isapnp_protocol)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "extracted_prediction": "This function checks if the ISAPNP protocol is present on a PNP card by iterating through all cards and checking if the protocol pointer matches the ISAPNP protocol. If a match is found, it returns 1; otherwise, it returns 0."}
{"index": 206, "input": "**User**: \nbegin_tup_output_tupdesc(DestReceiver *dest,\n\t\t\t\t\t\t TupleDesc tupdesc,\n\t\t\t\t\t\t const TupleTableSlotOps *tts_ops)\n{\n\tTupOutputState *tstate;\n\n\ttstate = (TupOutputState *) palloc(sizeof(TupOutputState));\n\n\ttstate->slot = MakeSingleTupleTableSlot(tupdesc, tts_ops);\n\ttstate->dest = dest;\n\n\ttstate->dest->rStartup(tstate->dest, (int) CMD_SELECT, tupdesc);\n\n\treturn tstate;\n}", "extracted_prediction": "This function creates a new `TupOutputState` object, initializes it with a tuple table slot, and sets up the destination receiver. It returns the `TupOutputState` pointer."}
{"index": 928, "input": "**User**: \nstatic void ice_vsi_set_num_desc(struct ice_vsi *vsi)\n{\n\tswitch (vsi->type) {\n\tcase ICE_VSI_PF:\n\t\t/* fall through */\n\tcase ICE_VSI_LB:\n\t\tvsi->num_rx_desc = ICE_DFLT_NUM_RX_DESC;\n\t\tvsi->num_tx_desc = ICE_DFLT_NUM_TX_DESC;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Not setting number of Tx/Rx descriptors for VSI type %d\\n\",\n\t\t\tvsi->type);\n\t\tbreak;\n\t}\n}", "extracted_prediction": "This function sets the default number of Rx and Tx descriptors for a VSI based on its type. If the type is PF or LB, the default values are used. Otherwise, an error message is logged."}
{"index": 237, "input": "**User**: \nstatic char* CFArrayALPNCopyFirst(CFArrayRef alpnArray)\n{\n    CFIndex count = CFArrayGetCount(alpnArray);\n\n    if (count <= 0)\n        return NULL;\n\n    CFStringRef alpnVal = CFArrayGetValueAtIndex(alpnArray, 0);\n    return FromCFString(alpnVal, kCFStringEncodingASCII);\n}", "extracted_prediction": "This function copies the first element of a CFArray containing ALPN (Application Layer Protocol Negotiation) values and returns a static char* string. If the array is empty or null, it returns NULL. The function converts the CFString to ASCII encoding."}
{"index": 490, "input": "**User**: \nvoid* CMSEXPORT cmsGetContextUserData(cmsContext ContextID)\n{\n    return _cmsContextGetClientChunk(ContextID, UserPtr);\n}", "extracted_prediction": "This function, `cmsGetContextUserData`, retrieves the user data associated with a specified context ID. It returns a `void*` pointer to the user data. The function uses the `_cmsContextGetClientChunk` function to access the user data chunk for the given context ID."}
{"index": 663, "input": "**User**: \ncreateTempGistContext(void)\n{\n\treturn AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t \"GiST temporary context\",\n\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n}", "extracted_prediction": "The `createTempGistContext` function allocates a temporary GiST (Generalized Search Tree) context using the current memory context as the base, with the name \"GiST temporary context,\" and sets the default size for the allocated set."}
{"index": 329, "input": "**User**: \nstruct tcp_congestion_ops *tcp_ca_find_key(u32 key)\n{\n\tstruct tcp_congestion_ops *e;\n\n\tlist_for_each_entry_rcu(e, &tcp_cong_list, list) {\n\t\tif (e->key == key)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}", "extracted_prediction": "This function searches for a TCP congestion control key within the `tcp_cong_list` list. It iterates through the list using `list_for_each_entry_rcu` and checks if the current entry's `key` matches the provided `key`. If a match is found, it returns the corresponding `struct tcp_congestion_ops` pointer. If no match is found after iterating through the entire list, it returns `NULL`."}
{"index": 419, "input": "**User**: \nstatic void dwc2_kill_all_urbs(struct dwc2_hsotg *hsotg)\n{\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_waiting);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_active);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_ready);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_assigned);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_queued);\n}", "extracted_prediction": "This function, `dwc2_kill_all_urbs`, iterates over the queued hardware urb (URB) lists for non-periodic and periodic scheduling states and calls `dwc2_kill_urbs_in_qh_list` to deallocate the URBs. The function ensures that all URBs in the specified lists are killed."}
{"index": 729, "input": "**User**: \nxo_style_is_encoding (xo_handle_t *xop)\n{\n    if (xo_style(xop) == XO_STYLE_JSON\n\t|| xo_style(xop) == XO_STYLE_XML\n\t|| xo_style(xop) == XO_STYLE_SDPARAMS\n\t|| xo_style(xop) == XO_STYLE_ENCODER)\n\treturn 1;\n    return 0;\n}", "extracted_prediction": "The function `xo_style_is_encoding` checks if the given `xo_handle_t` object is in one of the encoding styles: JSON, XML, SDPARMS, or ENCODER. It returns `1` if it is one of these styles and `0` otherwise."}
{"index": 229, "input": "**User**: \npg_get_indexdef_string(Oid indexrelid)\n{\n\treturn pg_get_indexdef_worker(indexrelid, 0, NULL,\n\t\t\t\t\t\t\t\t  false, false,\n\t\t\t\t\t\t\t\t  true, true,\n\t\t\t\t\t\t\t\t  0, false);\n}", "extracted_prediction": "This function, `pg_get_indexdef_string`, retrieves the definition of an index from a PostgreSQL database. It takes an `Oid` parameter representing the index's relation ID and returns a string containing the index definition. The function uses the `pg_get_indexdef_worker` function with various parameters to specify the type of index, whether it is unique, and whether it is a computed or system index. The result is a string that represents the definition of the index."}
{"index": 481, "input": "**User**: \nstatic struct qed_mcp_cmd_elem *qed_mcp_cmd_get_elem(struct qed_hwfn *p_hwfn,\n\t\t\t\t\t\t     u16 seq_num)\n{\n\tstruct qed_mcp_cmd_elem *p_cmd_elem = NULL;\n\n\tlist_for_each_entry(p_cmd_elem, &p_hwfn->mcp_info->cmd_list, list) {\n\t\tif (p_cmd_elem->expected_seq_num == seq_num)\n\t\t\treturn p_cmd_elem;\n\t}\n\n\treturn NULL;\n}", "extracted_prediction": "This function retrieves a command element from a list of command elements associated with a hardware function. It iterates through the list to find an element with the matching expected sequence number. If found, it returns the element; otherwise, it returns NULL."}
{"index": 98, "input": "**User**: \nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\n{\n\tif (!vha->vha_tgt.qla_tgt)\n\t\treturn 0;\n\n\tif (vha->fc_vport) {\n\t\tqlt_release(vha->vha_tgt.qla_tgt);\n\t\treturn 0;\n\t}\n\n\t/* free left over qfull cmds */\n\tqlt_init_term_exchange(vha);\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe03c, \"Unregistering target for host %ld(%p)\",\n\t    vha->host_no, ha);\n\tqlt_release(vha->vha_tgt.qla_tgt);\n\n\treturn 0;\n}", "extracted_prediction": "This function removes a target from a host on a QLogic adapter. It first checks if the target is present and if so, it releases the target. If the FCP Vport is present, it releases the target as well. It then initializes the term exchange and logs a debug message. Finally, it returns 0."}
{"index": 886, "input": "**User**: \nstatic void set_threshold(struct hfi1_devdata *dd, int scontext, int i)\n{\n\tu32 thres;\n\n\tthres = min(sc_percent_to_threshold(dd->kernel_send_context[scontext],\n\t\t\t\t\t    50),\n\t\t    sc_mtu_to_threshold(dd->kernel_send_context[scontext],\n\t\t\t\t\tdd->vld[i].mtu,\n\t\t\t\t\tdd->rcd[0]->rcvhdrqentsize));\n\tsc_set_cr_threshold(dd->kernel_send_context[scontext], thres);\n}", "extracted_prediction": "This function sets the threshold for a specific context in the kernel send context. It calculates the threshold based on the percentage of the send context's size and the maximum transmission unit (MTU) of the data. The threshold is then set using the `sc_set_cr_threshold` function."}
{"index": 432, "input": "**User**: \nenum ice_status ice_clear_pf_cfg(struct ice_hw *hw)\n{\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_clear_pf_cfg);\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n}", "extracted_prediction": "The function `ice_clear_pf_cfg` takes a pointer to an `ice_hw` structure and returns an integer. It fills a default direct command description for `ice_aqc_opc_clear_pf_cfg` and then sends the command using `ice_aq_send_cmd`."}
{"index": 649, "input": "**User**: \nstatic inline void zero_ino_node_unused(struct ubifs_ino_node *ino)\n{\n\tmemset(ino->padding1, 0, 4);\n\tmemset(ino->padding2, 0, 26);\n}", "extracted_prediction": "This function zeroes out the unused padding fields of a `struct ubifs_ino_node` by setting all values to zero. The `padding1` field is 4 bytes long, and the `padding2` field is 26 bytes long."}
{"index": 469, "input": "**User**: \nstatic int load_default_rx_configuration(struct fmdev *fmdev)\n{\n\tint ret;\n\n\tret = fm_rx_set_volume(fmdev, FM_DEFAULT_RX_VOLUME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fm_rx_set_rssi_threshold(fmdev, FM_DEFAULT_RSSI_THRESHOLD);\n}", "extracted_prediction": "This function loads the default RX configuration for a device. It sets the RX volume to the default value and then sets the RSSI threshold to the default value. If either operation fails, the function returns an error code."}
{"index": 494, "input": "**User**: \nstatic int velocity_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint ret;\n\n\t/* If we are asked for information and the device is power\n\t   saving then we need to bring the device back up to talk to it */\n\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D0);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\t/* Get address of MII PHY in use. */\n\tcase SIOCGMIIREG:\t/* Read MII PHY register. */\n\tcase SIOCSMIIREG:\t/* Write to MII PHY register. */\n\t\tret = velocity_mii_ioctl(dev, rq, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\n\n\treturn ret;\n}", "extracted_prediction": "This function `velocity_ioctl` handles various I/O control commands for a `struct net_device` instance. It first checks if the device is powered off and, if so, it sets the device to the PCI_D0 state using `velocity_set_power_state`. Depending on the command (`SIOCGMIIPHY`, `SIOCGMIIREG`, or `SIOCSMIIREG`), it calls `velocity_mii_ioctl` to perform the requested operation. If the command is not one of the supported ones, it returns an error (-EOPNOTSUPP). After handling the command, it ensures the device is powered on again by setting the power state to PCI_D3hot if the device was previously powered off."}
{"index": 139, "input": "**User**: \nstatic void ufshcd_async_scan(void *data, async_cookie_t cookie)\n{\n\tstruct ufs_hba *hba = (struct ufs_hba *)data;\n\n\tufshcd_probe_hba(hba);\n}", "extracted_prediction": "This function, `ufshcd_async_scan`, takes a pointer to a `struct ufs_hba` and an `async_cookie_t` as arguments. It initializes the `ufshcd_probe_hba` function to probe the UFS HBA."}
{"index": 298, "input": "**User**: \npb_tnc_msg_t* pb_remediation_parameters_msg_create_from_uri(chunk_t uri)\n{\n\tpen_type_t type = { PEN_IETF, PB_REMEDIATION_URI };\n\n\treturn pb_remediation_parameters_msg_create(type, uri);\n}", "extracted_prediction": "This function creates a `pb_remediation_parameters_msg` object from a given URI. It initializes the message type to `PEN_IETF` and `PB_REMEDIATION_URI`."}
{"index": 138, "input": "**User**: \nstatic bool is_pkcs11_uri(const char *string)\n{\n  if(curl_strnequal(string, \"pkcs11:\", 7)) {\n    return TRUE;\n  }\n  else {\n    return FALSE;\n  }\n}", "extracted_prediction": "The function `is_pkcs11_uri` checks if a given string is a PKCS#11 URI. It returns `TRUE` if the string starts with \"pkcs11:\" (case-insensitive) and ends with a colon, and `FALSE` otherwise."}
{"index": 988, "input": "**User**: \ndns_servers_relaunch_checks(void)\n{\n  if (server_mode(get_options())) {\n    dns_reset_correctness_checks();\n    time_to_check_for_correct_dns = 0;\n  }\n}", "extracted_prediction": "This function checks if the server mode is enabled and, if so, resets the correctness checks for DNS and sets a timer for checking DNS again."}
{"index": 380, "input": "**User**: \nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}", "extracted_prediction": "This function, `ext4_journalled_invalidatepage`, is a part of the ext4 file system's journaling mechanism. It invalidates a page in the journal, which is used to track metadata changes. The function first checks if the invalidation is successful using `WARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0)`. If the invalidation fails, it reports an error using `WARN_ON`."}
{"index": 262, "input": "**User**: \nserver_child_exited(pid_t pid, int status)\n{\n\tstruct window\t\t*w, *w1;\n\tstruct window_pane\t*wp;\n\tstruct job\t\t*job;\n\n\tRB_FOREACH_SAFE(w, windows, &windows, w1) {\n\t\tTAILQ_FOREACH(wp, &w->panes, entry) {\n\t\t\tif (wp->pid == pid) {\n\t\t\t\twp->status = status;\n\t\t\t\tserver_destroy_pane(wp, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tLIST_FOREACH(job, &all_jobs, lentry) {\n\t\tif (pid == job->pid) {\n\t\t\tjob_died(job, status);\t/* might free job */\n\t\t\tbreak;\n\t\t}\n\t}\n}", "extracted_prediction": "The `server_child_exited` function handles the termination of a child process by updating the status of the associated window panes and jobs. It iterates through the list of windows and their panes to find the one with the matching process ID. Once found, it sets the status to 'EXITED' and destroys the pane. Additionally, it checks the list of all jobs to see if the process ID matches and handles the job's termination, potentially freeing the job structure."}
{"index": 710, "input": "**User**: \nvoid br_recalculate_fwd_mask(struct net_bridge *br)\n{\n\tif (!br_opt_get(br, BROPT_VLAN_ENABLED) ||\n\t    br->vlan_proto == htons(ETH_P_8021Q))\n\t\tbr->group_fwd_mask_required = BR_GROUPFWD_DEFAULT;\n\telse /* vlan_enabled && ETH_P_8021AD */\n\t\tbr->group_fwd_mask_required = BR_GROUPFWD_8021AD &\n\t\t\t\t\t      ~(1u << br->group_addr[5]);\n}", "extracted_prediction": "This function recalculates the forwarding mask for a bridge. If the bridge is not configured for VLANs or if it uses Ethernet protocol version 802.1Q, the default forwarding mask is set to BR_GROUPFWD_DEFAULT. Otherwise, if VLANs are enabled and the protocol is Ethernet protocol version 802.1AD, the forwarding mask is set to BR_GROUPFWD_8021AD & ~(1u << br->group_addr[5])."}
{"index": 204, "input": "**User**: \nstatic inline void t_gen_add_flag(TCGv d, int flag)\n{\n    TCGv c;\n\n    c = tcg_temp_new();\n    t_gen_mov_TN_preg(c, PR_CCS);\n    /* Propagate carry into d.  */\n    tcg_gen_andi_tl(c, c, 1 << flag);\n    if (flag) {\n        tcg_gen_shri_tl(c, c, flag);\n    }\n    tcg_gen_add_tl(d, d, c);\n    tcg_temp_free(c);\n}", "extracted_prediction": "This function, `t_gen_add_flag`, takes a TCGv (`TCGv`) and an integer `flag`. It creates a temporary variable `c` and initializes it with a new TCGv. It then moves the contents of `c` into the `PR_CCS` register. It performs a bitwise AND operation between `c` and `c` with the bit set at position `flag` (i.e., `1 << flag`), which propagates the carry into `d`. If `flag` is non-zero, it shifts the result of the AND operation left by `flag` positions and adds it to `d`. Finally, it frees the temporary variable `c`."}
{"index": 714, "input": "**User**: \nvoid flush_tlb_mm(struct mm_struct *mm)\n{\n\ton_each_cpu(ipi_flush_tlb_all, NULL, 1);\n}", "extracted_prediction": "This function, `flush_tlb_mm`, is intended to flush the Translation Lookaside Buffer (TLB) for all CPUs in the specified memory management unit (mm). It does this by invoking the `ipi_flush_tlb_all` IPI (Inter-Process Communication) handler on each CPU, passing `NULL` as the context and executing the handler once."}
{"index": 125, "input": "**User**: \nfindTableByOid(Oid oid)\n{\n\treturn (TableInfo *) findObjectByOid(oid, tblinfoindex, numTables);\n}", "extracted_prediction": "This function `findTableByOid` retrieves a `TableInfo` object from a list of tables using the OID (Object ID) as a key. It calls the `findObjectByOid` function to locate the object in the `tblinfoindex` array, which contains pointers to table information, and returns the corresponding `TableInfo` pointer."}
{"index": 391, "input": "**User**: \nstatic u32 vfp_single_fsub(int sd, int sn, s32 m, u32 fpscr)\n{\n\t/*\n\t * Subtraction is addition with one sign inverted.\n\t */\n\treturn vfp_single_fadd(sd, sn, vfp_single_packed_negate(m), fpscr);\n}", "extracted_prediction": "This function performs a single-precision floating-point subtraction by inverting the sign of the second argument and adding it to the first argument. The result is returned."}
{"index": 467, "input": "**User**: \nstatic host_t *get_subnet_address(private_kernel_netlink_net_t *this,\n\t\t\t\t\t\t\t\t  int family, chunk_t net, uint8_t mask,\n\t\t\t\t\t\t\t\t  host_t *dest, host_t *candidate)\n{\n\treturn get_matching_address(this, NULL, family, net, mask, dest, candidate);\n}", "extracted_prediction": "This function, `get_subnet_address`, retrieves an address from a subnet specified by a family, net, and mask. It returns the matching address between the destination and candidate provided."}
{"index": 945, "input": "**User**: \nvoid default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state); }", "extracted_prediction": "This function sets the default layer state to the provided state."}
{"index": 268, "input": "**User**: \nstatic void gtkui_update(int target)\n{\n    switch (target) {\n        case UI_UPDATE_HOSTLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_host_list, NULL);\n            break;\n        case UI_UPDATE_PLUGINLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_plugin_list, NULL);\n            break;\n    }\n\n}", "extracted_prediction": "The `gtkui_update` function updates the user interface based on the `target` parameter. It uses a `switch` statement to determine which list to refresh: `UI_UPDATE_HOSTLIST` or `UI_UPDATE_PLUGINLIST`. For each case, it adds a `g_idle_add` call to a function that refreshes the respective list (`gtkui_refresh_host_list` or `gtkui_refresh_plugin_list`), passing `NULL` as the argument."}
{"index": 969, "input": "**User**: \nstatic void scoll_base_module_construct(mca_scoll_base_module_t *m)\n{\n    /* Collective function pointers */\n    m->scoll_barrier = NULL;\n    m->scoll_broadcast = NULL;\n    m->scoll_collect = NULL;\n    m->scoll_reduce = NULL;\n    m->scoll_alltoall = NULL;\n    m->scoll_module_enable = NULL;\n}", "extracted_prediction": "The function `scoll_base_module_construct` initializes a `mca_scoll_base_module_t` structure by setting its collective function pointers to `NULL`. This structure is intended to be used with the MCA (Message Passing Architecture) collective operations."}
{"index": 228, "input": "**User**: \nstatic void vmw_swap_notify(struct ttm_buffer_object *bo)\n{\n\tvmw_bo_swap_notify(bo);\n\t(void) ttm_bo_wait(bo, false, false);\n}", "extracted_prediction": "This function, `vmw_swap_notify`, calls `vmw_bo_swap_notify` on the provided `struct ttm_buffer_object *bo` pointer. Afterward, it waits for the buffer to be swapped out using `ttm_bo_wait`, with the parameters `false` for the first argument (indicating no timeout) and `false` for the second argument (indicating no blocking)."}
{"index": 337, "input": "**User**: \nstatic uint64_t cirrus_mmio_read(void *opaque, hwaddr addr,\n                                 unsigned size)\n{\n    CirrusVGAState *s = opaque;\n\n    if (addr >= 0x100) {\n        return cirrus_mmio_blt_read(s, addr - 0x100);\n    } else {\n        return cirrus_vga_ioport_read(s, addr + 0x10, size);\n    }\n}", "extracted_prediction": "This function reads data from the Cirrus MMIO space. It takes an opaque pointer, an address, and a size as parameters. If the address is within the 0x100 range, it calls the `cirrus_mmio_blt_read` function. Otherwise, it calls the `cirrus_vga_ioport_read` function."}
{"index": 362, "input": "**User**: \nlist_insert_nth(List *list, int pos, void *datum)\n{\n\tif (list == NIL)\n\t{\n\t\tAssert(pos == 0);\n\t\treturn list_make1(datum);\n\t}\n\tAssert(IsPointerList(list));\n\tlfirst(insert_new_cell(list, pos)) = datum;\n\tcheck_list_invariants(list);\n\treturn list;\n}", "extracted_prediction": "This function inserts a datum into a list at a specified position. If the list is empty, it creates a new list with the datum. Otherwise, it inserts the datum at the specified position and checks the list's invariants."}
{"index": 11, "input": "**User**: \nstatic enum ap_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_WAIT_NONE;\n}", "extracted_prediction": "This function, `ap_sm_nop`, returns `AP_WAIT_NONE` when called. It is a static function that is part of the `ap_queue` structure."}
{"index": 205, "input": "**User**: \nenumerator_t *enumerator_create_nested(enumerator_t *outer,\n\t\t\t\t\tenumerator_t *(inner_constructor)(void *outer, void *data),\n\t\t\t\t\tvoid *data, void (*destructor)(void *data))\n{\n\tnested_enumerator_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.enumerate = enumerator_enumerate_default,\n\t\t\t.venumerate = _enumerate_nested,\n\t\t\t.destroy = _destroy_nested,\n\t\t},\n\t\t.outer = outer,\n\t\t.create_inner = inner_constructor,\n\t\t.data = data,\n\t\t.destructor = destructor,\n\t);\n\treturn &this->public;\n}", "extracted_prediction": "This function creates a nested enumerator by initializing it with the provided parameters. It returns a pointer to the public section of the newly created enumerator."}
{"index": 694, "input": "**User**: \nstatic bool hasSpecifyDB(SSQLToken* pTableName) {\n  for (int32_t i = 0; i < pTableName->n; ++i) {\n    if (pTableName->z[i] == TS_PATH_DELIMITER[0]) {\n      return true;\n    }\n  }\n\n  return false;\n}", "extracted_prediction": "The function `hasSpecifyDB` checks if the provided `SSQLToken` pointer points to a table name that includes the path separator (`TS_PATH_DELIMITER[0]`). It iterates through the characters of the table name and returns `true` if it finds the path separator, indicating a database name. If no path separator is found, it returns `false`."}
{"index": 392, "input": "**User**: \nstatic void pcmuio_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\n\tchip->enabled_mask = 0;\n\tchip->active = 0;\n\ts->async->inttrig = NULL;\n\n\t/* disable all intrs for this subdev.. */\n\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\n}", "extracted_prediction": "This function stops an interrupt on a PCMUIO device by clearing the interrupt mask for the specified ASIC and disabling all interrupts for the subdevice."}
{"index": 194, "input": "**User**: \nstatic void fixup_unlock_powerup_lock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tif (cfip->FeatureSupport&32) {\n\t\tprintk(KERN_INFO \"Using auto-unlock on power-up/resume\\n\" );\n\t\tmtd->flags |= MTD_POWERUP_LOCK;\n\t}\n}", "extracted_prediction": "This function checks if the CFI (Calibration Firmware Interface) supports auto-unlock on power-up or resume. If it does, it sets the MTD_POWERUP_LOCK flag on the mtd_info structure to enable auto-unlocking."}
{"index": 300, "input": "**User**: \nint oshmem_info_finalize(void)\n{\n\n    /* All done -- destroy the table */\n\n    return OSHMEM_SUCCESS;\n}", "extracted_prediction": "The `oshmem_info_finalize` function completes its task by destroying the table it created. It returns `OSHMEM_SUCCESS` as a success indicator."}
{"index": 389, "input": "**User**: \nvoid ucg_ClearScreen(ucg_t *ucg)\n{\n  ucg_SetColor(ucg, 0, 0, 0, 0);\n  ucg_SetMaxClipRange(ucg);\n  ucg_DrawBox(ucg, 0, 0, ucg_GetWidth(ucg), ucg_GetHeight(ucg));\n  ucg_SetColor(ucg, 0, 255, 255, 255);\n}", "extracted_prediction": "This function clears the screen by setting the background color to black, setting the maximum clipping range, drawing a box around the entire screen, and setting the background color back to white."}
{"index": 257, "input": "**User**: \nreport_error_message(Step *step)\n{\n\tif (step->errormsg)\n\t{\n\t\tfprintf(stdout, \"%s\\n\", step->errormsg);\n\t\tfree(step->errormsg);\n\t\tstep->errormsg = NULL;\n\t}\n}", "extracted_prediction": "This function reports an error message if it exists. If an error message is present, it prints the message to standard output and then frees the memory associated with the error message, setting it to `NULL`."}
{"index": 318, "input": "**User**: \nstatic int eeprom_write_with_enable(struct qib_devdata *dd, u8 offset,\n\t\t     const void *buf, int len)\n{\n\tint ret, pwen;\n\n\tpwen = dd->f_eeprom_wen(dd, 1);\n\tret = qib_twsi_reset(dd);\n\tif (ret)\n\t\tqib_dev_err(dd, \"EEPROM Reset for write failed\\n\");\n\telse\n\t\tret = qib_twsi_blk_wr(dd, dd->twsi_eeprom_dev,\n\t\t\t\t      offset, buf, len);\n\tdd->f_eeprom_wen(dd, pwen);\n\treturn ret;\n}", "extracted_prediction": "This function writes data to an EEPROM memory location with an enable bit set. It first sets the enable bit, resets the EEPROM interface, writes the data to the specified offset, and then resets the enable bit. If the write operation fails, it logs an error."}
{"index": 459, "input": "**User**: \nstatic struct tcp_ulp_ops *tcp_ulp_find(const char *name)\n{\n\tstruct tcp_ulp_ops *e;\n\n\tlist_for_each_entry_rcu(e, &tcp_ulp_list, list) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}", "extracted_prediction": "This function searches for a TCP ULP operation named `name` in the `tcp_ulp_list` list. If found, it returns the corresponding pointer to the operation; otherwise, it returns `NULL`."}
{"index": 680, "input": "**User**: \nvoid libtpmtss_deinit(void)\n{\n\ttpm_tss_tss2_deinit();\n}", "extracted_prediction": "This function deinitializes the TPM TSS 2 component."}
{"index": 272, "input": "**User**: \nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}", "extracted_prediction": "This function checks if a btree node is the last record in its level. It returns 0 if the level is greater than 0, if the last record flag is not set, or if the sibling pointer is null. Otherwise, it returns 1 indicating that the node is the last record in its level."}
{"index": 519, "input": "**User**: \nxmlSecCryptoAppShutdown(void) {\n    if((xmlSecCryptoDLGetFunctions() == NULL) || (xmlSecCryptoDLGetFunctions()->cryptoAppShutdown == NULL)) {\n        xmlSecNotImplementedError(\"cryptoAppShutdown\");\n        return(-1);\n    }\n\n    return(xmlSecCryptoDLGetFunctions()->cryptoAppShutdown());\n}", "extracted_prediction": "This function checks if the `cryptoAppShutdown` function is available in the `xmlSecCryptoDLGetFunctions` structure. If not, it raises an error and returns -1. If the function is available, it calls it and returns its result."}
{"index": 414, "input": "**User**: \nvoid fsverity_cleanup_inode(struct inode *inode)\n{\n\tfsverity_free_info(inode->i_verity_info);\n\tinode->i_verity_info = NULL;\n}", "extracted_prediction": "This function cleans up the `inode` by freeing the allocated memory for the `i_verity_info` structure and setting `i_verity_info` to `NULL`."}
{"index": 193, "input": "**User**: \nint btrfs_bg_type_to_factor(u64 flags)\n{\n\tconst int index = btrfs_bg_flags_to_raid_index(flags);\n\n\treturn btrfs_raid_array[index].ncopies;\n}", "extracted_prediction": "This function converts a BTRFS background type flags value to the number of copies in the corresponding BTRFS RAID array."}
{"index": 537, "input": "**User**: \nstatic int dln2_spi_set_mode(struct dln2_spi *dln2, u8 mode)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 mode;\n\t} tx;\n\n\ttx.port = dln2->port;\n\ttx.mode = mode;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));\n}", "extracted_prediction": "This function sets the SPI mode for the DLN2 device by passing the port number and mode to the `dln2_transfer_tx` function. The `tx` structure contains the port and mode values. The function returns the result of the transfer."}
{"index": 122, "input": "**User**: \nskipbl(void)\n{\n\tint c;\n\n\tif( termch != 0 ){\n\t\tc = termch;\n\t\ttermch = 0;\n\t} else\n\t\tc = inchar();\n\twhile( c == ' ' || c == '\\t' )\n\t\tc = inchar();\n\treturn c;\n}", "extracted_prediction": "The `skipbl` function skips any whitespace characters (' ' or '\\t') from the input buffer `termch`. If `termch` is not empty, it stores the character in `c` and then sets `termch` to 0. If `termch` is empty, it reads the next character from the input buffer and continues to do so until a non-whitespace character is encountered. The function returns the character that was read."}
{"index": 81, "input": "**User**: \nstatic void kbd_bh(unsigned long dummy)\n{\n\tunsigned int leds;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&led_lock, flags);\n\tleds = getleds();\n\tleds |= (unsigned int)kbd->lockstate << 8;\n\tspin_unlock_irqrestore(&led_lock, flags);\n\n\tif (leds != ledstate) {\n\t\tkbd_propagate_led_state(ledstate, leds);\n\t\tledstate = leds;\n\t}\n}", "extracted_prediction": "This function updates the LED state based on the keyboard's lock state. It first acquires an interrupt-lock to prevent other processes from modifying the LEDs while it does so. It retrieves the current LED state and sets it to include the keyboard's lock state. If the new state differs from the current state, it updates the state and notifies other processes of the change."}
{"index": 31, "input": "**User**: \nstatic inline int16_t *scalarproduct(const int16_t *in, const int16_t *endin, int16_t *out)\n{\n    int32_t sample;\n    int16_t j;\n\n    while (in < endin) {\n        sample = 0;\n        for (j = 0; j < NUMTAPS; j++)\n            sample += in[j] * filt[j];\n        *out = av_clip_int16(sample >> 6);\n        out++;\n        in++;\n    }\n\n    return out;\n}", "extracted_prediction": "This function performs a scalar product on a set of samples using a filter. It iterates through each sample, multiplying it by the corresponding filter coefficient and accumulating the results. The final result is clipped and stored in the output array. The function returns the pointer to the output array."}
{"index": 366, "input": "**User**: \nstatic inline void lru_add(struct ashmem_range *range)\n{\n\tlist_add_tail(&range->lru, &ashmem_lru_list);\n\tlru_count += range_size(range);\n}", "extracted_prediction": "This function, `lru_add`, adds a `struct ashmem_range` object to the LRU (Least Recently Used) list in the `ashmem_lru_list` list. It also increments the `lru_count` by the size of the `range`."}
{"index": 17, "input": "**User**: \nstatic int query(const mca_base_component_t *component,\n                 ompi_op_t *op,\n                 int *priority, ompi_op_base_module_1_0_0_t **module)\n{\n    *module = NULL;\n    if (1 == component->mca_type_major_version &&\n        0 == component->mca_type_minor_version &&\n        0 == component->mca_type_release_version) {\n        const ompi_op_base_component_1_0_0_t *op100 =\n            (ompi_op_base_component_1_0_0_t *) component;\n\n        return query_1_0_0(op100, op, priority, module);\n    }\n\n    /* Unknown op API version -- return error */\n\n    return OMPI_ERROR;\n}", "extracted_prediction": "This function `query` checks if the `component` is a MCA component with version 1.0.0. If it is, it calls `query_1_0_0` to process the operation. If not, it returns an error."}
{"index": 27, "input": "**User**: \nstatic int Control( stream_t *p_access, int i_query, va_list args )\n{\n    switch( i_query )\n    {\n        case STREAM_CAN_SEEK:\n        case STREAM_CAN_FASTSEEK:\n        case STREAM_CAN_PAUSE:\n        case STREAM_CAN_CONTROL_PACE:\n            *va_arg( args, bool * ) = false;\n            break;\n\n        case STREAM_GET_PTS_DELAY:\n            *va_arg( args, vlc_tick_t * ) =\n                VLC_TICK_FROM_MS(var_InheritInteger( p_access, \"network-caching\" ));\n            break;\n\n        default:\n            return VLC_EGENERIC;\n    }\n\n    return VLC_SUCCESS;\n}", "extracted_prediction": "The `Control` function checks the type of the `i_query` parameter and sets the corresponding value in `*va_arg(args, bool *)` to `false`. If `i_query` is `STREAM_GET_PTS_DELAY`, it calculates the PTS delay from the `network-caching` value and stores it in `*va_arg(args, vlc_tick_t *)`. If the `i_query` is not one of the specified cases, it returns `VLC_EGENERIC`."}
{"index": 574, "input": "**User**: \npublic_key_t *botan_ed_public_key_adopt(botan_pubkey_t key)\n{\n\tprivate_public_key_t *this;\n\n\tthis = create_empty();\n\tthis->key = key;\n\n\treturn &this->public;\n}", "extracted_prediction": "This function takes a `botan_pubkey_t` object and creates a new `private_public_key_t` object, setting its `key` to the provided `botan_pubkey_t` object. The function then returns a pointer to the `public` field of the newly created `private_public_key_t` object."}
{"index": 618, "input": "**User**: \nINTEGER_print(const asn_TYPE_descriptor_t *td, const void *sptr, int ilevel,\n              asn_app_consume_bytes_f *cb, void *app_key) {\n    const INTEGER_t *st = (const INTEGER_t *)sptr;\n\tssize_t ret;\n\n\t(void)ilevel;\n\n\tif(!st || !st->buf)\n\t\tret = cb(\"<absent>\", 8, app_key);\n\telse\n\t\tret = INTEGER__dump(td, st, cb, app_key, 0);\n\n\treturn (ret < 0) ? -1 : 0;\n}", "extracted_prediction": "This function, `INTEGER_print`, takes a `const asn_TYPE_descriptor_t *td`, a pointer to a `const INTEGER_t *st`, an `ilevel` parameter, a `asn_app_consume_bytes_f *cb`, and a `void *app_key`. It prints the integer value pointed to by `st` using the `td` descriptor, consuming the specified number of bytes (`ilevel`), and returns an error code if the print operation fails. If the integer is absent or the buffer is empty, it returns an error code for \"<absent>\". Otherwise, it calls `INTEGER__dump` to print the integer value."}
{"index": 10, "input": "**User**: \nstatic void IoTHubTransportMqtt_Unsubscribe_DeviceMethod(IOTHUB_DEVICE_HANDLE handle)\n{\n    IoTHubTransport_MQTT_Common_Unsubscribe_DeviceMethod(handle);\n}", "extracted_prediction": "The `IoTHubTransportMqtt_Unsubscribe_DeviceMethod` function is a helper function that calls the `IoTHubTransport_MQTT_Common_Unsubscribe_DeviceMethod` function to unsubscribe a device from a MQTT topic."}
