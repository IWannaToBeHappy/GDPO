{"index": 275, "input": "**User**: \nscroll_up_dashboard (void)\n{\n  gscroll.dash--;\n}", "extracted_prediction": "<answer>\nThis code defines a function `scroll_up_dashboard` that does nothing (void) but decrements the value of the global `gscroll.dash` variable. It likely controls a dashboard's upward scroll behavior by adjusting a scroll position counter.\n</answer>"}
{"index": 542, "input": "**User**: \nvoid Chip_ACMP_SetHysteresis(LPC_CMP_T *pACMP, ACMP_HYS_T hys)\n{\n\tuint32_t reg = pACMP->CTRL & ~(ACMP_HYSTERESIS_MASK | ACMP_CTRL_RESERVED);\n\n\t/* Select negative input */\n\tpACMP->CTRL = reg | (uint32_t) hys;\n}", "extracted_prediction": "<answer>\nThis function modifies the ACMP control register (`pACMP->CTRL`) to enable or disable the negative input based on the `ACMP_HYS_T` (hysteresis) configuration.  \n\n- **Step 1**: Clears the `ACMP_HYS_MASK` and `ACMP_CTRL_RESERVED` bits from `pACMP->CTRL`, removing any existing hysteresis-related settings.  \n- **Step 2**: Sets the negative input by OR-ing the cleared value with the `hys` (hysteresis) value, storing the result back in `pACMP->CTRL`.  \n\nThe goal is to configure the ACMP controller to use hysteresis-based negative input, where the input remains low for a specified duration (controlled by `ACMP_HYSTERESIS_MASK`) before transitioning to high.\n</answer>"}
{"index": 537, "input": "**User**: \nstatic int dln2_spi_set_mode(struct dln2_spi *dln2, u8 mode)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 mode;\n\t} tx;\n\n\ttx.port = dln2->port;\n\ttx.mode = mode;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));\n}", "extracted_prediction": "<answer>\nThis function `dln2_spi_set_mode` configures the SPI mode for a Dln2 device. It takes a Dln2 SPI handle (`dln2`) and a mode parameter (`u8 mode`). It packs the device's current port (`dln2->port`) and the new mode into a transfer structure (`tx`), then uses `dln2_transfer_tx` to send this configuration over the PVSI (Parallel Video System Interface) bus. The function returns the result of the transfer operation.\n</answer>"}
{"index": 954, "input": "**User**: \ndo_panel_cd (WPanel * panel, const vfs_path_t * new_dir_vpath, enum cd_enum cd_type)\n{\n    gboolean r;\n\n    r = _do_panel_cd (panel, new_dir_vpath, cd_type);\n    if (r)\n        directory_history_add (panel, panel->cwd_vpath);\n    return r;\n}", "extracted_prediction": "<answer>\nThe `do_panel_cd` function checks if a panel's directory history can be updated by `_do_panel_cd` with the given path and type. If successful, it adds the panel's current working directory to its history via `directory_history_add`. It returns the result of this operation.\n</answer>"}
{"index": 245, "input": "**User**: \nstatic KMETHOD KvirNodeGetCellsFreeMemory(KonohaContext *kctx,  KonohaStack *sfp)\n{\n\tvirConnectPtr arg0 = To_virConnectPtr(sfp[0]);\n\tunsigned_long_long_Ptr arg1 = To_unsigned_long_long_Ptr(sfp[1]);\n\tint arg2 = To_int(sfp[2]);\n\tint arg3 = To_int(sfp[3]);\n\tint ret = virNodeGetCellsFreeMemory (arg0, arg1, arg2, arg3);\n\tRETURNint(ret);\n}", "extracted_prediction": "<answer>\nThis function retrieves free memory cells using the `virNodeGetCellsFreeMemory` system call. It takes two parameters (`KonohaContext *kctx` and `KonohaStack *sfp`), extracts specific values from them (via `To_virConnectPtr`, `To_unsigned_long_long_Ptr`, and `To_int`), calls the system function with these parameters, and returns the result as an integer (`RETINT`).\n</answer>"}
{"index": 555, "input": "**User**: \nlibvlc_audio_get_track_description( libvlc_media_player_t *p_mi )\n{\n    return libvlc_get_track_description( p_mi, AUDIO_ES );\n}", "extracted_prediction": "<answer>\nThis function retrieves the track description for audio tracks by calling `libvlc_get_track_description` with the media player's audio filter (`AUDIO_ES`), returning the result of that function call. It likely fetches metadata about the audio track linked to the media player instance (`p_mi`).\n</answer>"}
{"index": 654, "input": "**User**: \nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv)\n{\n\tstruct mii_bus **ptr, *bus;\n\n\tptr = devres_alloc(_devm_mdiobus_free, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\t/* use raw alloc_dr for kmalloc caller tracing */\n\tbus = mdiobus_alloc_size(sizeof_priv);\n\tif (bus) {\n\t\t*ptr = bus;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn bus;\n}", "extracted_prediction": "<answer>\nThis function allocates memory for a private field within a MII (Memory Interface Bus) structure associated with a device. It uses the device-mapped memory subsystem (`devres_*` macros) to manage allocation and freeing. \n\n- **Parameters**: `dev` (device structure), `sizeof_priv` (size of the private data field in the MII bus).  \n- **Process**:  \n  1. Allocates a function pointer to `devm_mdiobus_free` (a free function from the device-mapped memory subsystem) to track the allocated bus structure.  \n  2. Calls `mdiobus_alloc_size` to allocate memory for the private field.  \n  3. If allocation succeeds, stores the bus structure and adds it to the device’s resource list (`devres_add`).  \n  4. If allocation fails, frees the previously allocated bus structure.  \n- **Return**: The allocated bus structure on success; `NULL` otherwise.  \n\n**Summary**: A helper function to allocate memory for a private field in a MII bus structure, leveraging device-mapped memory for safe allocation and cleanup.\n</answer>"}
{"index": 278, "input": "**User**: \nstatic u_char read_byte(chunk_t *blob)\n{\n\tu_char val;\n\n\tif (blob->len < sizeof(u_char))\n\t{\n\t\treturn 0;\n\t}\n\tval = *(blob->ptr);\n\t*blob = chunk_skip(*blob, sizeof(u_char));\n\treturn val;\n}", "extracted_prediction": "<answer>\nThis function reads a single byte from a chunk structure. It first checks if the chunk has sufficient memory to hold at least one `u_char` byte; if not, it returns 0. Otherwise, it reads the first byte from the chunk, skips the next byte using `chunk_skip`, and returns the read value.\n</answer>"}
{"index": 371, "input": "**User**: \nint __drm_set_edid_firmware_path(const char *path)\n{\n\tscnprintf(edid_firmware, sizeof(edid_firmware), \"%s\", path);\n\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThe function `__drm_set_edid_firmware_path` takes a `const char*` parameter `path`, which is the path to the firmware file. It uses `scnprintf` to format the `path` string into an array `edid_firmware` of fixed size, then returns 0 (likely indicating success).\n</answer>"}
{"index": 694, "input": "**User**: \nstatic bool hasSpecifyDB(SSQLToken* pTableName) {\n  for (int32_t i = 0; i < pTableName->n; ++i) {\n    if (pTableName->z[i] == TS_PATH_DELIMITER[0]) {\n      return true;\n    }\n  }\n\n  return false;\n}", "extracted_prediction": "<answer>\n\nThis function `hasSpecifyDB` checks if the first character of a given SQL Server table name string (`pTableName`) matches the delimiter character defined by `TS_PATH_DELIMITER[0]`. It iterates through each character of the table name string and returns `true` immediately if the delimiter is found; otherwise, it returns `false` after checking all characters.\n</answer>"}
{"index": 8, "input": "**User**: \nstatic int ni65_open(struct net_device *dev)\n{\n\tstruct priv *p = dev->ml_priv;\n\tint irqval = request_irq(dev->irq, ni65_interrupt,0,\n                        cards[p->cardno].cardname,dev);\n\tif (irqval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d (irqval=%d).\\n\",\n\t\t          dev->name,dev->irq, irqval);\n\t\treturn -EAGAIN;\n\t}\n\n\tif(ni65_lance_reinit(dev))\n\t{\n\t\tnetif_start_queue(dev);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfree_irq(dev->irq,dev);\n\t\treturn -EAGAIN;\n\t}\n}", "extracted_prediction": "<answer>\nThe `ni65_open` function handles opening the ni65 network device in the Linux kernel. It first attempts to request an interrupt for the device using `request_irq`. If the interrupt cannot be requested (returns `-EAGAIN`), it logs an error and exits. If successful, it checks if the device needs reinitialization (`ni65_lance_reinit`). If not, it frees the allocated IRQ and exits. If reinitialization is required, it starts a netif queue. The summary captures the interrupt request, failure handling, reinitialization check, and IRQ cleanup logic.\n</answer>"}
{"index": 153, "input": "**User**: \ncredential_factory_t *credential_factory_create()\n{\n\tprivate_credential_factory_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.create = _create,\n\t\t\t.create_builder_enumerator = _create_builder_enumerator,\n\t\t\t.add_builder = _add_builder,\n\t\t\t.remove_builder = _remove_builder,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.constructors = linked_list_create(),\n\t\t.recursive = thread_value_create(NULL),\n\t\t.lock = rwlock_create(RWLOCK_TYPE_DEFAULT),\n\t);\n\n\treturn &this->public;\n}", "extracted_prediction": "<answer>\nThis function `credential_factory_create()` initializes and returns a new `credential_factory_t` object. It configures the object by setting up initialization logic (e.g., creating builder enumerators, managing builders via `add_builder`/`remove_builder`), linking constructors to a linked list, enabling recursion, and initializing a mutex (`rwlock`) for thread safety. The returned pointer points to the newly constructed object.\n</answer>"}
{"index": 162, "input": "**User**: \nvoid  OS_EventWaitListInit (OS_EVENT *pevent)\n{\n    INT8U  i;\n\n\n    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */\n    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {\n        pevent->OSEventTbl[i] = 0u;\n    }\n}", "extracted_prediction": "<answer>\nThis function initializes the event wait list structure (`OS_EVENT` pointer). It sets the event group index to `0u` (indicating no task waiting on events) and clears all entries in the event table (`OSEventTbl`) within the specified size (`OS_EVENT_TBL_SIZE`).\n</answer>"}
{"index": 369, "input": "**User**: \nstatic unsigned ODDescriptorLength( unsigned *pi_data, const uint8_t **pp_data )\n{\n    unsigned int i_b;\n    unsigned int i_len = 0;\n\n    if(*pi_data == 0)\n        return 0;\n\n    do\n    {\n        i_b = **pp_data;\n        (*pp_data)++;\n        (*pi_data)--;\n        i_len = ( i_len << 7 ) + ( i_b&0x7f );\n\n    } while( i_b&0x80 && *pi_data > 0 );\n\n    if (i_len > *pi_data)\n        i_len = *pi_data;\n\n    return i_len;\n}", "extracted_prediction": "<answer>\n\nThe `ODDescriptorLength` function calculates the length of a sequence of data elements, where each element contributes 7 bits to the total length. Here's a breakdown:\n\n### Key Details:\n1. **Initial Check**: If the starting data pointer (`*pi_data`) is `NULL`, it returns `0` immediately.\n2. **Accumulating Length**: Uses a loop to iterate through consecutive data elements. For each element:\n   - Extracts the 7-bit value (`i_b`) of the current element.\n   - Shifts accumulated length left by 7 bits and adds the 7-bit value of `i_b`.\n3. **Loop Termination**: Stops when:\n   - The current element’s lower 7 bits (`i_b & 0x80`) are `0` (no more significant bits to add).\n   - The previous data pointer (`*pi_data`) is `NULL` (end of the sequence).\n4. **Capping Length**: Ensures the final length does not exceed the number of remaining elements by comparing `i_len` with `*pi_data`.\n5. **Return Value**: Returns the total length (in bits) of the sequence.\n\n**In summary**: This function computes the total bit-length of a contiguous data block, where each element contributes 7 bits, and stops when the block ends or when the next element’s significant bits are exhausted.\n</answer>"}
{"index": 11, "input": "**User**: \nstatic enum ap_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_WAIT_NONE;\n}", "extracted_prediction": "<answer>\nThis code defines a static enum value `ap_sm_nop` (likely representing \"No Operation\" or \"Skipped\") within the `ap_wait` enum type. It is used by the `ap_queue` structure (`struct ap_queue *aq`) to indicate that no wait condition is required, returning the constant `AP_WAIT_NONE`.\n</answer>"}
{"index": 28, "input": "**User**: \nstatic int amd76x_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t/* don't need to call pci_enable_device() */\n\treturn amd76x_probe1(pdev, ent->driver_data);\n}", "extracted_prediction": "<answer>\nThis is a driver initialization function for the AMD 76X hardware. It logs a newline using EdacDB, skips calling `pci_enable_device()`, and registers the driver with the provided PCI device ID (`ent->driver_data`). The return value is the result of `pci_register_driver()`.\n</answer>"}
{"index": 997, "input": "**User**: \nevutil_gettime_monotonic(struct evutil_monotonic_timer *timer,\n                         struct timeval *tp)\n{\n  return evutil_gettime_monotonic_(timer, tp);\n}", "extracted_prediction": "<answer>\nThe `evutil_gettime_monotonic` function retrieves the current monotonic time from a given monotonic timer structure (`struct evutil_monotonic_timer`), using a time value (`struct timeval`) to specify the time origin. It returns the current time as a monotonic value, unaffected by system clock adjustments, making it suitable for measuring intervals between events.\n</answer>"}
{"index": 58, "input": "**User**: \nstatic int is_number(const char* s) {\n  size_t i;\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\n  return 1;\n}", "extracted_prediction": "<answer>\nThe `is_number` function checks if a string `s` contains only numeric characters (digits '0'-'9'). It returns `1` (true) if all characters in `s` are digits, and `0` (false) otherwise. The check uses `strchr` to verify each character against the numeric digit set.\n</answer>"}
{"index": 295, "input": "**User**: \nstatic void _sba_process_pending_requests(struct sba_device *sba)\n{\n\tint ret;\n\tu32 count;\n\tstruct sba_request *req;\n\n\t/* Process few pending requests */\n\tcount = SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL;\n\twhile (!list_empty(&sba->reqs_pending_list) && count) {\n\t\t/* Get the first pending request */\n\t\treq = list_first_entry(&sba->reqs_pending_list,\n\t\t\t\t       struct sba_request, node);\n\n\t\t/* Try to make request active */\n\t\tif (!_sba_active_request(sba, req))\n\t\t\tbreak;\n\n\t\t/* Send request to mailbox channel */\n\t\tret = sba_send_mbox_request(sba, req);\n\t\tif (ret < 0) {\n\t\t\t_sba_pending_request(sba, req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount--;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `_sba_process_pending_requests` iterates through pending SBA (System Block Architecture) requests stored in `sba->reqs_pending_list`. For each unprocessed request, it checks if the request is still active using `_sba_active_request`. If active, it sends the request to the mailbox via `sba_send_mbox_request`. If sending fails, it logs the failure and stops processing further requests. The loop terminates when all pending requests are processed or no more active requests remain.\n</answer>"}
{"index": 683, "input": "**User**: \nstatic int unicodeDestroy(sqlite3_tokenizer *pTokenizer){\n  if( pTokenizer ){\n    unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;\n    sqlite3_free(p->aiException);\n    sqlite3_free(p);\n  }\n  return SQLITE_OK;\n}", "extracted_prediction": "<answer>\nThis function `unicodeDestroy` safely deallocates a SQLite tokenizer object by freeing its associated exception (`aiException`) and the object itself, returning `SQLITE_OK` to indicate success.\n</answer>"}
{"index": 577, "input": "**User**: \nstatic struct lvname *alloc_lvn(struct parsed_partitions *state, u32 lba)\n{\n\tsize_t count = sizeof(struct lvname) * LVM_MAXLVS;\n\tstruct lvname *p;\n\n\tp = kmalloc(count, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) p, count) < count) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}", "extracted_prediction": "<answer>\nThis function allocates memory for a `struct lvname` (a structure representing an LVM volume name) within the Linux kernel's memory management framework. Here's a breakdown:\n\n### Key Details:\n- **Purpose**: Allocates a buffer to store metadata about an LVM volume, including its name, starting LBA address, and size.\n- **Parameters**:\n  - `state`: Pointer to a `parsed_partitions` structure containing partition metadata.\n  - `lba`: The LVM block number (address) where the volume metadata resides.\n- **Steps**:\n  1. Calculate the total size needed for the `struct lvname` buffer: `sizeof(struct lvname) * LVM_MAXLVS` (accounts for all possible LVM levels).\n  2. Allocate memory using `kmalloc` (kernel-managed memory allocation). Fails if memory is unavailable.\n  3. Verify the metadata (via `read_lba`) from the specified LVM block (`lba`) into the allocated buffer. This ensures the metadata matches the actual LVM volume data at the given address.\n  4. If verification succeeds, return the allocated buffer; otherwise, free memory and return `NULL`.\n\n### Summary:\nThis function safely allocates and validates memory for LVM volume metadata, ensuring the metadata is correctly placed in the LVM block at the specified address before returning it.\n</answer>"}
{"index": 258, "input": "**User**: \nstatic int vfio_virt_config_write(struct vfio_pci_device *vdev, int pos,\n\t\t\t\t  int count, struct perm_bits *perm,\n\t\t\t\t  int offset, __le32 val)\n{\n\tmemcpy(vdev->vconfig + pos, &val, count);\n\treturn count;\n}", "extracted_prediction": "<answer>\nThis function `vfio_virt_config_write` is a helper that writes a pre-configured integer array (`val`) into the vconfig region of a VFIO device structure (`vdev`). It copies `count` elements from `val` to the vconfig memory starting at offset `pos`, then returns the number of elements copied.\n</answer>"}
{"index": 965, "input": "**User**: \nint acpi_bus_register_driver(struct acpi_driver *driver)\n{\n\tint ret;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\tdriver->drv.name = driver->name;\n\tdriver->drv.bus = &acpi_bus_type;\n\tdriver->drv.owner = driver->owner;\n\n\tret = driver_register(&driver->drv);\n\treturn ret;\n}", "extracted_prediction": "<answer>\nThis function `acpi_bus_register_driver` initializes and registers a driver for ACPI bus communication. It first checks if ACPI is disabled; if so, returns `-ENODEV` (invalid operation). Otherwise, it configures the driver by setting its name, bus type, and owner, then calls `driver_register` to register the driver structure, returning the operation result.\n</answer>"}
{"index": 833, "input": "**User**: \nunsigned long long kbuffer_timestamp(struct kbuffer *kbuf)\n{\n\treturn kbuf->timestamp;\n}", "extracted_prediction": "<answer>\nThis function `kbuffer_timestamp` retrieves the timestamp value stored in the `timestamp` member of a `kbuffer` structure, provided via a pointer to the `kbuffer` object. It returns the timestamp as a 64-bit unsigned integer (`unsigned long long`).\n</answer>"}
{"index": 306, "input": "**User**: \nstatic bool create_aead(private_tls_crypto_t *this, suite_algs_t *algs)\n{\n\tthis->aead_in = tls_aead_create_aead(algs->encr, algs->encr_size);\n\tthis->aead_out = tls_aead_create_aead(algs->encr, algs->encr_size);\n\tif (!this->aead_in || !this->aead_out)\n\t{\n\t\tDBG1(DBG_TLS, \"selected TLS transforms %N-%u not supported\",\n\t\t\t encryption_algorithm_names, algs->encr, algs->encr_size * 8);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "extracted_prediction": "<answer>\nThis function creates two AAD (Authentication Data Authenticated Encryption) streams (`aead_in` and `aead_out`) using the TLS AAD authentication encryption algorithm. It validates that both streams are successfully initialized (non-null) and logs an error if either is invalid. Returns `true` on success, `false` otherwise.\n</answer>"}
{"index": 894, "input": "**User**: \ncalculate_column_width(view_t *view)\n{\n\tconst int column_gap = (cfg.extra_padding ? 2 : 1);\n\tif(view->max_filename_width == 0)\n\t{\n\t\tview->max_filename_width = get_max_filename_width(view);\n\t}\n\treturn MIN(view->max_filename_width + column_gap,\n\t           (size_t)ui_view_available_width(view));\n}", "extracted_prediction": "<answer>\nThis function calculates the maximum width for a column in a UI view, considering filename display width and internal view constraints. It initializes a column gap (2 if `extra_padding` is enabled, otherwise 1). If `view->max_filename_width` is not initialized, it retrieves it using `get_max_filename_width(view)`. The final width is the lesser of the sum of filename width and gap, or the available view width, ensuring no overflow.\n</answer>"}
{"index": 119, "input": "**User**: \nnextPowerOfTwo(int x)\n{\n    int val = 1;\n    while (val < x) {\n        val *= 2;\n    }\n    return val;\n}", "extracted_prediction": "<answer>\nThe `nextPowerOfTwo` function calculates the smallest power of two that is strictly greater than the input integer `x`. It initializes a variable `val` to 1 and repeatedly doubles `val` in a loop until `val` is no longer less than `x`. The final value of `val` is returned as the result.\n</answer>"}
{"index": 380, "input": "**User**: \nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}", "extracted_prediction": "<answer>\nThe `ext4_journalled_invalidatepage` function is a kernel function that calls `__ext4_journalled_invalidatepage` to invalidate data within an ext4 filesystem page. It takes a `struct page*` (pointer to the filesystem page), an `offset` (starting position on the page), and a `length` (number of bytes to invalidate). If the return value of `__ext4_journalled_invalidatepage` is negative, it triggers a warning via `WARN_ON`.\n</answer>"}
{"index": 72, "input": "**User**: \nstatic double poly_basis_dy(ssize_t n, double x, double y)\n{\n  /* polynomial term for y derivative */\n  switch(n) {\n    case  0:  return( 0.0 ); /* constant */\n    case  1:  return( 0.0 );\n    case  2:  return( 1.0 ); /* affine      order = 1   terms = 3 */\n    case  3:  return(  x  ); /* bilinear    order = 1.5 terms = 4 */\n    case  4:  return( 0.0 );\n    case  5:  return(  y  ); /* quadratic   order = 2   terms = 6 */\n    default:  return( poly_basis_dx(n-1,x,y) ); /* weird but true */\n  }\n  /* NOTE: the only reason that last is not true for 'quadratic'\n     is due to the re-arrangement of terms to allow for 'bilinear'\n  */\n}", "extracted_prediction": "<answer>\nThis function `poly_basis_dy` computes a polynomial term in the variable `y` based on its degree `n`, evaluated at points `(x, y)`. It uses a switch-case structure to return predefined coefficients for specific degrees, with special handling for `n=3` (bilinear term) and a recursive fallback for `n>5`. Key details include:  \n- `n=0`: Constant term (0.0).  \n- `n=1`: No non-zero terms (0.0).  \n- `n=2`: Affine term (1.0, order 1, 3 terms).  \n- `n=3`: Bilinear term (`x`, order 1.5, 4 terms).  \n- `n=5`: Quadratic term (`y`, order 2, 6 terms).  \n- Default: Recursively calls `poly_basis_dx` for lower degrees.  \n\nThe quadratic term (`y`) is omitted from the return value for `n=2` due to term rearrangement logic.\n</answer>"}
{"index": 237, "input": "**User**: \nstatic char* CFArrayALPNCopyFirst(CFArrayRef alpnArray)\n{\n    CFIndex count = CFArrayGetCount(alpnArray);\n\n    if (count <= 0)\n        return NULL;\n\n    CFStringRef alpnVal = CFArrayGetValueAtIndex(alpnArray, 0);\n    return FromCFString(alpnVal, kCFStringEncodingASCII);\n}", "extracted_prediction": "<answer>\nThis function `CFArrayALPNCopyFirst` retrieves the first element of a given `CFArrayRef` (an array of CFTypeRef) and converts it to a `CString` using ASCII encoding. It first checks if the array is empty or null (returning `NULL` in such cases), then fetches the first element (index 0) via `CFArrayGetValueAtIndex`, and finally converts the retrieved `CFStringRef` to a `CString` using `FromCFString`. The result is returned as a `char*` pointer to the converted string.\n</answer>"}
{"index": 449, "input": "**User**: \nstatic grp_stack_item* grp_stack_append(\n  grp_stack_item* last, grp_stack_data data\n) {\n  /* first create a new stack item, and copy data to it */\n  grp_stack_item* new_item = (grp_stack_item*) malloc(sizeof(grp_stack_item));\n  new_item->data = data;\n  if(last) {\n    /* attach this item between the \"last\" item and its \"next\" item */\n    new_item->next = last->next;\n    new_item->prev = last;\n    last->next->prev = new_item;\n    last->next = new_item;\n  } else {\n    /* stack is empty, so \"next\" and \"previous\" both point back to it */\n    new_item->next = new_item;\n    new_item->prev = new_item;\n  }\n  return new_item;\n}", "extracted_prediction": "<answer>\nThis function `grp_stack_append` dynamically creates and appends a new stack item to an existing stack. It allocates memory for the new item, copies the provided data, and links it to the last item in the stack. If the stack is not empty, the new item is attached between the last item and its next item, updating pointers to maintain adjacency. If the stack is empty, the new item becomes the root of the stack.\n</answer>"}
{"index": 522, "input": "**User**: \nvoid sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  pParse->nErr++;\n  sqliteFree(pParse->zErrMsg);\n  va_start(ap, zFormat);\n  pParse->zErrMsg = sqlite3VMPrintf(zFormat, ap);\n  va_end(ap);\n}", "extracted_prediction": "<answer>\nThis function `sqlite3ErrorMsg` handles SQLite error message generation. It increments an error counter (`pParse->nErr`), frees the previously allocated error message string (`sqliteFree(pParse->zErrMsg)`), then prints a formatted error message using SQLite's `sqlite3VMPrintf` with the provided format string (`zFormat`) via the variable argument list (`va_start`, `va_end`). Finally, it frees the variable arguments after printing. The goal is to provide structured, user-friendly error messages based on the input format string while properly managing memory.\n</answer>"}
{"index": 751, "input": "**User**: \nstatic int unicodeClose(sqlite3_tokenizer_cursor *pCursor){\n  unicode_cursor *pCsr = (unicode_cursor *) pCursor;\n  sqlite3_free(pCsr->zToken);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}", "extracted_prediction": "<answer>\nThis function `unicodeClose` safely closes a SQLite tokenizer cursor by converting it to an `unicode_cursor`, freeing its token (`zToken`) and the cursor itself, then returning `SQLITE_OK` to indicate success.\n</answer>"}
{"index": 814, "input": "**User**: \nstatic int agent_thread_cmd_listen_reply(int fd,\n                                         uint32_t addr, int32_t udp_port)\n{\n    int ret;\n\n    opal_btl_usnic_connectivity_cmd_listen_reply_t cmd = {\n        .cmd = CONNECTIVITY_AGENT_CMD_LISTEN,\n        .ipv4_addr = addr,\n        .udp_port = udp_port\n    };\n\n    ret = opal_fd_write(fd, sizeof(cmd), &cmd);\n    if (OPAL_SUCCESS != ret) {\n        OPAL_ERROR_LOG(ret);\n        ABORT(\"usnic connectivity agent IPC write failed\");\n        /* Will not return */\n    }\n\n    return OPAL_SUCCESS;\n}", "extracted_prediction": "<answer>\nThis function `agent_thread_cmd_listen_reply` initializes a connectivity command structure (`opal_btl_usnic_connectivity_cmd_listen_reply_t`) with specified IP address (`addr`), UDP port (`udp_port`), and a connection type (`CONNECTIVITY_AGENT_CMD_LISTEN`). It writes this structure to a file descriptor (`fd`), checks for write success, logs errors on failure, and returns `OPAL_SUCCESS` (or 0) if successful.\n</answer>"}
{"index": 298, "input": "**User**: \npb_tnc_msg_t* pb_remediation_parameters_msg_create_from_uri(chunk_t uri)\n{\n\tpen_type_t type = { PEN_IETF, PB_REMEDIATION_URI };\n\n\treturn pb_remediation_parameters_msg_create(type, uri);\n}", "extracted_prediction": "<answer>\nThis function creates a message object (`pb_remediation_parameters_msg_t`) from a given URI, using the Internet Protocol type (`PEN_IETF`) and the specified URI (`PB_REMEDIATION_URI`). It returns a pointer to the newly created message.\n</answer>"}
{"index": 482, "input": "**User**: \nstatic void Efuse_ReadAllMap(struct adapter *pAdapter, u8 efuseType, u8 *Efuse)\n{\n\tefuse_power_switch(pAdapter, false, true);\n\n\tefuse_ReadEFuse(pAdapter, efuseType, 0, EFUSE_MAP_LEN_88E, Efuse);\n\n\tefuse_power_switch(pAdapter, false, false);\n}", "extracted_prediction": "<answer>\nThis function toggles the power switch state of the adapter, reads the EFUSE map entry (for the specified `efuseType`), and resets the power switch to its initial state. It uses `efuse_power_switch` to toggle the switch and `efuse_ReadEFuse` to retrieve the map data.\n</answer>"}
{"index": 98, "input": "**User**: \nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\n{\n\tif (!vha->vha_tgt.qla_tgt)\n\t\treturn 0;\n\n\tif (vha->fc_vport) {\n\t\tqlt_release(vha->vha_tgt.qla_tgt);\n\t\treturn 0;\n\t}\n\n\t/* free left over qfull cmds */\n\tqlt_init_term_exchange(vha);\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe03c, \"Unregistering target for host %ld(%p)\",\n\t    vha->host_no, ha);\n\tqlt_release(vha->vha_tgt.qla_tgt);\n\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThe `qlt_remove_target` function unregisters a target associated with an SCIQLA_Host structure. It first checks if the target is null; if so, returns 0. If the host has a FC_VPORT, it releases any leftover commands and exits. Otherwise, it initializes a term exchange mechanism and uses `ql932g` to unregister the target with parameters including the host identifier and target address. Finally, it releases the target resource and returns 0.\n</answer>"}
{"index": 487, "input": "**User**: \nstatic void sbz_gpio_shutdown_commands(struct hda_codec *codec, int dir,\n\t\t\t\t\t\t\tint mask, int data)\n{\n\tif (dir >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DIRECTION, dir);\n\tif (mask >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_MASK, mask);\n\n\tif (data >= 0)\n\t\tsnd_hda_codec_write(codec, 0x01, 0,\n\t\t\t\tAC_VERB_SET_GPIO_DATA, data);\n}", "extracted_prediction": "<answer>\nThis function `sbz_gpio_shutdown_commands` shuts down a codec by writing to GPIO registers based on non-negative flags. It checks if `dir`, `mask`, or `data` are non-negative, then uses `snd_hda_codec_write` to set specific GPIO registers:  \n- `dir`: GPIO direction register (via `AC_VERB_SET_GPIO_DIRECTION`).  \n- `mask`: GPIO mask register (via `AC_VERB_SET_GPIO_MASK`).  \n- `data`: GPIO data register (via `AC_VERB_SET_GPIO_DATA`).  \n\nEach write operation likely configures the GPIO to disable the codec's functionality.\n</answer>"}
{"index": 519, "input": "**User**: \nxmlSecCryptoAppShutdown(void) {\n    if((xmlSecCryptoDLGetFunctions() == NULL) || (xmlSecCryptoDLGetFunctions()->cryptoAppShutdown == NULL)) {\n        xmlSecNotImplementedError(\"cryptoAppShutdown\");\n        return(-1);\n    }\n\n    return(xmlSecCryptoDLGetFunctions()->cryptoAppShutdown());\n}", "extracted_prediction": "<answer>\nThis function `xmlSecCryptoAppShutdown` checks if the required cryptographic functions (`xmlSecCryptoDLGetFunctions`) and their `cryptoAppShutdown` member are available. If not, it returns an `xmlSecNotImplementedError` with the message \"cryptoAppShutdown\". If valid, it invokes the `cryptoAppShutdown` method from the function's returned object and returns its result.\n</answer>"}
{"index": 823, "input": "**User**: \nu32 sqlite3ExprListFlags(const ExprList *pList){\n  int i;\n  u32 m = 0;\n  assert( pList!=0 );\n  for(i=0; i<pList->nExpr; i++){\n     Expr *pExpr = pList->a[i].pExpr;\n     assert( pExpr!=0 );\n     m |= pExpr->flags;\n  }\n  return m;\n}", "extracted_prediction": "<answer>\nThis function computes a 32-bit bitmask (`m`) representing the combined flags of all SQLite expressions in the provided `ExprList`. It iterates through each expression in the list, extracts its individual flags using the `pExpr->flags` member, and accumulates these flags via bitwise OR. The final bitmask is returned, indicating which SQLite expression features are enabled.\n</answer>"}
{"index": 401, "input": "**User**: \nstatic av_always_inline void decode_cabac_residual_dc(const H264Context *h,\n                                                      H264SliceContext *sl,\n                                                      int16_t *block,\n                                                      int cat, int n,\n                                                      const uint8_t *scantable,\n                                                      int max_coeff)\n{\n    /* read coded block flag */\n    if( get_cabac( &sl->cabac, &sl->cabac_state[get_cabac_cbf_ctx(sl, cat, n, max_coeff, 1)]) == 0 ) {\n        sl->non_zero_count_cache[scan8[n]] = 0;\n        return;\n    }\n    decode_cabac_residual_dc_internal(h, sl, block, cat, n, scantable, max_coeff);\n}", "extracted_prediction": "<answer>\nThis function `decode_cabac_residual_dc` decodes the residual DC block of a CABAC-encoded image. It first verifies the validity of the CABAC state using `get_cabac`, skipping processing if invalid. If valid, it calls an internal helper function `decode_cabac_residual_dc_internal` to decode the residual DC block, passing through the input context (`H264Context`), slice context (`H264SliceContext`), block buffer, CABAC parameters, and the encoding/scan8 table.\n</answer>"}
{"index": 748, "input": "**User**: \nVOID AsicSetStreamMode(\n\tIN RTMP_ADAPTER *pAd,\n\tIN PUCHAR pMacAddr,\n\tIN INT chainIdx,\n\tIN BOOLEAN bEnabled)\n{\n#ifdef MT_MAC\n\n\tif (IS_HIF_TYPE(pAd, HIF_MT)) {\n\t\tMtAsicSetStreamMode(pAd, pMacAddr, chainIdx, bEnabled);\n\t\treturn;\n\t}\n\n#endif\n\tAsicNotSupportFunc(pAd, __func__);\n}", "extracted_prediction": "<answer>\nThis VB function `AsicSetStreamMode` handles setting the RTMP stream mode based on the adapter's MAC address. It checks if the MAC address is in \"MT\" type (via `IS_HIF_TYPE`) and calls `MtAsicSetStreamMode` if true. If not, it invokes `AsicNotSupportFunc`. The function takes an RTMP adapter pointer (`pAd`), a MAC address (`pMacAddr`), a chain index (`chainIdx`), and a flag indicating if the operation is enabled (`bEnabled`).\n</answer>"}
{"index": 430, "input": "**User**: \nstatic uint8_t keyboard_leds(void) { return keyboard_led_stats; }", "extracted_prediction": "<answer>\nThis code defines a static function `keyboard_leds` that returns the current count of keyboard LEDs, using the variable `keyboard_led_stats`. The function takes no parameters and returns an unsigned 8-bit integer (`uint8_t`).\n</answer>"}
{"index": 473, "input": "**User**: \nCCLBuffer * ccl_buffer_new_wrap(cl_mem mem_object) {\n\n    return (CCLBuffer *) ccl_wrapper_new(\n        CCL_BUFFER, (void *) mem_object, sizeof(CCLBuffer));\n\n}", "extracted_prediction": "<answer>\nThis function initializes a new CCLBuffer by allocating a wrapper object using the CCL wrapper library. It takes a `cl_mem` memory object as input and returns a pointer to a newly created CCLBuffer, with the buffer size explicitly set to the size of a CCLBuffer structure.\n</answer>"}
{"index": 409, "input": "**User**: \nvoid qbman_pull_desc_clear(struct qbman_pull_desc *d)\n{\n\tmemset(d, 0, sizeof(*d));\n}", "extracted_prediction": "<answer>\nThe `qbman_pull_desc_clear` function clears all members of a `struct qbman_pull_desc` by setting its memory content to zero using `memset`. It takes a pointer to such a structure as input.\n</answer>"}
{"index": 732, "input": "**User**: \nstatic bool inode_logged(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_inode *inode)\n{\n\tif (inode->logged_trans == trans->transid)\n\t\treturn true;\n\n\tif (inode->last_trans == trans->transid &&\n\t    test_bit(BTRFS_INODE_NEEDS_FULL_SYNC, &inode->runtime_flags) &&\n\t    !test_bit(BTRFS_FS_LOG_RECOVERING, &trans->fs_info->flags))\n\t\treturn true;\n\n\treturn false;\n}", "extracted_prediction": "<answer>\nThis function `inode_logged` checks if a filesystem inode has logged transactions. It returns `true` if either:  \n1. The inode's logged transaction ID (`inode->logged_trans`) matches the current transaction ID in the filesystem transaction handle (`trans->transid`), or  \n2. The inode's last transaction ID (`inode->last_trans`) matches the current transaction ID, and the filesystem supports full sync (`BTRFS_INODE_NEEDS_FULL_SYNC` flag is set) without logging recovery (`BTRFS_FS_LOG_RECOVERING` flag is disabled).  \n\nOtherwise, it returns `false`.\n</answer>"}
{"index": 247, "input": "**User**: \nstatic inline void refill_rspq(struct adapter *adapter,\n\t\t\t       const struct sge_rspq *q, unsigned int credits)\n{\n\trmb();\n\tt3_write_reg(adapter, A_SG_RSPQ_CREDIT_RETURN,\n\t\t     V_RSPQ(q->cntxt_id) | V_CREDITS(credits));\n}", "extracted_prediction": "<answer>\nThis function `refill_rspq` updates the `A_SG_RSPQ_CREDIT_RETURN` register in the system's RMB (Return Message Buffer) by combining the current value from the `sge_rspq` structure's `cntxt_id` field with the provided `credits` value. It first resets the RMB buffer (`rmb()`) to ensure a clean state before writing the combined bitmask into the target register.\n</answer>"}
{"index": 290, "input": "**User**: \nstatic int calipso_sock_setattr(struct sock *sk,\n\t\t\t\tconst struct calipso_doi *doi_def,\n\t\t\t\tconst struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val;\n\tstruct ipv6_opt_hdr *old, *new;\n\tstruct ipv6_txoptions *txopts = txopt_get(inet6_sk(sk));\n\n\told = NULL;\n\tif (txopts)\n\t\told = txopts->hopopt;\n\n\tnew = calipso_opt_insert(old, doi_def, secattr);\n\ttxopt_put(txopts);\n\tif (IS_ERR(new))\n\t\treturn PTR_ERR(new);\n\n\tret_val = calipso_opt_update(sk, new);\n\n\tkfree(new);\n\treturn ret_val;\n}", "extracted_prediction": "<answer>\nThis function `calipso_sock_setattr` updates the IPV6 transmission options of a socket (`sk`) using Calipso. It retrieves the existing IPV6 transmission options (`txopts`), inserts new options including a DOI definition (`doi_def`) and security attribute (`secattr`), updates the socket's options, handles potential errors, and cleans up temporary data. The function returns the operation's success status or an error code.\n</answer>"}
{"index": 490, "input": "**User**: \nvoid* CMSEXPORT cmsGetContextUserData(cmsContext ContextID)\n{\n    return _cmsContextGetClientChunk(ContextID, UserPtr);\n}", "extracted_prediction": "<answer>\nThe `CMSEXPORT cmsGetContextUserData(cmsContext ContextID)` function retrieves a user data chunk from the context associated with the given `ContextID`. It calls `_cmsContextGetClientChunk` with the `ContextID` and `UserPtr` parameters, returning the result as a `void*` pointer. This function likely fetches user-specific context data stored in client chunks.\n</answer>"}
{"index": 736, "input": "**User**: \nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)\n{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));\n  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)\n  {\n    /* Drive the SMBusAlert pin Low */\n    I2Cx->CR1 |= I2C_SMBusAlert_Low;\n  }\n  else\n  {\n    /* Drive the SMBusAlert pin High  */\n    I2Cx->CR1 &= I2C_SMBusAlert_High;\n  }\n}", "extracted_prediction": "<answer>\nThis function configures the I2C peripheral's control register (CR1) based on the `I2C_SMBusAlert` parameter, using assertions to validate input values. It drives the SMBus alert pin low or high by setting/resetting specific bits in the I2Cx register's CR1 bit field.\n</answer>"}
{"index": 434, "input": "**User**: \nvoid rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {\n    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));\n    state->lines[state->numlines++] = line;\n}", "extracted_prediction": "<answer>\nThe `rewriteConfigAppendLine` function dynamically allocates an array of string pointers (`char*`) to store configuration lines, then appends a new line to this array and increments the line count. It uses `zrealloc` for efficient memory reallocation, ensuring the array grows to accommodate the new line without unnecessary copies.\n</answer>"}
{"index": 217, "input": "**User**: \nstatic int wm8996_get_retune_mobile_block(const char *name)\n{\n\tif (strcmp(name, \"DSP1 EQ Mode\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"DSP2 EQ Mode\") == 0)\n\t\treturn 1;\n\treturn -EINVAL;\n}", "extracted_prediction": "<answer>\nThis function `wm8996_get_retune_mobile_block` checks if the input `name` matches either \"DSP1 EQ Mode\" or \"DSP2 EQ Mode\". Returns `0` for \"DSP1 EQ Mode\", `1` for \"DSP2 EQ Mode\", and `-EINVAL` if the input name is invalid.\n</answer>"}
{"index": 679, "input": "**User**: \nint audio_buffer_frames(AudiodevPerDirectionOptions *pdo,\n                        audsettings *as, int def_usecs)\n{\n    uint64_t usecs = pdo->has_buffer_length ? pdo->buffer_length : def_usecs;\n    return (as->freq * usecs + 500000) / 1000000;\n}", "extracted_prediction": "<answer>\nThis function `audio_buffer_frames` calculates a duration in seconds based on audio device parameters. It computes the result as `(as->freq * usecs + 500000) / 1000000`, where:  \n- `usecs` is the buffer length (from `pdo`) or a default (`def_usecs`).  \n- `as->freq` is the audio device's frequency in hertz (Hz).  \n\nThe result represents a duration derived from the product of the device's frequency and buffer length (adjusted by a constant), plus a fixed offset, normalized to seconds.\n</answer>"}
{"index": 581, "input": "**User**: \nSilcUInt32 silc_hash_block_len(SilcHash hash)\n{\n  return hash->hash->block_len;\n}", "extracted_prediction": "<answer>\nThe `silc_hash_block_len` function retrieves the block length from a SilcHash object. It takes a SilcHash instance (`hash`) as input and returns the value of the `block_len` field within the hash structure (accessed via `hash->hash->block_len`). This indicates the length of the block stored in the SilcHash.\n</answer>"}
{"index": 764, "input": "**User**: \nvoid rproc_add_subdev(struct rproc *rproc, struct rproc_subdev *subdev)\n{\n\tlist_add_tail(&subdev->node, &rproc->subdevs);\n}", "extracted_prediction": "<answer>\nThis function appends a subdevice to the list of subdevices associated with the main process, linking it to the subdevice's node list using `list_add_tail`.\n</answer>"}
{"index": 338, "input": "**User**: \nvoid radix__flush_all_lpid(unsigned int lpid)\n{\n\t_tlbie_lpid(lpid, RIC_FLUSH_ALL);\n}", "extracted_prediction": "<answer>\nThis function `radix__flush_all_lpid` is responsible for flushing all LPI (length pointer) information for a given length pointer `lpid`. It uses the low-order type information (`_tlbie_`) macro and a flag `RIC_FLUSH_ALL` to ensure all associated flush operations are executed for the specified length pointer.\n</answer>"}
{"index": 876, "input": "**User**: \ninit_combo_box(GtkBuilder *builder, const gchar *name)\n{\n    GtkComboBox *combo;\n\n    g_debug(\"init_combo_box() %s\\n\", name);\n    // First modify the combobox model to allow greying out of options\n    combo = GTK_COMBO_BOX(GHB_WIDGET(builder, name));\n    ghb_init_combo_box(combo);\n}", "extracted_prediction": "<answer>\nThe `init_combo_box` function initializes a `GtkComboBox` widget within a `GtkBuilder`. It logs a debug message, creates the combo box using `GTK_COMBO_BOX`, and initializes it via `ghb_init_combo_box`.\n</answer>"}
{"index": 168, "input": "**User**: \n__weak void HAL_SMARTCARD_RxCpltCallback(SMARTCARD_HandleTypeDef *hsc)\n{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hsc);\n  /* NOTE : This function Should not be modified, when the callback is needed,\n            the HAL_SMARTCARD_RxCpltCallback could be implemented in the user file\n   */\n}", "extracted_prediction": "<answer>\nThe `HAL_SMARTCARD_RxCpltCallback` function is a callback triggered when a smart card's read response is completed. It takes a pointer to a smart card handle (`SMARTCARD_HandleTypeDef *hsc`) as input. The compiler warns about an unused parameter (`hsc`), indicating the function should not be modified unless the callback is required. A note states it should remain unmodified by default.\n</answer>"}
{"index": 920, "input": "**User**: \nMarkCurrentTransactionIdLoggedIfAny(void)\n{\n\tif (FullTransactionIdIsValid(CurrentTransactionState->fullTransactionId))\n\t\tCurrentTransactionState->didLogXid = true;\n}", "extracted_prediction": "<answer>\nThis function checks if the current transaction's `fullTransactionId` is valid. If valid, it sets the `didLogXid` flag in the `CurrentTransactionState` to `true`, indicating that at least one transaction ID has been logged.\n</answer>"}
{"index": 711, "input": "**User**: \nvoid devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)\n{\n\tWARN_ON(devres_release(dev, devm_gpiod_release_array,\n\t\t\t       devm_gpiod_match_array, &descs));\n}", "extracted_prediction": "<answer>\nThis function `devm_gpiod_put_array` is responsible for releasing a GPIO array resource associated with a device and matching it with the provided device descriptors (`struct gpio_descs`). It includes a warning (`devres_release`) to alert about potential resource management issues before releasing the array. The function takes a `struct device` pointer (the device being managed) and a `struct gpio_descs` pointer (the device-specific GPIO descriptors) as inputs.\n</answer>"}
{"index": 969, "input": "**User**: \nstatic void scoll_base_module_construct(mca_scoll_base_module_t *m)\n{\n    /* Collective function pointers */\n    m->scoll_barrier = NULL;\n    m->scoll_broadcast = NULL;\n    m->scoll_collect = NULL;\n    m->scoll_reduce = NULL;\n    m->scoll_alltoall = NULL;\n    m->scoll_module_enable = NULL;\n}", "extracted_prediction": "<answer>\nThis static function initializes the `MCA_SCOLL_BASE_MODULE_T` structure by setting all collective operation function pointers (`scoll_barrier`, `scoll_broadcast`, etc.) to `NULL`. These function pointers are placeholders for future implementation of collective operations (e.g., barrier synchronization, broadcast messaging) that will be configured during module initialization.\n</answer>"}
{"index": 299, "input": "**User**: \nstatic chunk_t build_Request(private_x509_ocsp_request_t *this,\n\t\t\t\t\t\t\t chunk_t issuerNameHash, chunk_t issuerKeyHash,\n\t\t\t\t\t\t\t chunk_t serialNumber)\n{\n\treturn asn1_wrap(ASN1_SEQUENCE, \"m\",\n\t\t\t\tasn1_wrap(ASN1_SEQUENCE, \"mmmm\",\n\t\t\t\t\tasn1_algorithmIdentifier(OID_SHA1),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerNameHash),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerKeyHash),\n\t\t\t\t\tasn1_simple_object(ASN1_INTEGER, serialNumber)));\n}", "extracted_prediction": "<answer>\nThis function `build_Request` constructs an ASN.1-encoded value (a `ASN1_wrap`) representing a request. It creates a SEQUENCE (`ASN1_SEQUENCE`) with three components:  \n- A top-level element `\"m\"`,  \n- A nested SEQUENCE `\"mmmm\"` containing:  \n  - An OID SHA-1 identifier (`OID_SHA1`),  \n  - Two octet-encoded strings (`issuerNameHash`, `issuerKeyHash`),  \n  - An integer (`serialNumber`).  \n\nThe function accepts pointers to `private_x509_ocsp_request_t` and three input chunks (`issuerNameHash`, `issuerKeyHash`, `serialNumber`), returning the constructed ASN.1 value.\n</answer>"}
{"index": 615, "input": "**User**: \nstatic uint16_t auth_to_hash(uint16_t alg)\n{\n\tswitch (alg)\n\t{\n\t\tcase AUTH_HMAC_SHA1_96:\n\t\t\treturn HASH_SHA1;\n\t\tcase AUTH_HMAC_SHA2_256_128:\n\t\t\treturn HASH_SHA256;\n\t\tcase AUTH_HMAC_SHA2_384_192:\n\t\t\treturn HASH_SHA384;\n\t\tcase AUTH_HMAC_SHA2_512_256:\n\t\t\treturn HASH_SHA512;\n\t\tcase AUTH_HMAC_MD5_96:\n\t\t\treturn HASH_MD5;\n\t\tdefault:\n\t\t\treturn HASH_UNKNOWN;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `auth_to_hash` maps an algorithm type (`uint16_t alg`) to a specific HMAC hash function. It uses a `switch` statement to handle predefined cases (e.g., `AUTH_HMAC_SHA1_96` maps to `HASH_SHA1`), returning the corresponding hash implementation. If the algorithm isn’t recognized, it returns `HASH_UNKNOWN`.\n</answer>"}
{"index": 124, "input": "**User**: \nvoid t4vf_sge_start(struct adapter *adapter)\n{\n\tadapter->sge.ethtxq_rover = 0;\n\tmod_timer(&adapter->sge.rx_timer, jiffies + RX_QCHECK_PERIOD);\n\tmod_timer(&adapter->sge.tx_timer, jiffies + TX_QCHECK_PERIOD);\n}", "extracted_prediction": "<answer>\nThis function `t4vf_sge_start` initializes a structure `sge` within an adapter to set up timing mechanisms. It sets `adapter->sge.ethtxq_rover` to 0 and schedules periodic timer checks for RX (`RX_QCHECK_PERIOD`) and TX (`TX_QCHECK_PERIOD`) operations, likely to monitor or trigger network traffic processing.\n</answer>"}
{"index": 583, "input": "**User**: \nvoid MsSetThreadSingleCpu()\n{\n\tSetThreadAffinityMask(GetCurrentThread(), 1);\n}", "extracted_prediction": "<answer>\nThis function, `MsSetThreadSingleCpu()`, restricts the current thread to use only its primary CPU core by setting its thread affinity mask to 1 (where 1 represents the first CPU core).\n</answer>"}
{"index": 658, "input": "**User**: \nint StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}", "extracted_prediction": "<answer>\nThe `StreamTcpInlineMode` function returns 1 if the `STREAMTCP_INIT_FLAG_INLINE` flag is set in the `stream_config` structure, and 0 otherwise. This indicates whether the TCP stream configuration is set to inline mode.\n</answer>"}
{"index": 254, "input": "**User**: \nvoid OS_COM_Send1(OS_U8 c) {\n  OS_USEPARA(c);           // Avoid compiler warning\n  OS_COM_ClearTxActive();  // Let embOS know that Tx is not busy\n}", "extracted_prediction": "<answer>\nThe `OS_COM_Send1` function prepares for a transmission by enabling parallel processing (`OS_USEPARA(c)`) to avoid compiler warnings and explicitly marking the transmission channel as inactive (`OS_COM_ClearTxActive()`).\n</answer>"}
{"index": 546, "input": "**User**: \nstatic inline void kasan_free_nondeferred_pages(struct page *page, int order)\n{\n\tif (!static_branch_unlikely(&deferred_pages))\n\t\tkasan_free_pages(page, order);\n}", "extracted_prediction": "<answer>\nThis is a helper function that conditionally frees nondeferred pages from a kernel page structure. It checks if \"deferred pages\" are not unlikely using `static_branch_unlikely`, and if true, it calls `kasan_free_pages` to release the specified number of nondeferred pages based on the page structure (`page`) and order.\n</answer>"}
{"index": 472, "input": "**User**: \nstatic void amdgpu_dm_crtc_copy_transient_flags(struct drm_crtc_state *crtc_state,\n\t\t\t\t\t\tstruct dc_stream_state *stream_state)\n{\n\tstream_state->mode_changed = drm_atomic_crtc_needs_modeset(crtc_state);\n}", "extracted_prediction": "<answer>\nThis function `amdgpu_dm_crtc_copy_transient_flags` copies transient flags from a DRM CRTC state (`crtc_state`) to a stream state (`stream_state`). It checks if the CRTC state requires mode changes using `drm_atomic_crtc_needs_modeset(crtc_state)` and sets `stream_state->mode_changed` accordingly. This handles dynamic mode transitions tied to the DRM core's CRTC state.\n</answer>"}
{"index": 769, "input": "**User**: \nadin_sndfile_get_current_filename()\n{\n  return(speechfilename);\n}", "extracted_prediction": "<answer>\nThe function `adin_sndfile_get_current_filename()` retrieves the current filename using the adin_sndfile library, returning the `speechfilename` variable.\n</answer>"}
{"index": 352, "input": "**User**: \nstatic void quirk_vt82c598_id(struct pci_dev *dev)\n{\n\tpci_write_config_byte(dev, 0xfc, 0);\n\tpci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);\n}", "extracted_prediction": "<answer>\nThis C function `quirk_vt82c598_id` configures a specific byte (0xfc) on a PCI device and reads the PCI device ID (PCI_DEVICE_ID) from the device structure. It uses `pci_write_config_byte` to set the byte and `pci_read_config_word` to retrieve the device ID from the PCI device.\n</answer>"}
{"index": 688, "input": "**User**: \nstatic inline struct xfs_icreate_item *ICR_ITEM(struct xfs_log_item *lip)\n{\n\treturn container_of(lip, struct xfs_icreate_item, ic_item);\n}", "extracted_prediction": "<answer>\nThis is a helper function that retrieves a pointer to a `struct xfs_icreate_item` from a `struct xfs_log_item`. It uses the `container_of` macro to cast the input `xfs_log_item` to the target struct type by name (`ic_item`), making it a convenient way to access the relevant data stored in the log item.\n</answer>"}
{"index": 257, "input": "**User**: \nreport_error_message(Step *step)\n{\n\tif (step->errormsg)\n\t{\n\t\tfprintf(stdout, \"%s\\n\", step->errormsg);\n\t\tfree(step->errormsg);\n\t\tstep->errormsg = NULL;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `report_error_message` checks if a `Step` object contains an error message (`step->errormsg`). If the error message exists, it prints it to standard output (`stdout`), frees the dynamically allocated memory allocated for the error message, and sets `step->errormsg` to `NULL` to clear the field. This handles error reporting by outputting and cleaning up the error message data.\n</answer>"}
{"index": 942, "input": "**User**: \nTIFFWritePerSampleAnys(TIFF* tif,\n    TIFFDataType type, ttag_t tag, TIFFDirEntry* dir)\n{\n\tdouble buf[10], v;\n\tdouble* w = buf;\n\tint i, status;\n\tint samples = (int) tif->tif_dir.td_samplesperpixel;\n\n\tif (samples > NITEMS(buf))\n\t\tw = (double*) _TIFFmalloc(samples * sizeof (double));\n\tTIFFGetField(tif, tag, &v);\n\tfor (i = 0; i < samples; i++)\n\t\tw[i] = v;\n\tstatus = TIFFWriteAnyArray(tif, type, tag, dir, samples, w);\n\tif (w != buf)\n\t\t_TIFFfree(w);\n\treturn (status);\n}", "extracted_prediction": "<answer>\nThis function `TIFFWritePerSampleAnys` writes data to a TIFF file per sample. It takes a `TIFF*` pointer, a `TIFFDataType` type, a `tag`, and a `TIFFDirEntry` directory entry. It dynamically allocates a buffer sized for the number of samples (from the TIFF directory), copies the data from the specified `tag` into this buffer, and writes the data using `TIFFWriteAnyArray`. Memory is freed after the operation.\n</answer>"}
{"index": 494, "input": "**User**: \nstatic int velocity_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct velocity_info *vptr = netdev_priv(dev);\n\tint ret;\n\n\t/* If we are asked for information and the device is power\n\t   saving then we need to bring the device back up to talk to it */\n\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D0);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\t/* Get address of MII PHY in use. */\n\tcase SIOCGMIIREG:\t/* Read MII PHY register. */\n\tcase SIOCSMIIREG:\t/* Write to MII PHY register. */\n\t\tret = velocity_mii_ioctl(dev, rq, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\tif (!netif_running(dev))\n\t\tvelocity_set_power_state(vptr, PCI_D3hot);\n\n\n\treturn ret;\n}", "extracted_prediction": "<answer>\nThis function `velocity_ioctl` handles I/O control operations related to MII (Multi-Channel I/O) PHY management. It checks if the network device is running, sets the power state if inactive, and performs either reading/writing of MII PHY registers based on the `cmd` parameter. If no valid operation is performed, it returns `-EOPNOTSUPP`. The function uses `velocity_mii_ioctl` internally to execute MII-specific I/O commands.\n</answer>"}
{"index": 528, "input": "**User**: \nstatic int portman_data_avail(struct portman *pm, int channel)\n{\n\tint command = INT_EN;\n\tswitch (channel) {\n\tcase 0:\n\t\tcommand |= RXDATA0;\n\t\tbreak;\n\tcase 1:\n\t\tcommand |= RXDATA1;\n\t\tbreak;\n\t}\n\t/* Write hardware (assumme STROBE=0) */\n\tportman_write_command(pm, command);\n\t/* Check multiplexed RxAvail signal */\n\tif ((portman_read_status(pm) & RXAVAIL) == RXAVAIL)\n\t\treturn 1;\t/* Data available */\n\n\t/* No Data available */\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThis function `portman_data_avail` checks if data is available on a specific channel (0 or 1) of the Portman hardware. It sets a command bit in the corresponding RXDATA register (RXDATA0 for channel 0, RXDATA1 for channel 1), sends this command to the portman device, and checks if the portman reports RXAVAIL (indicating data availability). Returns 1 if RXAVAIL is detected, otherwise 0.\n</answer>"}
{"index": 607, "input": "**User**: \nmptsas_del_device_component_by_os(MPT_ADAPTER *ioc, u8 channel, u8 id)\n{\n\tstruct mptsas_device_info\t*sas_info, *next;\n\n\t/*\n\t * Set is_cached flag\n\t */\n\tlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\n\t\tlist) {\n\t\tif (sas_info->os.channel == channel && sas_info->os.id == id)\n\t\t\tsas_info->is_cached = 1;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `mptsas_del_device_component_by_os` deletes a MPT (Management Point Technology) device component from the system. It iterates over a list of MPT device components associated with the input structure (`ioc`), checks if a component matches the specified `channel` and `id`, and marks it as \"cached\" by setting `sas_info->is_cached = 1`. This likely optimizes deletion by avoiding unnecessary operations on already cached components.\n</answer>"}
{"index": 91, "input": "**User**: \nstatic void spapr_machine_2_11_class_options(MachineClass *mc)\n{\n    SpaprMachineClass *smc = SPAPR_MACHINE_CLASS(mc);\n\n    spapr_machine_2_12_class_options(mc);\n    smc->default_caps.caps[SPAPR_CAP_HTM] = SPAPR_CAP_ON;\n    compat_props_add(mc->compat_props, hw_compat_2_11, hw_compat_2_11_len);\n}", "extracted_prediction": "<answer>\nThis function configures a machine class (`spapr_machine_2_11_class_options`) for the Spapr framework, specifically targeting 2.1 compatibility. It retrieves the machine class from the input pointer, calls a 2.2-compatible method, enables a hash table capability (`SPAPR_CAP_ON`), and adds a 2.1-compatible compatibility property to the machine class's properties.\n</answer>"}
{"index": 707, "input": "**User**: \nstatic int __init uvhub_to_first_node(int uvhub)\n{\n\tint node, b;\n\n\tfor_each_online_node(node) {\n\t\tb = uv_node_to_blade_id(node);\n\t\tif (uvhub == b)\n\t\t\treturn node;\n\t}\n\treturn -1;\n}", "extracted_prediction": "<answer>\nThis function `uvhub_to_first_node` searches for the first online node associated with the given `uvhub` ID. It iterates through all online nodes, retrieves their blade IDs via `uv_node_to_blade_id`, and returns the corresponding node if a match is found. If no match is found, it returns `-1`.\n</answer>"}
{"index": 393, "input": "**User**: \nvoid RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)\n{\n  /* Check the parameters */\n  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));\n\n  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;\n}", "extracted_prediction": "<answer>\nThis function `RCC_I2SCLKConfig` configures the I2S (Inter-Integrated System) clock source in the RCC (System Clock Controller). It takes a parameter `RCC_I2SCLKSource` (the desired I2S clock source, e.g., external or internal), validates it using an assertion (`assert_param`), and stores the valid source in the macro `CFGR_I2SSRC_BB`.\n</answer>"}
{"index": 945, "input": "**User**: \nvoid default_layer_and(layer_state_t state) { default_layer_state_set(default_layer_state & state); }", "extracted_prediction": "<answer>\nThis function updates the default layer state by setting it to the address of the provided `layer_state_t` parameter. It copies the current state into itself using `default_layer_state_set`, effectively initializing the default layer state from the input state.\n</answer>"}
{"index": 335, "input": "**User**: \nstatic KMETHOD Object_instanceOf(KonohaContext *kctx, KonohaStack *sfp)\n{\n\tKClass *selfClass = kObject_class(sfp[0].asObject), *targetClass = kObject_class(sfp[1].asObject);\n\tKReturnUnboxValue(selfClass == targetClass || selfClass->isSubType(kctx, selfClass, targetClass));\n}", "extracted_prediction": "<answer>\nThis `Object_instanceOf` method checks if the object classes of two objects in a `KonohaStack` are either identical or one is a subtype of the other. It returns `KReturnUnboxValue` if they are related (allowing unboxing from the first to the second), and `KReturnNull` otherwise. This is likely used to determine if an object can be deserialized or if one object is a valid subtype of another in a hierarchical object system.\n</answer>"}
{"index": 928, "input": "**User**: \nstatic void ice_vsi_set_num_desc(struct ice_vsi *vsi)\n{\n\tswitch (vsi->type) {\n\tcase ICE_VSI_PF:\n\t\t/* fall through */\n\tcase ICE_VSI_LB:\n\t\tvsi->num_rx_desc = ICE_DFLT_NUM_RX_DESC;\n\t\tvsi->num_tx_desc = ICE_DFLT_NUM_TX_DESC;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Not setting number of Tx/Rx descriptors for VSI type %d\\n\",\n\t\t\tvsi->type);\n\t\tbreak;\n\t}\n}", "extracted_prediction": "<answer>\nThis function `ice_vsi_set_num_desc` configures the number of RX/TX descriptor tables for an Ice VSI device based on its type. For `ICE_VSI_LB` (loop-based), it explicitly sets `num_rx_desc` and `num_tx_desc` to default values (`ICE_DFLT_NUM_RX_DESC` and `ICE_DFLT_NUM_TX_DESC`). For `ICE_VSI_PF` (packet-based), it \"falls through\" to continue execution. Any other VSI type triggers a debug warning via `dev_dbg`.\n</answer>"}
{"index": 319, "input": "**User**: \nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) |\n\t\t\t   DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) &\n\t\t\t   ~(DUPS1_GATING_DIS | DUPS2_GATING_DIS));\n}", "extracted_prediction": "<answer>\nThis function `skl_wa_827` toggles the gating bits on/off for an MIPS processor's I915 clock controller. It uses `CLKGATE_DIS_PSL` to read/write the clock gating state to the specified `pipe`, with `DUPS1_GATING_DIS` and `DUPS2_GATING_DIS` as the toggle bits. If `enable` is true, it writes the current gating state OR-ing the toggle bits; if false, it writes the inverse AND-ing them. This adjusts the clock generation gating configuration dynamically.\n</answer>"}
{"index": 508, "input": "**User**: \nstatic void list_splice_entire_tail(struct list_head *from,\n\t\t\t\t    struct list_head *to)\n{\n\tstruct list_head *from_last = from->prev;\n\n\tlist_splice_tail(from_last, to);\n\tlist_add_tail(from_last, to);\n}", "extracted_prediction": "<answer>\nThis function splices the entire tail of the list head `from` into the list head `to`. It first identifies the node immediately preceding `from` (stored as `from_last`), removes this node from the list using `list_splice_tail`, and then appends it to the end of `to` using `list_add_tail`, effectively transferring the tail of `from` to the end of `to`.\n</answer>"}
{"index": 9, "input": "**User**: \nvoid ge_sub(ge_p1p1 *r,const ge_p3 *p,const ge_cached *q)\n{\n  fe t0;\n#include \"ge_sub.h\"\n}", "extracted_prediction": "<answer>\nThis is a C function declaration for `ge_sub`, which takes three pointer parameters (`ge_p1p1 *r`, `ge_p3 *p`, `ge_cached *q`) and performs operations on them. The function is declared without a return value (`void`), likely part of a larger ge-related system (e.g., geometry processing) as indicated by the struct names (`ge_p1p1`, `ge_p3`, `ge_cached`). The `#include \"ge_sub.h\"` directive suggests it uses definitions from a header file defining these structures and associated functions.\n</answer>"}
{"index": 888, "input": "**User**: \nint sqlite3PagerIsMemdb(Pager *pPager){\n  return pPager->tempFile;\n}", "extracted_prediction": "<answer>\nThis function checks if the temporary file associated with the `Pager` object is in memory by verifying its existence through the `tempFile` member of the `Pager` pointer. It returns `true` if the file exists (in memory), and `false` otherwise.\n</answer>"}
{"index": 386, "input": "**User**: \nfetch_function_defaults(HeapTuple func_tuple)\n{\n\tList\t   *defaults;\n\tDatum\t\tproargdefaults;\n\tbool\t\tisnull;\n\tchar\t   *str;\n\n\t/* The error cases here shouldn't happen, but check anyway */\n\tproargdefaults = SysCacheGetAttr(PROCOID, func_tuple,\n\t\t\t\t\t\t\t\t\t Anum_pg_proc_proargdefaults,\n\t\t\t\t\t\t\t\t\t &isnull);\n\tif (isnull)\n\t\telog(ERROR, \"not enough default arguments\");\n\tstr = TextDatumGetCString(proargdefaults);\n\tdefaults = castNode(List, stringToNode(str));\n\tpfree(str);\n\treturn defaults;\n}", "extracted_prediction": "<answer>\nThis Go function `fetch_function_defaults` retrieves default arguments for a given function represented as a `HeapTuple`. It first checks if the function has any default arguments using `SysCacheGetAttr`. If no defaults exist, it logs an error. Otherwise, it converts the default arguments (stored as a string) into a `List` node, frees the temporary string, and returns the list of default arguments.\n</answer>"}
{"index": 268, "input": "**User**: \nstatic void gtkui_update(int target)\n{\n    switch (target) {\n        case UI_UPDATE_HOSTLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_host_list, NULL);\n            break;\n        case UI_UPDATE_PLUGINLIST:\n            g_idle_add((GSourceFunc)gtkui_refresh_plugin_list, NULL);\n            break;\n    }\n\n}", "extracted_prediction": "<answer>\nThis function `gtkui_update` is triggered by a `target` integer parameter. When either `UI_UPDATE_HOSTLIST` or `UI_UPDATE_PLUGINLIST` cases are matched, it schedules the execution of `gtkui_refresh_host_list` (for host list updates) or `gtkui_refresh_plugin_list` (for plugin list updates) using `g_idle_add`, with no associated user data passed to the scheduled function.\n</answer>"}
{"index": 477, "input": "**User**: \nstatic int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)\n{\n\tunsigned int i, j;\n\tu8 wwn[8];\n\n\tmemset(wwn, 0, sizeof(wwn));\n\n\t/* Validate and store the new name */\n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tint value;\n\n\t\tvalue = hex_to_bin(*ns++);\n\t\tif (value >= 0)\n\t\t\tj = (j << 4) | value;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t*nm = wwn_to_u64(wwn);\n\treturn 0;\n}", "extracted_prediction": "<answer>\nThis function `tcm_qla2xxx_npiv_extract_wwn` extracts a 128-bit WWN (World Name Identifier) from a hexadecimal string (`ns`) and stores it in a pre-allocated `u64` buffer (`nm`).  \n\n### Key Details:\n1. **Input Validation**:  \n   - Iterates through each 16-character hexadecimal string segment.  \n   - Converts each character to a 4-bit nibble (0x00–0xFF). If any nibble is invalid (negative value), returns `-EINVAL`.  \n\n2. **WWN Construction**:  \n   - Packs valid nibbles into an 8-byte `wwn` buffer, alternating nibbles into pairs (e.g., first nibble in byte 0, second in byte 1, etc.).  \n\n3. **Output**:  \n   - Converts the 8-byte `wwn` buffer to a `u64` using `wwn_to_u64` and stores it in `*nm`.  \n\n**Return Value**:  \n- `0` on success; `-EINVAL` if any hexadecimal character is invalid.\n</answer>"}
{"index": 228, "input": "**User**: \nstatic void vmw_swap_notify(struct ttm_buffer_object *bo)\n{\n\tvmw_bo_swap_notify(bo);\n\t(void) ttm_bo_wait(bo, false, false);\n}", "extracted_prediction": "<answer>\nThis static function `vmw_swap_notify` is responsible for initiating swap notifications on a `ttm_buffer_object`. It first calls an internal swap notification handler (`vmw_bo_swap_notify`) and then waits for the buffer to become available using `ttm_bo_wait`, ensuring proper swap operations occur only after the buffer is ready.\n</answer>"}
{"index": 905, "input": "**User**: \nmongoc_counters_calc_size (void)\n{\n   size_t n_cpu;\n   size_t n_groups;\n   size_t size;\n\n   n_cpu = _mongoc_get_cpu_count ();\n   n_groups = (LAST_COUNTER / SLOTS_PER_CACHELINE) + 1;\n   size = (sizeof (mongoc_counters_t) +\n           (LAST_COUNTER * sizeof (mongoc_counter_info_t)) +\n           (n_cpu * n_groups * sizeof (mongoc_counter_slots_t)));\n\n#ifdef BSON_OS_UNIX\n   return BSON_MAX (getpagesize (), size);\n#else\n   return size;\n#endif\n}", "extracted_prediction": "<answer>\nThis function calculates the required memory size for MongoDB's counters. It determines the number of CPU cores (`n_cpu`), the number of cache lines needed (`n_groups`) based on `LAST_COUNTER` and `SLOTS_PER_CACHELINE`, and computes the total memory by summing the sizes of the counters data structures, counter info entries, and slots across cores and cache lines. On Unix systems, it returns the maximum page size or the calculated size; on other OSes, it returns only the computed size.\n</answer>"}
{"index": 65, "input": "**User**: \nget_range_subtype(Oid rangeOid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(rangeOid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = rngtup->rngsubtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}", "extracted_prediction": "<answer>\nThe `get_range_subtype` function retrieves the subtype of a given range object by its OID. It uses `SearchSysCache1` to fetch metadata about the range, checks if the retrieval is valid, and returns the range's subtype (as an `Oid`) or `InvalidOid` if the range is not found.\n</answer>"}
{"index": 475, "input": "**User**: \nstatic int compile(char *src, char *dst) {\n\tcompose(com, clist, append(src, 0), append(dst, 0));\n\treturn callsys(av);\n}", "extracted_prediction": "<answer>\nThis `compile` function appends the values of `src` and `dst` to a list `clist`, calls `compose(com, clist,...)` to perform an operation on the modified list, and returns the result of `callsys(av)` (where `av` likely holds context or state).\n</answer>"}
{"index": 696, "input": "**User**: \nstatic void sama5d2_piobu_set(struct gpio_chip *chip, unsigned int pin,\n\t\t\t      int value)\n{\n\tif (!value)\n\t\tvalue = PIOBU_LOW;\n\telse\n\t\tvalue = PIOBU_HIGH;\n\n\tsama5d2_piobu_write_value(chip, pin, PIOBU_SOD, value);\n}", "extracted_prediction": "<answer>\nThis function `sama5d2_piobu_set` configures the output direction of a GPIO pin to either low (default when no value is provided) or high (when a non-zero value is specified). It does this by writing the target value to the GPIO chip's output direction register (PIOBU_SOD) using the provided pin number. If no value is passed, it defaults to `PIOBU_LOW`; otherwise, it uses `PIOBU_HIGH`.\n</answer>"}
{"index": 252, "input": "**User**: \nxpc_check_remote_hb(void)\n{\n\tstruct xpc_partition *part;\n\tshort partid;\n\tenum xp_retval ret;\n\n\tfor (partid = 0; partid < xp_max_npartitions; partid++) {\n\n\t\tif (xpc_exiting)\n\t\t\tbreak;\n\n\t\tif (partid == xp_partition_id)\n\t\t\tcontinue;\n\n\t\tpart = &xpc_partitions[partid];\n\n\t\tif (part->act_state == XPC_P_AS_INACTIVE ||\n\t\t    part->act_state == XPC_P_AS_DEACTIVATING) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = xpc_arch_ops.get_remote_heartbeat(part);\n\t\tif (ret != xpSuccess)\n\t\t\tXPC_DEACTIVATE_PARTITION(part, ret);\n\t}\n}", "extracted_prediction": "<answer>\nThis function `xpc_check_remote_hb` iterates through all XPC partitions, skipping the current partition (`xp_partition_id`) and inactive/deactivating ones. For each active partition, it attempts to execute a remote heartbeat operation via `xpc_arch_ops.get_remote_heartbeat()`. If the operation fails (`ret!= xpSuccess`), it deactivates the partition using `XPC_DEACTIVATE_PARTITION()`. The loop terminates when `xpc_exiting` is detected.\n</answer>"}
{"index": 149, "input": "**User**: \nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\n{\n\tstruct snd_interval t;\n\tt.empty = 0;\n\tt.min = t.max = val;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(i, &t);\n}", "extracted_prediction": "<answer>\nThis function `snd_interval_refine_set` initializes and configures a `struct snd_interval` structure to refine interval settings. It sets `t.min` and `t.max` to the provided `val`, initializes `t.empty` to 0, `t.openmin` and `t.openmax` to 0, and sets `t.integer` to 1 before calling `snd_interval_refine` to apply these changes to the interval structure.\n</answer>"}
{"index": 218, "input": "**User**: \nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->autoneg_stat)\n\t\tmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\n\telse\n\t\t*auto_neg = 0;\n}", "extracted_prediction": "<answer>\nThis function `hns_mac_get_autoneg` initializes an auto-negative MAC driver control mechanism. It retrieves a driver handle (`mac_ctrl_drv`) from the provided callback (`mac_cb`). If the driver has an active auto-negative status (`mac_ctrl_drv->autoneg_stat`), it triggers the status update via `mac_ctrl_drv->autoneg_stat`. Otherwise, it sets the `auto_neg` parameter to zero.\n</answer>"}
{"index": 320, "input": "**User**: \nunsigned int cxgb4_port_viid(const struct net_device *dev)\n{\n\treturn netdev2pinfo(dev)->viid;\n}", "extracted_prediction": "<answer>\nThe function `cxgb4_port_viid` returns the `viid` (unique identifier) of the port associated with the provided `net_device` struct.\n</answer>"}
{"index": 675, "input": "**User**: \nint idr_alloc(struct idr *idr, void *ptr, int start, int end, gfp_t gfp)\n{\n\tu32 id = start;\n\tint ret;\n\n\tif (WARN_ON_ONCE(start < 0))\n\t\treturn -EINVAL;\n\n\tret = idr_alloc_u32(idr, ptr, &id, end > 0 ? end - 1 : INT_MAX, gfp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn id;\n}", "extracted_prediction": "<answer>\nThis function `idr_alloc` allocates memory of a specified size using the `idr` structure, with parameters including a pointer to the allocation structure (`idr`), a pointer to the allocation start address (`ptr`), and allocation bounds (`start`, `end`). It enforces validation for negative `start` values and uses `gfp_t` for memory allocation control. The actual allocated size is determined by `end - 1` (if `end > 0`) or `INT_MAX` (if `end ≤ 0`), returning the starting address on success or `-EINVAL` if `start` is negative.\n</answer>"}
