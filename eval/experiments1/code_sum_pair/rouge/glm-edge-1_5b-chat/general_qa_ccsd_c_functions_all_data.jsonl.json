{"index": 567, "input": "**User**: \nstatic void *gcov_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tloff_t i;\n\n\tgcov_iter_start(seq->private);\n\tfor (i = 0; i < *pos; i++) {\n\t\tif (gcov_iter_next(seq->private))\n\t\t\treturn NULL;\n\t}\n\treturn seq->private;\n}", "extracted_prediction": "This function initializes a GCOV iterator and starts it at the given position. It then iterates through the specified number of positions, updating the position pointer and checking if the next iteration is successful. If the iteration is successful, it returns a pointer to the iterator; otherwise, it returns NULL."}
{"index": 362, "input": "**User**: \nlist_insert_nth(List *list, int pos, void *datum)\n{\n\tif (list == NIL)\n\t{\n\t\tAssert(pos == 0);\n\t\treturn list_make1(datum);\n\t}\n\tAssert(IsPointerList(list));\n\tlfirst(insert_new_cell(list, pos)) = datum;\n\tcheck_list_invariants(list);\n\treturn list;\n}", "extracted_prediction": "This function inserts a datum into a list at a specified position. If the list is empty, it creates a new list with the datum. Otherwise, it inserts the datum at the specified position and checks the list's invariants."}
{"index": 105, "input": "**User**: \nstatic void s3c_cpufreq_freq_min(struct s3c_freq *dst,\n\t\t\t\t struct s3c_freq *a, struct s3c_freq *b)\n{\n\tdst->fclk = do_min(a->fclk, b->fclk);\n\tdst->hclk = do_min(a->hclk, b->hclk);\n\tdst->pclk = do_min(a->pclk, b->pclk);\n\tdst->armclk = do_min(a->armclk, b->armclk);\n}", "extracted_prediction": "This function, `s3c_cpufreq_freq_min`, takes two frequency structs, `a` and `b`, and calculates the minimum frequency among the clock frequencies (`fclk`, `hclk`, `pclk`, `armclk`) for the destination struct `dst`. The minimum values are stored in `dst->fclk`, `dst->hclk`, `dst->pclk`, and `dst->armclk` respectively."}
{"index": 299, "input": "**User**: \nstatic chunk_t build_Request(private_x509_ocsp_request_t *this,\n\t\t\t\t\t\t\t chunk_t issuerNameHash, chunk_t issuerKeyHash,\n\t\t\t\t\t\t\t chunk_t serialNumber)\n{\n\treturn asn1_wrap(ASN1_SEQUENCE, \"m\",\n\t\t\t\tasn1_wrap(ASN1_SEQUENCE, \"mmmm\",\n\t\t\t\t\tasn1_algorithmIdentifier(OID_SHA1),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerNameHash),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerKeyHash),\n\t\t\t\t\tasn1_simple_object(ASN1_INTEGER, serialNumber)));\n}", "extracted_prediction": "This function constructs a new `private_x509_ocsp_request_t` object by wrapping it in an ASN.1 SEQUENCE with the following components:\n- A SEQUENCE of type \"mmmm\" containing:\n  - An `algorithmIdentifier` with the OID SHA1.\n  - An `OCTET_STRING` containing the `issuerNameHash`.\n  - An `OCTET_STRING` containing the `issuerKeyHash`.\n  - An `INTEGER` containing the `serialNumber`."}
{"index": 248, "input": "**User**: \nstatic MSize ndigits_dec(uint32_t x)\n{\n  MSize t = ((lj_fls(x | 1) * 77) >> 8) + 1; /* 2^8/77 is roughly log2(10) */\n  return t + (x > ndigits_dec_threshold[t]);\n}", "extracted_prediction": "This function, `ndigits_dec`, calculates the number of digits in a given `uint32_t` number `x`. It uses the formula `(lj_fls(x | 1) * 77) >> 8` to estimate the number of digits, where `lj_fls` is a logarithmic function, and `77` is a constant that approximates `log2(10)`. The result is then adjusted by adding `x > ndigits_dec_threshold[t]`, where `ndigits_dec_threshold` is a predefined threshold that determines the maximum number of digits to consider."}
{"index": 649, "input": "**User**: \nstatic inline void zero_ino_node_unused(struct ubifs_ino_node *ino)\n{\n\tmemset(ino->padding1, 0, 4);\n\tmemset(ino->padding2, 0, 26);\n}", "extracted_prediction": "This function zeroes out the unused padding fields of a `struct ubifs_ino_node` by setting all values to zero. The `padding1` field is 4 bytes long, and the `padding2` field is 26 bytes long."}
{"index": 425, "input": "**User**: \nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState)\n{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_FUNCTIONAL_STATE(NewState));\n  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));\n\n  if (NewState != DISABLE)\n  {\n    /* Enable the selected I2C DMA requests */\n    I2Cx->CR1 |= I2C_DMAReq;\n  }\n  else\n  {\n    /* Disable the selected I2C DMA requests */\n    I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;\n  }\n}", "extracted_prediction": "This function, `I2C_DMACmd`, enables or disables I2C DMA requests for a specified I2C peripheral. It first checks the validity of the parameters, then sets the I2C DMA requests based on the `NewState` parameter. If `NewState` is `ENABLE`, it enables the requested DMA requests; otherwise, it disables them."}
{"index": 432, "input": "**User**: \nenum ice_status ice_clear_pf_cfg(struct ice_hw *hw)\n{\n\tstruct ice_aq_desc desc;\n\n\tice_fill_dflt_direct_cmd_desc(&desc, ice_aqc_opc_clear_pf_cfg);\n\n\treturn ice_aq_send_cmd(hw, &desc, NULL, 0, NULL);\n}", "extracted_prediction": "The function `ice_clear_pf_cfg` takes a pointer to an `ice_hw` structure and returns an integer. It fills a default direct command description for `ice_aqc_opc_clear_pf_cfg` and then sends the command using `ice_aq_send_cmd`."}
{"index": 300, "input": "**User**: \nint oshmem_info_finalize(void)\n{\n\n    /* All done -- destroy the table */\n\n    return OSHMEM_SUCCESS;\n}", "extracted_prediction": "The `oshmem_info_finalize` function completes its task by destroying the table it created. It returns `OSHMEM_SUCCESS` as a success indicator."}
{"index": 1, "input": "**User**: \nnilfs_palloc_desc_blkoff(const struct inode *inode, unsigned long group)\n{\n\tunsigned long desc_block =\n\t\tgroup / nilfs_palloc_groups_per_desc_block(inode);\n\treturn desc_block * NILFS_MDT(inode)->mi_blocks_per_desc_block;\n}", "extracted_prediction": "This function calculates the block offset for a descriptor block in a NILFS (Networked Logical File System) file. It divides the group number by the number of groups per descriptor block (`nilfs_palloc_groups_per_desc_block(inode)`) and then multiplies the result by the number of blocks per descriptor block (`NILFS_MDT(inode)->mi_blocks_per_desc_block`). The function returns the calculated block offset."}
{"index": 583, "input": "**User**: \nvoid MsSetThreadSingleCpu()\n{\n\tSetThreadAffinityMask(GetCurrentThread(), 1);\n}", "extracted_prediction": "The `MsSetThreadSingleCpu()` function sets the current thread to run exclusively on a single CPU core."}
{"index": 92, "input": "**User**: \nstatic void local_LZ4_resetStreamHC(void)\n{\n    LZ4_initStreamHC(&LZ4_streamHC, sizeof(LZ4_streamHC));\n}", "extracted_prediction": "This function initializes a local LZ4 stream handle with a size of `sizeof(LZ4_streamHC)`."}
{"index": 485, "input": "**User**: \nvoid gif_create(gif_animation *gif, gif_bitmap_callback_vt *bitmap_callbacks) {\n    memset(gif, 0, sizeof(gif_animation));\n    gif->bitmap_callbacks = *bitmap_callbacks;\n    gif->decoded_frame = GIF_INVALID_FRAME;\n}", "extracted_prediction": "The `gif_create` function initializes a `gif_animation` structure by setting all fields to zero, except for `bitmap_callbacks`, which is copied from the provided `bitmap_callbacks` pointer. The `decoded_frame` is set to `GIF_INVALID_FRAME`, indicating that no frames have been decoded yet."}
{"index": 264, "input": "**User**: \nTIFFCurrentStrip(TIFF* tif)\n{\n\treturn (tif->tif_curstrip);\n}", "extracted_prediction": "This function returns the current strip number of a TIFF file (`tif`)."}
{"index": 319, "input": "**User**: \nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) |\n\t\t\t   DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) &\n\t\t\t   ~(DUPS1_GATING_DIS | DUPS2_GATING_DIS));\n}", "extracted_prediction": "This function, `skl_wa_827`, adjusts the clock gate state for a given pipe on a DRM device. It sets the clock gate for both DUPS1 and DUPS2 to disable if the `enable` parameter is true, and to re-enable them if it's false. The function uses the `I915_WRITE` and `I915_READ` functions to read and write to the appropriate registers on the DRM device."}
{"index": 258, "input": "**User**: \nstatic int vfio_virt_config_write(struct vfio_pci_device *vdev, int pos,\n\t\t\t\t  int count, struct perm_bits *perm,\n\t\t\t\t  int offset, __le32 val)\n{\n\tmemcpy(vdev->vconfig + pos, &val, count);\n\treturn count;\n}", "extracted_prediction": "This function writes a value to a specific position in the virtual configuration of a PCI device. It takes the device, position, count, and a pointer to a `perm_bits` structure that contains the permissions. The function then copies the value into the specified position in the virtual configuration and returns the number of bytes written."}
{"index": 430, "input": "**User**: \nstatic uint8_t keyboard_leds(void) { return keyboard_led_stats; }", "extracted_prediction": "This function returns the current state of the keyboard LEDs, as stored in the `keyboard_led_stats` variable."}
{"index": 519, "input": "**User**: \nxmlSecCryptoAppShutdown(void) {\n    if((xmlSecCryptoDLGetFunctions() == NULL) || (xmlSecCryptoDLGetFunctions()->cryptoAppShutdown == NULL)) {\n        xmlSecNotImplementedError(\"cryptoAppShutdown\");\n        return(-1);\n    }\n\n    return(xmlSecCryptoDLGetFunctions()->cryptoAppShutdown());\n}", "extracted_prediction": "This function checks if the `cryptoAppShutdown` function is available in the `xmlSecCryptoDLGetFunctions` structure. If not, it raises an error and returns -1. If the function is available, it calls it and returns its result."}
{"index": 228, "input": "**User**: \nstatic void vmw_swap_notify(struct ttm_buffer_object *bo)\n{\n\tvmw_bo_swap_notify(bo);\n\t(void) ttm_bo_wait(bo, false, false);\n}", "extracted_prediction": "This function, `vmw_swap_notify`, calls `vmw_bo_swap_notify` on the provided `struct ttm_buffer_object *bo` pointer. Afterward, it waits for the buffer to be swapped out using `ttm_bo_wait`, with the parameters `false` for the first argument (indicating no timeout) and `false` for the second argument (indicating no blocking)."}
{"index": 149, "input": "**User**: \nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\n{\n\tstruct snd_interval t;\n\tt.empty = 0;\n\tt.min = t.max = val;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(i, &t);\n}", "extracted_prediction": "This function sets the interval refinement settings for `i`. It initializes a temporary interval `t` with the given `val` for both `min` and `max`, and sets `openmin` and `openmax` to 0 and `integer` to 1, respectively. It then calls `snd_interval_refine(i, &t)` to apply the refined interval settings to `i`."}
{"index": 522, "input": "**User**: \nvoid sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  pParse->nErr++;\n  sqliteFree(pParse->zErrMsg);\n  va_start(ap, zFormat);\n  pParse->zErrMsg = sqlite3VMPrintf(zFormat, ap);\n  va_end(ap);\n}", "extracted_prediction": "This function, `sqlite3ErrorMsg`, increments the error count for a `Parse` object. It then frees the previous error message and calls `sqlite3VMPrintf` to create a new error message from a format string and arguments. The new message is stored in the `zErrMsg` field of the `Parse` object."}
{"index": 122, "input": "**User**: \nskipbl(void)\n{\n\tint c;\n\n\tif( termch != 0 ){\n\t\tc = termch;\n\t\ttermch = 0;\n\t} else\n\t\tc = inchar();\n\twhile( c == ' ' || c == '\\t' )\n\t\tc = inchar();\n\treturn c;\n}", "extracted_prediction": "The `skipbl` function skips any whitespace characters (' ' or '\\t') from the input buffer `termch`. If `termch` is not empty, it stores the character in `c` and then sets `termch` to 0. If `termch` is empty, it reads the next character from the input buffer and continues to do so until a non-whitespace character is encountered. The function returns the character that was read."}
{"index": 574, "input": "**User**: \npublic_key_t *botan_ed_public_key_adopt(botan_pubkey_t key)\n{\n\tprivate_public_key_t *this;\n\n\tthis = create_empty();\n\tthis->key = key;\n\n\treturn &this->public;\n}", "extracted_prediction": "This function takes a `botan_pubkey_t` object and creates a new `private_public_key_t` object, setting its `key` to the provided `botan_pubkey_t` object. The function then returns a pointer to the `public` field of the newly created `private_public_key_t` object."}
{"index": 704, "input": "**User**: \nbuf_datalen(const buf_t *buf)\n{\n  return buf->datalen;\n}", "extracted_prediction": "This function, `buf_datalen`, retrieves the data length of a buffer pointed to by `buf_t` by returning the value stored in `buf->datalen`."}
{"index": 98, "input": "**User**: \nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\n{\n\tif (!vha->vha_tgt.qla_tgt)\n\t\treturn 0;\n\n\tif (vha->fc_vport) {\n\t\tqlt_release(vha->vha_tgt.qla_tgt);\n\t\treturn 0;\n\t}\n\n\t/* free left over qfull cmds */\n\tqlt_init_term_exchange(vha);\n\n\tql_dbg(ql_dbg_tgt, vha, 0xe03c, \"Unregistering target for host %ld(%p)\",\n\t    vha->host_no, ha);\n\tqlt_release(vha->vha_tgt.qla_tgt);\n\n\treturn 0;\n}", "extracted_prediction": "This function removes a target from a host on a QLogic adapter. It first checks if the target is present and if so, it releases the target. If the FCP Vport is present, it releases the target as well. It then initializes the term exchange and logs a debug message. Finally, it returns 0."}
{"index": 488, "input": "**User**: \nconsole_main(int argc, char *argv[])\n{\n    SDL_SetMainReady();\n\n    /* Run the application main() code */\n    return SDL_main(argc, argv);\n}", "extracted_prediction": "The `console_main` function sets SDL to be ready for use and then calls `SDL_main` with the provided arguments (`argc` and `argv`)."}
{"index": 342, "input": "**User**: \nprocess_syncing_tables(XLogRecPtr current_lsn)\n{\n\tif (am_tablesync_worker())\n\t\tprocess_syncing_tables_for_sync(current_lsn);\n\telse\n\t\tprocess_syncing_tables_for_apply(current_lsn);\n}", "extracted_prediction": "This function checks if the `am_tablesync_worker()` function is currently running. If it is, it calls `process_syncing_tables_for_sync(current_lsn)`. If not, it calls `process_syncing_tables_for_apply(current_lsn)`."}
{"index": 446, "input": "**User**: \nvoid snmp_inc_sysuptime(void)\n{\n  sysuptime++;\n}", "extracted_prediction": "The `snmp_inc_sysuptime` function increments the `sysuptime` variable by one."}
{"index": 157, "input": "**User**: \nUNI_TOKEN_LIST *UniNullToken()\n{\n\tUNI_TOKEN_LIST *ret = ZeroMalloc(sizeof(UNI_TOKEN_LIST));\n\tret->Token = ZeroMalloc(0);\n\n\treturn ret;\n}", "extracted_prediction": "This function allocates memory for a `UNI_TOKEN_LIST` structure and initializes it with a null pointer. It also allocates memory for the `Token` array within the `UNI_TOKEN_LIST` structure and initializes it with a null pointer. The function returns a pointer to the allocated `UNI_TOKEN_LIST` structure."}
{"index": 35, "input": "**User**: \nxfs_ail_max(\n\tstruct xfs_ail  *ailp)\n{\n\tif (list_empty(&ailp->ail_head))\n\t\treturn NULL;\n\n\treturn list_entry(ailp->ail_head.prev, struct xfs_log_item, li_ail);\n}", "extracted_prediction": "This function `xfs_ail_max` checks if the `ailp->ail_head` list is empty. If it is, it returns `NULL`. Otherwise, it returns the last element in the list, which is the maximum `xfs_log_item` in the list."}
{"index": 204, "input": "**User**: \nstatic inline void t_gen_add_flag(TCGv d, int flag)\n{\n    TCGv c;\n\n    c = tcg_temp_new();\n    t_gen_mov_TN_preg(c, PR_CCS);\n    /* Propagate carry into d.  */\n    tcg_gen_andi_tl(c, c, 1 << flag);\n    if (flag) {\n        tcg_gen_shri_tl(c, c, flag);\n    }\n    tcg_gen_add_tl(d, d, c);\n    tcg_temp_free(c);\n}", "extracted_prediction": "This function, `t_gen_add_flag`, takes a TCGv (`TCGv`) and an integer `flag`. It creates a temporary variable `c` and initializes it with a new TCGv. It then moves the contents of `c` into the `PR_CCS` register. It performs a bitwise AND operation between `c` and `c` with the bit set at position `flag` (i.e., `1 << flag`), which propagates the carry into `d`. If `flag` is non-zero, it shifts the result of the AND operation left by `flag` positions and adds it to `d`. Finally, it frees the temporary variable `c`."}
{"index": 253, "input": "**User**: \nGetFdwRoutineByRelId(Oid relid)\n{\n\tOid\t\t\tserverid;\n\n\t/* Get server OID for the foreign table. */\n\tserverid = GetForeignServerIdByRelId(relid);\n\n\t/* Now retrieve server's FdwRoutine struct. */\n\treturn GetFdwRoutineByServerId(serverid);\n}", "extracted_prediction": "The `GetFdwRoutineByRelId` function retrieves a `FdwRoutine` struct based on a foreign table's `relid` OID. It first obtains the `serverid` for the foreign table using `GetForeignServerIdByRelId`. Then, it returns the `FdwRoutine` struct associated with the `serverid`."}
{"index": 477, "input": "**User**: \nstatic int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)\n{\n\tunsigned int i, j;\n\tu8 wwn[8];\n\n\tmemset(wwn, 0, sizeof(wwn));\n\n\t/* Validate and store the new name */\n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tint value;\n\n\t\tvalue = hex_to_bin(*ns++);\n\t\tif (value >= 0)\n\t\t\tj = (j << 4) | value;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t*nm = wwn_to_u64(wwn);\n\treturn 0;\n}", "extracted_prediction": "This function extracts the WWN (World Wide Name) from a new name and stores it in the provided `nm` pointer. It first initializes an array `wwn` with zeros, then iterates over each character of the new name. It converts each hexadecimal character to binary and stores it in the `wwn` array. If a character is invalid, it returns -EINVAL. After processing all characters, it converts the `wwn` array to a 64-bit unsigned integer and stores it in `nm`."}
{"index": 682, "input": "**User**: \nvoid modbus_set_bits_from_byte(uint8_t *dest, int idx, const uint8_t value)\n{\n    int i;\n\n    for (i=0; i < 8; i++) {\n        dest[idx+i] = (value & (1 << i)) ? 1 : 0;\n    }\n}", "extracted_prediction": "This function takes a pointer to a byte (`uint8_t *dest`) and an index (`int idx`) and a value (`const uint8_t value`). It sets the specified index and the following 7 bits of the destination byte to 1 if the corresponding bit in the value is 1, and to 0 if it is 0."}
{"index": 162, "input": "**User**: \nvoid  OS_EventWaitListInit (OS_EVENT *pevent)\n{\n    INT8U  i;\n\n\n    pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */\n    for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {\n        pevent->OSEventTbl[i] = 0u;\n    }\n}", "extracted_prediction": "The `OS_EventWaitListInit` function initializes an event wait list by setting the event group to 0 and clearing the event table with all values set to 0."}
{"index": 756, "input": "**User**: \nsint8 ICACHE_FLASH_ATTR espconn_tcp_set_max_retran(uint8 num)\n{\n\tif (num == 0 || num > 12)\n\t\treturn ESPCONN_ARG;\n\n\tTCP_MAXRTX = num;\n\treturn ESPCONN_OK;\n}", "extracted_prediction": "This function, `espconn_tcp_set_max_retran`, sets the maximum number of retransmissions for TCP connections to the specified value. It returns `ESPCONN_OK` if the value is valid (0 or 12), otherwise it returns `ESPCONN_ARG` if the value is outside the valid range."}
{"index": 33, "input": "**User**: \nsize_t rand_pool_length(RAND_POOL *pool)\n{\n    return pool->len;\n}", "extracted_prediction": "The `rand_pool_length` function returns the length of the `RAND_POOL` structure."}
{"index": 153, "input": "**User**: \ncredential_factory_t *credential_factory_create()\n{\n\tprivate_credential_factory_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.create = _create,\n\t\t\t.create_builder_enumerator = _create_builder_enumerator,\n\t\t\t.add_builder = _add_builder,\n\t\t\t.remove_builder = _remove_builder,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.constructors = linked_list_create(),\n\t\t.recursive = thread_value_create(NULL),\n\t\t.lock = rwlock_create(RWLOCK_TYPE_DEFAULT),\n\t);\n\n\treturn &this->public;\n}", "extracted_prediction": "The function `credential_factory_create` initializes a `private_credential_factory_t` object and returns a pointer to its public interface. The public interface includes methods for creating credentials, creating builder enumerators, adding and removing builders, destroying the factory, and creating a thread-local value and a read-write lock."}
{"index": 585, "input": "**User**: \nstatic const char *yesno(int x)\n{\n\tstatic const char *yes = \"yes\";\n\tstatic const char *no = \"no\";\n\n\treturn x ? yes : no;\n}", "extracted_prediction": "The `yesno` function returns \"yes\" if the integer `x` is non-zero, and \"no\" otherwise."}
{"index": 380, "input": "**User**: \nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}", "extracted_prediction": "This function, `ext4_journalled_invalidatepage`, is a part of the ext4 file system's journaling mechanism. It invalidates a page in the journal, which is used to track metadata changes. The function first checks if the invalidation is successful using `WARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0)`. If the invalidation fails, it reports an error using `WARN_ON`."}
{"index": 391, "input": "**User**: \nstatic u32 vfp_single_fsub(int sd, int sn, s32 m, u32 fpscr)\n{\n\t/*\n\t * Subtraction is addition with one sign inverted.\n\t */\n\treturn vfp_single_fadd(sd, sn, vfp_single_packed_negate(m), fpscr);\n}", "extracted_prediction": "This function performs a single-precision floating-point subtraction by inverting the sign of the second argument and adding it to the first argument. The result is returned."}
{"index": 469, "input": "**User**: \nstatic int load_default_rx_configuration(struct fmdev *fmdev)\n{\n\tint ret;\n\n\tret = fm_rx_set_volume(fmdev, FM_DEFAULT_RX_VOLUME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fm_rx_set_rssi_threshold(fmdev, FM_DEFAULT_RSSI_THRESHOLD);\n}", "extracted_prediction": "This function loads the default RX configuration for a device. It sets the RX volume to the default value and then sets the RSSI threshold to the default value. If either operation fails, the function returns an error code."}
{"index": 199, "input": "**User**: \nvoid matrix_init_user( void ) {\n    matrix_init_keymap();\n}", "extracted_prediction": "The `matrix_init_user` function initializes the keymap for the matrix."}
{"index": 227, "input": "**User**: \nstatic void tun_net_uninit(struct net_device *dev)\n{\n\ttun_detach_all(dev);\n}", "extracted_prediction": "This function, `tun_net_uninit`, uninitializes a network interface by detaching all associated tunnels."}
{"index": 662, "input": "**User**: \nconst char* GetPartitionType(BYTE Type)\n{\n\tint i;\n\tfor (i=0; i<ARRAYSIZE(msdos_systypes); i++) {\n\t\tif (msdos_systypes[i].type == Type)\n\t\t\treturn msdos_systypes[i].name;\n\t}\n\treturn \"Unknown\";\n}", "extracted_prediction": "This function, `GetPartitionType`, takes a byte `Type` as input and returns the corresponding partition type name from the `msdos_systypes` array. If the type is not found in the array, it returns \"Unknown\"."}
{"index": 410, "input": "**User**: \nstatic inline void ocfs2_block_to_cluster_group(struct inode *inode,\n\t\t\t\t\t\tu64 data_blkno,\n\t\t\t\t\t\tu64 *bg_blkno,\n\t\t\t\t\t\tu16 *bg_bit_off)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 data_cluster = ocfs2_blocks_to_clusters(osb->sb, data_blkno);\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\t*bg_blkno = ocfs2_which_cluster_group(inode,\n\t\t\t\t\t      data_cluster);\n\n\tif (*bg_blkno == osb->first_cluster_group_blkno)\n\t\t*bg_bit_off = (u16) data_cluster;\n\telse\n\t\t*bg_bit_off = (u16) ocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t     data_blkno - *bg_blkno);\n}", "extracted_prediction": "This function converts a block number to a cluster group number and bit offset. It first checks if the cluster bitmap is valid. Then, it calculates the cluster group number for the given block number. If the block number is the first cluster group block, it sets the bit offset to the cluster number. Otherwise, it calculates the bit offset by subtracting the current cluster group block number from the given block number and converting it to a 16-bit value."}
{"index": 187, "input": "**User**: \nstatic void free_eq_pages(struct hinic_eq *eq)\n{\n\tstruct hinic_hwif *hwif = eq->hwif;\n\tstruct pci_dev *pdev = hwif->pdev;\n\tint pg;\n\n\tfor (pg = 0; pg < eq->num_pages; pg++)\n\t\tdma_free_coherent(&pdev->dev, eq->page_size,\n\t\t\t\t  eq->virt_addr[pg],\n\t\t\t\t  eq->dma_addr[pg]);\n\n\tdevm_kfree(&pdev->dev, eq->virt_addr);\n\tdevm_kfree(&pdev->dev, eq->dma_addr);\n}", "extracted_prediction": "This function frees the DMA coherent buffers and virtual addresses associated with the PCI device's pages in the HINIC_EQ structure. It iterates over the number of pages, deallocating the DMA addresses and virtual addresses using `dma_free_coherent` and `devm_kfree`, respectively."}
{"index": 479, "input": "**User**: \nLITE_OS_SEC_TEXT VOID osSwTmrAdjust(UINT32 uwsleep_time)\n{\n    if (uwsleep_time > m_pstSwtmrSortList->uwCount)\n    {\n        uwsleep_time = m_pstSwtmrSortList->uwCount;\n    }\n\n    m_pstSwtmrSortList->uwCount -= uwsleep_time;\n\n    if (m_pstSwtmrSortList->uwCount == 0)\n    {\n        osSwTmrTimeoutHandle();\n    }\n}", "extracted_prediction": "This function adjusts the sleep time by subtracting the specified value from the current count in the `m_pstSwtmrSortList`. If the count reaches zero, it triggers the timeout handling function."}
{"index": 257, "input": "**User**: \nreport_error_message(Step *step)\n{\n\tif (step->errormsg)\n\t{\n\t\tfprintf(stdout, \"%s\\n\", step->errormsg);\n\t\tfree(step->errormsg);\n\t\tstep->errormsg = NULL;\n\t}\n}", "extracted_prediction": "This function reports an error message if it exists. If an error message is present, it prints the message to standard output and then frees the memory associated with the error message, setting it to `NULL`."}
{"index": 489, "input": "**User**: \ntcp_kill_timewait(void)\n{\n  struct tcp_pcb *pcb, *inactive;\n  u32_t inactivity;\n\n  inactivity = 0;\n  inactive = NULL;\n  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */\n  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {\n    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {\n      inactivity = tcp_ticks - pcb->tmr;\n      inactive = pcb;\n    }\n  }\n  if (inactive != NULL) {\n    LWIP_DEBUGF(TCP_DEBUG, (\"tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%\"S32_F\")\\n\",\n           (void *)inactive, inactivity));\n    tcp_abort(inactive);\n  }\n}", "extracted_prediction": "The `tcp_kill_timewait` function identifies and terminates the oldest TIME_WAIT state TCP connection in the list. It keeps track of the time elapsed since the connection was in TIME_WAIT state and kills the connection with the oldest time elapsed. If an inactive TIME_WAIT connection is found, it prints a debug message and terminates it."}
{"index": 580, "input": "**User**: \nstatic void initio_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct initio_host *s = (struct initio_host *)host->hostdata;\n\tscsi_remove_host(host);\n\tfree_irq(pdev->irq, host);\n\trelease_region(s->addr, 256);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}", "extracted_prediction": "This function initializes the removal of a device by:\n1. Retrieving the SCSI host data associated with the PCI device.\n2. Removing the SCSI host from the system.\n3. Freeing the IRQ associated with the device.\n4. Releasing the memory region used by the device.\n5. Putting the SCSI host to a put state.\n6. Disabling the PCI device."}
{"index": 168, "input": "**User**: \n__weak void HAL_SMARTCARD_RxCpltCallback(SMARTCARD_HandleTypeDef *hsc)\n{\n  /* Prevent unused argument(s) compilation warning */\n  UNUSED(hsc);\n  /* NOTE : This function Should not be modified, when the callback is needed,\n            the HAL_SMARTCARD_RxCpltCallback could be implemented in the user file\n   */\n}", "extracted_prediction": "This function is a weak reference to the `HAL_SMARTCARD_RxCpltCallback` function, which is intended to be used as a callback for the SmartCard reception completion interrupt. It prevents unused argument compilation warnings and is designed to be used in user code, but it should not be modified as it is part of the HAL library."}
{"index": 663, "input": "**User**: \ncreateTempGistContext(void)\n{\n\treturn AllocSetContextCreate(CurrentMemoryContext,\n\t\t\t\t\t\t\t\t \"GiST temporary context\",\n\t\t\t\t\t\t\t\t ALLOCSET_DEFAULT_SIZES);\n}", "extracted_prediction": "The `createTempGistContext` function allocates a temporary GiST (Generalized Search Tree) context using the current memory context as the base, with the name \"GiST temporary context,\" and sets the default size for the allocated set."}
{"index": 577, "input": "**User**: \nstatic struct lvname *alloc_lvn(struct parsed_partitions *state, u32 lba)\n{\n\tsize_t count = sizeof(struct lvname) * LVM_MAXLVS;\n\tstruct lvname *p;\n\n\tp = kmalloc(count, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) p, count) < count) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}", "extracted_prediction": "This function allocates memory for a maximum of LVM_MAXLVS number of `struct lvname` structures. It uses `kmalloc` to allocate the memory and checks if the allocation was successful. If the allocation fails, it releases the allocated memory and returns `NULL`. If the memory allocation is successful, it proceeds to read the LBA from the specified state and populates the allocated memory with the data. If the read operation fails, it releases the allocated memory and returns `NULL`."}
{"index": 174, "input": "**User**: \nint get_comp() {\n    return comp;\n}", "extracted_prediction": "The `get_comp()` function returns the value of the variable `comp`."}
{"index": 932, "input": "**User**: \nstatic int key_create_persistent_register(struct user_namespace *ns)\n{\n\tstruct key *reg = keyring_alloc(\".persistent_register\",\n\t\t\t\t\tKUIDT_INIT(0), KGIDT_INIT(0),\n\t\t\t\t\tcurrent_cred(),\n\t\t\t\t\t((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t\t KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tns->persistent_keyring_register = reg;\n\treturn 0;\n}", "extracted_prediction": "This function allocates a persistent key registration in the keyring for a given user namespace. It checks for errors and returns the allocated key registration if successful. If an error occurs, it returns the corresponding error code."}
{"index": 176, "input": "**User**: \nstatic void setAlarm(int N){\n#ifdef __unix__\n  alarm(N);\n#else\n  (void)N;\n#endif\n}", "extracted_prediction": "This function sets the alarm for N seconds on Unix-like systems. On other platforms, it does nothing."}
{"index": 610, "input": "**User**: \nstruct pci_dev *pci_dev_get(struct pci_dev *dev)\n{\n\tif (dev)\n\t\tget_device(&dev->dev);\n\treturn dev;\n}", "extracted_prediction": "This function retrieves the device structure for a given `pci_dev` object. If the `dev` parameter is not `NULL`, it calls `get_device` to populate the device structure with the corresponding device information. The function then returns the updated `dev` pointer."}
{"index": 431, "input": "**User**: \nrounddown10(int n)\n{\n    int tens = 0;\n    /* tens = floor(log_10(n)) */\n    while (n >= 10) {\n        n = n / 10;\n        tens++;\n    }\n    /* result = 10**tens */\n    int i, result = 1;\n    for (i = 0; i < tens; i++) {\n        result *= 10;\n    }\n    return result;\n}", "extracted_prediction": "The `rounddown10` function takes an integer `n` and returns a new integer where the last digit is rounded down to the nearest multiple of 10. It does this by first calculating the number of digits in `n` by repeatedly dividing `n` by 10 until `n` is less than 10. Then, it multiplies 10 by the number of digits to get the rounded-down result."}
{"index": 943, "input": "**User**: \nstatic bool SubsdelayIsTextEmpty( const text_segment_t *p_segment )\n{\n    while ( p_segment )\n    {\n        if ( strlen( p_segment->psz_text ) > 0 )\n        {\n            size_t offset = strspn( p_segment->psz_text, \" \" );\n            if ( p_segment->psz_text[offset] )\n                return false;\n        }\n        p_segment = p_segment->p_next;\n    }\n\n    return true;\n}", "extracted_prediction": "This function checks if a `text_segment_t` is empty by iterating through its segments. It returns `true` if the segment is empty (i.e., its text is empty or consists only of spaces), and `false` otherwise."}
{"index": 553, "input": "**User**: \nxmlSecGCryptTransformSha512GetKlass(void) {\n    return(&xmlSecGCryptSha512Klass);\n}", "extracted_prediction": "This function returns a pointer to the `xmlSecGCryptSha512Klass` structure, which likely represents a class or structure used for the GnuTLS library to perform SHA-512 encryption."}
{"index": 769, "input": "**User**: \nadin_sndfile_get_current_filename()\n{\n  return(speechfilename);\n}", "extracted_prediction": "This function returns the current filename of the speech file being processed."}
{"index": 392, "input": "**User**: \nstatic void pcmuio_stop_intr(struct comedi_device *dev,\n\t\t\t     struct comedi_subdevice *s)\n{\n\tstruct pcmuio_private *devpriv = dev->private;\n\tint asic = pcmuio_subdevice_to_asic(s);\n\tstruct pcmuio_asic *chip = &devpriv->asics[asic];\n\n\tchip->enabled_mask = 0;\n\tchip->active = 0;\n\ts->async->inttrig = NULL;\n\n\t/* disable all intrs for this subdev.. */\n\tpcmuio_write(dev, 0, asic, PCMUIO_PAGE_ENAB, 0);\n}", "extracted_prediction": "This function stops an interrupt on a PCMUIO device by clearing the interrupt mask for the specified ASIC and disabling all interrupts for the subdevice."}
{"index": 950, "input": "**User**: \nstatic inline unsigned char parport_ip32_read_status(struct parport *p)\n{\n\tstruct parport_ip32_private * const priv = p->physport->private_data;\n\treturn readb(priv->regs.dsr);\n}", "extracted_prediction": "This function reads the DSR (Data Set Ready) register from the IP32 port specified by `p`. It returns the value of the DSR register as an unsigned char."}
{"index": 893, "input": "**User**: \nstatic int mmc_sd_alive(struct mmc_host *host)\n{\n\treturn mmc_send_status(host->card, NULL);\n}", "extracted_prediction": "This function checks if the MMC/SD card is alive by sending a status command to the card and returning the result."}
{"index": 448, "input": "**User**: \nvoid fscache_mark_pages_cached(struct fscache_retrieval *op,\n\t\t\t       struct pagevec *pagevec)\n{\n\tunsigned long loop;\n\n\tfor (loop = 0; loop < pagevec->nr; loop++)\n\t\tfscache_mark_page_cached(op, pagevec->pages[loop]);\n\n\tpagevec_reinit(pagevec);\n}", "extracted_prediction": "This function iterates over all pages in a `pagevec` and marks them as cached using `fscache_mark_page_cached`. After marking all pages, it reinitializes the `pagevec` structure."}
{"index": 437, "input": "**User**: \nlast_window()\n{\n    return (one_window() && first_tabpage->tp_next == NULL);\n}", "extracted_prediction": "The `last_window()` function checks if there is a window on the first tabpage and if the next tabpage is the last one in the list."}
{"index": 444, "input": "**User**: \nstatic TTree *numtree (lua_State *L, int n) {\n  if (n == 0)\n    return newleaf(L, TTrue);\n  else {\n    TTree *tree, *nd;\n    if (n > 0)\n      tree = nd = newtree(L, 2 * n - 1);\n    else {  /* negative: code it as !(-n) */\n      n = -n;\n      tree = newtree(L, 2 * n);\n      tree->tag = TNot;\n      nd = sib1(tree);\n    }\n    fillseq(nd, TAny, n, NULL);  /* sequence of 'n' any's */\n    return tree;\n  }\n}", "extracted_prediction": "This function creates a new tree structure with a given number of nodes, handling both positive and negative inputs. If `n` is 0, it returns a leaf node. For positive `n`, it creates a new tree and fills it with `n` any nodes. For negative `n`, it creates a tree with double the number of nodes and sets the tree's tag to `TNot`. It then fills the sequence of nodes with `n` any nodes."}
{"index": 138, "input": "**User**: \nstatic bool is_pkcs11_uri(const char *string)\n{\n  if(curl_strnequal(string, \"pkcs11:\", 7)) {\n    return TRUE;\n  }\n  else {\n    return FALSE;\n  }\n}", "extracted_prediction": "The function `is_pkcs11_uri` checks if a given string is a PKCS#11 URI. It returns `TRUE` if the string starts with \"pkcs11:\" (case-insensitive) and ends with a colon, and `FALSE` otherwise."}
{"index": 748, "input": "**User**: \nVOID AsicSetStreamMode(\n\tIN RTMP_ADAPTER *pAd,\n\tIN PUCHAR pMacAddr,\n\tIN INT chainIdx,\n\tIN BOOLEAN bEnabled)\n{\n#ifdef MT_MAC\n\n\tif (IS_HIF_TYPE(pAd, HIF_MT)) {\n\t\tMtAsicSetStreamMode(pAd, pMacAddr, chainIdx, bEnabled);\n\t\treturn;\n\t}\n\n#endif\n\tAsicNotSupportFunc(pAd, __func__);\n}", "extracted_prediction": "The `AsicSetStreamMode` function sets the stream mode for an RTMP adapter. It first checks if the adapter is of type HIF_MT (High-Definition Interactive Framework Media Type) and if so, calls the `MtAsicSetStreamMode` function. If not, it calls `AsicNotSupportFunc` to handle unsupported functions."}
{"index": 231, "input": "**User**: \nvoid test_merge_trees_trivial__initialize(void)\n{\n\trepo = cl_git_sandbox_init(TEST_REPO_PATH);\n}", "extracted_prediction": "The function `test_merge_trees_trivial__initialize` initializes a sandbox for a Git repository at the specified path (`TEST_REPO_PATH`). The repository is initialized with the `cl_git_sandbox_init` function, which is part of the Git C library."}
{"index": 3, "input": "**User**: \nvoid sqlite3SrcListAddAlias(SrcList *pList, Token *pToken){\n  if( pList && pList->nSrc>0 ){\n    pList->a[pList->nSrc-1].zAlias = sqlite3NameFromToken(pToken);\n  }\n}", "extracted_prediction": "This function adds an alias to the end of a `SrcList` if the list is not empty and has more than one source. It retrieves the alias from the token and assigns it to the last source in the list."}
{"index": 28, "input": "**User**: \nstatic int amd76x_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t/* don't need to call pci_enable_device() */\n\treturn amd76x_probe1(pdev, ent->driver_data);\n}", "extracted_prediction": "This function initializes a single AMD76x device by printing a debug message and then calling `amd76x_probe1` with the driver data specified by the `pci_device_id` structure."}
{"index": 831, "input": "**User**: \nbool bdrv_is_first_non_filter(BlockDriverState *candidate)\n{\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    /* walk down the bs forest recursively */\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        bool perm;\n\n        /* try to recurse in this top level bs */\n        perm = bdrv_recurse_is_first_non_filter(bs, candidate);\n\n        /* candidate is the first non filter */\n        if (perm) {\n            bdrv_next_cleanup(&it);\n            return true;\n        }\n    }\n\n    return false;\n}", "extracted_prediction": "This function checks if the `candidate` is the first non-filter in a block driver state forest. It iterates through the forest recursively, attempting to find the first non-filter. If found, it cleans up the iterator and returns `true`. If no non-filter is found, it returns `false`."}
{"index": 729, "input": "**User**: \nxo_style_is_encoding (xo_handle_t *xop)\n{\n    if (xo_style(xop) == XO_STYLE_JSON\n\t|| xo_style(xop) == XO_STYLE_XML\n\t|| xo_style(xop) == XO_STYLE_SDPARAMS\n\t|| xo_style(xop) == XO_STYLE_ENCODER)\n\treturn 1;\n    return 0;\n}", "extracted_prediction": "The function `xo_style_is_encoding` checks if the given `xo_handle_t` object is in one of the encoding styles: JSON, XML, SDPARMS, or ENCODER. It returns `1` if it is one of these styles and `0` otherwise."}
{"index": 145, "input": "**User**: \nstatic KMETHOD KvirSecretGetUsageType(KonohaContext *kctx,  KonohaStack *sfp)\n{\n\tvirSecretPtr arg0 = To_virSecretPtr(sfp[0]);\n\tint ret = virSecretGetUsageType (arg0);\n\tRETURNint(ret);\n}", "extracted_prediction": "This function, `KvirSecretGetUsageType`, takes a `KonohaContext` and a `KonohaStack` pointer as arguments. It converts the first element of the `KonohaStack` to a `virSecretPtr` and then calls the `virSecretGetUsageType` function on that secret. The function returns the result of the `virSecretGetUsageType` call as an integer."}
{"index": 29, "input": "**User**: \nstatic int ks_wlan_config_commit(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *zwrq,\n\t\t\t\t char *extra)\n{\n\tstruct ks_wlan_private *priv = netdev_priv(dev);\n\n\tif (!priv->need_commit)\n\t\treturn 0;\n\n\tks_wlan_setup_parameter(priv, priv->need_commit);\n\tpriv->need_commit = 0;\n\treturn 0;\n}", "extracted_prediction": "This function, `ks_wlan_config_commit`, checks if the wireless device's configuration needs to be committed. If it does not, the function returns 0. If it does, the function sets the configuration parameter to 0 and returns 0."}
{"index": 393, "input": "**User**: \nvoid RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)\n{\n  /* Check the parameters */\n  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));\n\n  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;\n}", "extracted_prediction": "This function configures the I2S clock source by setting the appropriate value in the RCC Configuration Register. It first checks if the provided RCC_I2SCLKSource is valid, then writes the source to the CFGR_I2SSRC_BB register."}
{"index": 358, "input": "**User**: \ndlt_null_proto(tcpeditdlt_t *ctx, const u_char *packet, const int pktlen)\n{\n    assert(ctx);\n    assert(packet);\n    uint32_t *af_type; \n    int protocol = 0;\n\n    if (pktlen < 4)\n        return TCPEDIT_ERROR;\n    \n    af_type = (uint32_t *)packet;\n    if (*af_type == PF_INET || SWAPLONG(*af_type) == PF_INET) {\n        protocol = ETHERTYPE_IP;\n    } else if (*af_type == PF_INET6 || SWAPLONG(*af_type) == PF_INET6) {\n        protocol = ETHERTYPE_IP6;\n    } else {\n        tcpedit_seterr(ctx->tcpedit, \"Unsupported DLT_NULL/DLT_LOOP PF_ type: 0x%04x\", *af_type);\n        return TCPEDIT_ERROR;\n    }\n    \n    return htons(protocol);\n}", "extracted_prediction": "The `dlt_null_proto` function checks if the packet's protocol type is DLT_NULL or DLT_LOOP. If it is, it converts the protocol type to a network byte order and returns it. If the protocol type is not supported, it sets an error and returns TCPEDIT_ERROR."}
{"index": 72, "input": "**User**: \nstatic double poly_basis_dy(ssize_t n, double x, double y)\n{\n  /* polynomial term for y derivative */\n  switch(n) {\n    case  0:  return( 0.0 ); /* constant */\n    case  1:  return( 0.0 );\n    case  2:  return( 1.0 ); /* affine      order = 1   terms = 3 */\n    case  3:  return(  x  ); /* bilinear    order = 1.5 terms = 4 */\n    case  4:  return( 0.0 );\n    case  5:  return(  y  ); /* quadratic   order = 2   terms = 6 */\n    default:  return( poly_basis_dx(n-1,x,y) ); /* weird but true */\n  }\n  /* NOTE: the only reason that last is not true for 'quadratic'\n     is due to the re-arrangement of terms to allow for 'bilinear'\n  */\n}", "extracted_prediction": "The `poly_basis_dy` function calculates the derivative of a polynomial basis function with respect to `y`. The function returns the derivative of the polynomial term for `y` at a given `x` and `y` value. The function uses a switch statement to determine the derivative based on the order of the polynomial. If the order is 0, 1, or 2, the function returns 0. If the order is 3, the function returns `x`. If the order is 4, the function returns 0. If the order is 5, the function returns `y`. For other orders, the function returns the derivative of the polynomial term at the previous order (`n-1`). The function is designed to handle polynomials of any order, but the last case is a special case due to the re-arrangement of terms to allow for the calculation of a bilinear polynomial."}
{"index": 459, "input": "**User**: \nstatic struct tcp_ulp_ops *tcp_ulp_find(const char *name)\n{\n\tstruct tcp_ulp_ops *e;\n\n\tlist_for_each_entry_rcu(e, &tcp_ulp_list, list) {\n\t\tif (strcmp(e->name, name) == 0)\n\t\t\treturn e;\n\t}\n\n\treturn NULL;\n}", "extracted_prediction": "This function searches for a TCP ULP operation named `name` in the `tcp_ulp_list` list. If found, it returns the corresponding pointer to the operation; otherwise, it returns `NULL`."}
{"index": 139, "input": "**User**: \nstatic void ufshcd_async_scan(void *data, async_cookie_t cookie)\n{\n\tstruct ufs_hba *hba = (struct ufs_hba *)data;\n\n\tufshcd_probe_hba(hba);\n}", "extracted_prediction": "This function, `ufshcd_async_scan`, takes a pointer to a `struct ufs_hba` and an `async_cookie_t` as arguments. It initializes the `ufshcd_probe_hba` function to probe the UFS HBA."}
{"index": 363, "input": "**User**: \nstatic struct xol_area *get_xol_area(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct xol_area *area;\n\n\tif (!mm->uprobes_state.xol_area)\n\t\t__create_xol_area(0);\n\n\t/* Pairs with xol_add_vma() smp_store_release() */\n\tarea = READ_ONCE(mm->uprobes_state.xol_area); /* ^^^ */\n\treturn area;\n}", "extracted_prediction": "This function retrieves the `xol_area` for the current process's memory management structure (`mm`). If the `xol_area` is not initialized, it is created using `__create_xol_area(0)`. The function then reads the `xol_area` from the `mm->uprobes_state` and returns it."}
{"index": 454, "input": "**User**: \nbool intel_gvt_in_force_nonpriv_whitelist(struct intel_gvt *gvt,\n\t\t\t\t\t  unsigned int offset)\n{\n\treturn in_whitelist(offset);\n}", "extracted_prediction": "The function `intel_gvt_in_force_nonpriv_whitelist` checks if the specified offset is in the non-privileged whitelist of the `gvt` structure. It returns `true` if the offset is in the whitelist, and `false` otherwise."}
{"index": 295, "input": "**User**: \nstatic void _sba_process_pending_requests(struct sba_device *sba)\n{\n\tint ret;\n\tu32 count;\n\tstruct sba_request *req;\n\n\t/* Process few pending requests */\n\tcount = SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL;\n\twhile (!list_empty(&sba->reqs_pending_list) && count) {\n\t\t/* Get the first pending request */\n\t\treq = list_first_entry(&sba->reqs_pending_list,\n\t\t\t\t       struct sba_request, node);\n\n\t\t/* Try to make request active */\n\t\tif (!_sba_active_request(sba, req))\n\t\t\tbreak;\n\n\t\t/* Send request to mailbox channel */\n\t\tret = sba_send_mbox_request(sba, req);\n\t\tif (ret < 0) {\n\t\t\t_sba_pending_request(sba, req);\n\t\t\tbreak;\n\t\t}\n\n\t\tcount--;\n\t}\n}", "extracted_prediction": "This function processes pending requests from a SBA device. It checks a maximum number of pending requests (SBA_MAX_MSG_SEND_PER_MBOX_CHANNEL) and attempts to make each one active. If an active request is not possible, it sends the request to a mailbox channel. If there is an error sending the request, it is marked as pending again."}
{"index": 194, "input": "**User**: \nstatic void fixup_unlock_powerup_lock(struct mtd_info *mtd)\n{\n\tstruct map_info *map = mtd->priv;\n\tstruct cfi_private *cfi = map->fldrv_priv;\n\tstruct cfi_pri_intelext *cfip = cfi->cmdset_priv;\n\n\tif (cfip->FeatureSupport&32) {\n\t\tprintk(KERN_INFO \"Using auto-unlock on power-up/resume\\n\" );\n\t\tmtd->flags |= MTD_POWERUP_LOCK;\n\t}\n}", "extracted_prediction": "This function checks if the CFI (Calibration Firmware Interface) supports auto-unlock on power-up or resume. If it does, it sets the MTD_POWERUP_LOCK flag on the mtd_info structure to enable auto-unlocking."}
{"index": 436, "input": "**User**: \nvoid* luaR_getmeta(ROTable *rotable) {\n  const TValue *res = luaR_findentry(rotable, NULL, NULL);\n  return res && ttisrotable(res) ? rvalue(res) : NULL;\n}", "extracted_prediction": "This function retrieves the meta-value of a table from the given table (`rotable`). It searches for the meta-value using `luaR_findentry` and returns the value if found and the table is a rotable (`ttisrotable`). If not, it returns `NULL`."}
{"index": 581, "input": "**User**: \nSilcUInt32 silc_hash_block_len(SilcHash hash)\n{\n  return hash->hash->block_len;\n}", "extracted_prediction": "This function, `silc_hash_block_len`, retrieves the block length from a `SilcHash` object. It takes the `SilcHash` hash as an argument and returns the block length associated with it."}
{"index": 724, "input": "**User**: \nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}", "extracted_prediction": "This function removes all groups from a specified kobject by iterating through the provided list of attribute groups and calling `sysfs_remove_group` for each one. If `groups` is `NULL`, the function returns immediately."}
{"index": 984, "input": "**User**: \nHaveNFreeProcs(int n)\n{\n\tPGPROC\t   *proc;\n\n\tSpinLockAcquire(ProcStructLock);\n\n\tproc = ProcGlobal->freeProcs;\n\n\twhile (n > 0 && proc != NULL)\n\t{\n\t\tproc = (PGPROC *) proc->links.next;\n\t\tn--;\n\t}\n\n\tSpinLockRelease(ProcStructLock);\n\n\treturn (n <= 0);\n}", "extracted_prediction": "The `HaveNFreeProcs` function checks if there are at least `n` free procedures in the `ProcGlobal->freeProcs` list. It uses a spinlock to ensure thread safety. The function returns `true` if there are enough free procedures, and `false` otherwise."}
{"index": 411, "input": "**User**: \nexr2vips_vec( im_object *argv )\n{\n\treturn( im_exr2vips( argv[0], argv[1] ) );\n}", "extracted_prediction": "This function, `exr2vips_vec`, takes two arguments, `im_object *argv`, and returns the result of calling `im_exr2vips` with the first argument as the input file name and the second argument as the output file name. The `im_object` type is likely a custom data structure used to represent image or object data, but without more context, it's not clear what this type is."}
{"index": 202, "input": "**User**: \nstatic void __init omap3_ctrl_set_iva_bootmode_idle(void)\n{\n\tomap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,\n\t\t\t OMAP343X_CONTROL_IVA2_BOOTMOD);\n}", "extracted_prediction": "This function initializes the IVA2 boot mode to idle in OMAP343X by writing the boot mode IDLE value to the OMAP3_IVA2_BOOTMOD_IDLE register."}
{"index": 31, "input": "**User**: \nstatic inline int16_t *scalarproduct(const int16_t *in, const int16_t *endin, int16_t *out)\n{\n    int32_t sample;\n    int16_t j;\n\n    while (in < endin) {\n        sample = 0;\n        for (j = 0; j < NUMTAPS; j++)\n            sample += in[j] * filt[j];\n        *out = av_clip_int16(sample >> 6);\n        out++;\n        in++;\n    }\n\n    return out;\n}", "extracted_prediction": "This function performs a scalar product on a set of samples using a filter. It iterates through each sample, multiplying it by the corresponding filter coefficient and accumulating the results. The final result is clipped and stored in the output array. The function returns the pointer to the output array."}
{"index": 237, "input": "**User**: \nstatic char* CFArrayALPNCopyFirst(CFArrayRef alpnArray)\n{\n    CFIndex count = CFArrayGetCount(alpnArray);\n\n    if (count <= 0)\n        return NULL;\n\n    CFStringRef alpnVal = CFArrayGetValueAtIndex(alpnArray, 0);\n    return FromCFString(alpnVal, kCFStringEncodingASCII);\n}", "extracted_prediction": "This function copies the first element of a CFArray containing ALPN (Application Layer Protocol Negotiation) values and returns a static char* string. If the array is empty or null, it returns NULL. The function converts the CFString to ASCII encoding."}
{"index": 26, "input": "**User**: \nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}", "extracted_prediction": "This function retrieves the UUID of a hard disk by its location within a VBox snapshot configuration. It iterates through the machine's media registry to find the matching disk, then returns the UUID if found. If no disk is found, it returns NULL."}
{"index": 11, "input": "**User**: \nstatic enum ap_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_WAIT_NONE;\n}", "extracted_prediction": "This function, `ap_sm_nop`, returns `AP_WAIT_NONE` when called. It is a static function that is part of the `ap_queue` structure."}
{"index": 508, "input": "**User**: \nstatic void list_splice_entire_tail(struct list_head *from,\n\t\t\t\t    struct list_head *to)\n{\n\tstruct list_head *from_last = from->prev;\n\n\tlist_splice_tail(from_last, to);\n\tlist_add_tail(from_last, to);\n}", "extracted_prediction": "This function splices the entire tail of the list pointed by `from` to the beginning of the list pointed by `to`. It first finds the last element of the `from` list (`from_last`) and then uses `list_splice_tail` to move the end of the `from` list to the beginning of the `to` list. Finally, it adds the `from_last` element to the end of the `to` list."}
{"index": 546, "input": "**User**: \nstatic inline void kasan_free_nondeferred_pages(struct page *page, int order)\n{\n\tif (!static_branch_unlikely(&deferred_pages))\n\t\tkasan_free_pages(page, order);\n}", "extracted_prediction": "This function checks if the `deferred_pages` branch is not taken. If not, it calls `kasan_free_pages` to free the pages."}
{"index": 24, "input": "**User**: \nstatic int pnv_eeh_configure_bridge(struct eeh_pe *pe)\n{\n\treturn 0;\n}", "extracted_prediction": "This function, `pnv_eeh_configure_bridge`, takes a pointer to an `eeh_pe` structure and returns 0."}
{"index": 244, "input": "**User**: \nstatic int wacom_calc_hid_res(int logical_extents, int physical_extents,\n\t\t\t       unsigned unit, int exponent)\n{\n\tstruct hid_field field = {\n\t\t.logical_maximum = logical_extents,\n\t\t.physical_maximum = physical_extents,\n\t\t.unit = unit,\n\t\t.unit_exponent = exponent,\n\t};\n\n\treturn hidinput_calc_abs_res(&field, ABS_X);\n}", "extracted_prediction": "This function calculates the absolute resolution of a Wacom tablet using the provided logical and physical extent sizes, unit, and exponent. It returns the calculated resolution in pixels."}
