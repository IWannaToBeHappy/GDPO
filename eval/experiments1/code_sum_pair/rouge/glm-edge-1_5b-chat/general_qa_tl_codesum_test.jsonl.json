{"index": 479, "input": "**User**: \npublic GT_MetaGenerated_Item(String aUnlocalized,short aOffset,short aItemAmount){\n  super(aUnlocalized);\n  setCreativeTab(GregTech_API.TAB_GREGTECH_MATERIALS);\n  setHasSubtypes(true);\n  setMaxDamage(0);\n  mEnabledItems=new BitSet(aItemAmount);\n  mVisibleItems=new BitSet(aItemAmount);\n  mOffset=(short)Math.min(32766,aOffset);\n  mItemAmount=(short)Math.min(aItemAmount,32766 - mOffset);\n  mIconList=new IIcon[aItemAmount][1];\n  sInstances.put(getUnlocalizedName(),this);\n}\n", "extracted_prediction": "This code initializes a `GT_MetaGenerated_Item` with a given unlocalized name, offset, and item amount. It sets the item's creative tab to `GregTech_API.TAB_GREGTECH_MATERIALS`, enables subtypes, sets a maximum damage value to 0, and creates two `BitSet` instances for items that are enabled and visible. It also sets the offset and item amount, ensuring they are within the range of 32766. The item has an array of `IIcon` instances corresponding to the item amount, and a `sInstances` map is used to store the item's instance."}
{"index": 753, "input": "**User**: \nprivate void updateActions(final INaviAddressSpace addressSpace){\n  m_loadAddressSpaceAction.setEnabled(!addressSpace.isLoaded());\n}\n", "extracted_prediction": "The `updateActions` method sets the enabled state of the `m_loadAddressSpaceAction` to `true` if the `addressSpace` is not loaded, and `false` otherwise."}
{"index": 63, "input": "**User**: \nprivate static int encodeText(CharSequence msg,int startpos,int count,StringBuilder sb,int initialSubmode){\n  StringBuilder tmp=new StringBuilder(count);\n  int submode=initialSubmode;\n  int idx=0;\n  while (true) {\n    char ch=msg.charAt(startpos + idx);\nswitch (submode) {\ncase SUBMODE_ALPHA:\n      if (isAlphaUpper(ch)) {\n        if (ch == ' ') {\n          tmp.append((char)26);\n        }\n else {\n          tmp.append((char)(ch - 65));\n        }\n      }\n else {\n        if (isAlphaLower(ch)) {\n          submode=SUBMODE_LOWER;\n          tmp.append((char)27);\n          continue;\n        }\n else         if (isMixed(ch)) {\n          submode=SUBMODE_MIXED;\n          tmp.append((char)28);\n          continue;\n        }\n else {\n          tmp.append((char)29);\n          tmp.append((char)PUNCTUATION[ch]);\n          break;\n        }\n      }\n    break;\ncase SUBMODE_LOWER:\n  if (isAlphaLower(ch)) {\n    if (ch == ' ') {\n      tmp.append((char)26);\n    }\n else {\n      tmp.append((char)(ch - 97));\n    }\n  }\n else {\n    if (isAlphaUpper(ch)) {\n      tmp.append((char)27);\n      tmp.append((char)(ch - 65));\n      break;\n    }\n else     if (isMixed(ch)) {\n      submode=SUBMODE_MIXED;\n      tmp.append((char)28);\n      continue;\n    }\n else {\n      tmp.append((char)29);\n      tmp.append((char)PUNCTUATION[ch]);\n      break;\n    }\n  }\nbreak;\ncase SUBMODE_MIXED:\nif (isMixed(ch)) {\ntmp.append((char)MIXED[ch]);\n}\n else {\nif (isAlphaUpper(ch)) {\n  submode=SUBMODE_ALPHA;\n  tmp.append((char)28);\n  continue;\n}\n else if (isAlphaLower(ch)) {\n  submode=SUBMODE_LOWER;\n  tmp.append((char)27);\n  continue;\n}\n else {\n  if (startpos + idx + 1 < count) {\n    char next=msg.charAt(startpos + idx + 1);\n    if (isPunctuation(next)) {\n      submode=SUBMODE_PUNCTUATION;\n      tmp.append((char)25);\n      continue;\n    }\n  }\n  tmp.append((char)29);\n  tmp.append((char)PUNCTUATION[ch]);\n}\n}\nbreak;\ndefault :\nif (isPunctuation(ch)) {\ntmp.append((char)PUNCTUATION[ch]);\n}\n else {\nsubmode=SUBMODE_ALPHA;\ntmp.append((char)29);\ncontinue;\n}\n}\nidx++;\nif (idx >= count) {\nbreak;\n}\n}\nchar h=0;\nint len=tmp.length();\nfor (int i=0; i < len; i++) {\nboolean odd=(i % 2) != 0;\nif (odd) {\nh=(char)((h * 30) + tmp.charAt(i));\nsb.append(h);\n}\n else {\nh=tmp.charAt(i);\n}\n}\nif ((len % 2) != 0) {\nsb.append((char)((h * 30) + 29));\n}\nreturn submode;\n}\n", "extracted_prediction": "This code snippet is a function that encodes a given text message into a specific format based on a submode. The function `encodeText` takes several parameters, including the text message (`msg`), the starting position (`startpos`), the count of characters to process (`count`), a `StringBuilder` (`sb`) to store the encoded text, and an initial submode (`initialSubmode`).\n\nThe function uses a `StringBuilder` to build the encoded text. It iterates through the text message, switching between different submodes based on the character's type (alpha, lowercase, mixed, punctuation). Each character is processed according to the submode, and the result is appended to the `StringBuilder`.\n\nThe function also checks for punctuation and converts it to a specific character. It then calculates the hash value of the `StringBuilder` and appends it to the encoded text. Finally, the function returns the current submode.\n\nPlease note that the code snippet provided is incomplete and may require additional context or clarification to fully understand its functionality."}
{"index": 603, "input": "**User**: \nprivate SharedDeployment createNewDeployment(GridDeploymentMetadata meta,boolean isCache){\n  assert Thread.holdsLock(mux);\n  assert meta.parentLoader() == null;\n  IgniteUuid ldrId=IgniteUuid.fromUuid(ctx.localNodeId());\n  GridDeploymentClassLoader clsLdr;\n  if (meta.deploymentMode() == CONTINUOUS || meta.participants() == null) {\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,ctx.config().getClassLoader() != null ? ctx.config().getClassLoader() : U.gridClassLoader(),meta.classLoaderId(),meta.senderNodeId(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),meta.deploymentMode() == CONTINUOUS,false);\n    if (meta.participants() != null)     for (    Map.Entry<UUID,IgniteUuid> e : meta.participants().entrySet())     clsLdr.register(e.getKey(),e.getValue());\n    if (log.isDebugEnabled())     log.debug(\"Created class loader in CONTINUOUS mode or without participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ ']');\n  }\n else {\n    assert meta.deploymentMode() == SHARED;\n    clsLdr=new GridDeploymentClassLoader(ldrId,meta.userVersion(),meta.deploymentMode(),false,ctx,U.gridClassLoader(),meta.participants(),comm,ctx.config().getNetworkTimeout(),log,ctx.config().getPeerClassLoadingLocalClassPathExclude(),ctx.config().getPeerClassLoadingMissedResourcesCacheSize(),false,false);\n    if (log.isDebugEnabled())     log.debug(\"Created classloader in SHARED mode with participants \" + \"[ldr=\" + clsLdr + \", meta=\"+ meta+ ']');\n  }\n  SharedDeployment dep=new SharedDeployment(meta.deploymentMode(),clsLdr,ldrId,meta.userVersion(),meta.alias());\n  if (log.isDebugEnabled())   log.debug(\"Created new deployment: \" + dep);\n  if (isCache) {\n    List<SharedDeployment> deps=F.addIfAbsent(cache,meta.userVersion(),new LinkedList<SharedDeployment>());\n    assert deps != null;\n    deps.add(dep);\n    if (log.isDebugEnabled())     log.debug(\"Added deployment to cache: \" + cache);\n  }\n  return dep;\n}\n", "extracted_prediction": "This code snippet defines a method `createNewDeployment` that creates a new `SharedDeployment` object based on provided `GridDeploymentMetadata` and a boolean flag `isCache`. Here's a concise summary:\n\n- The method first checks if the current thread holds a lock on the `mux`.\n- It verifies that the `meta.parentLoader()` is `null`.\n- It retrieves the local node's `IgniteUuid` and creates a `GridDeploymentClassLoader` based on the provided `meta` parameters.\n- If the `meta.deploymentMode()` is `CONTINUOUS` or `null`, it registers the participants and logs the creation.\n- If the `meta.deploymentMode()` is `SHARED`, it creates a `GridDeploymentClassLoader` with the specified `meta.participants` and logs the creation.\n- A new `SharedDeployment` object is created with the `meta` parameters and is added to the cache if `isCache` is `true`.\n- The method returns the newly created `SharedDeployment` object."}
{"index": 712, "input": "**User**: \npublic ByteMatrix encode(String contents,int width,int height,Map<EncodeHintType,Object> hints) throws WriterException {\n  if (contents == null || contents.length() == 0) {\n    throw new IllegalArgumentException(\"Found empty contents\");\n  }\n  if (width < 0 || height < 0) {\n    throw new IllegalArgumentException(\"Requested dimensions are too small: \" + width + 'x'+ height);\n  }\n  ErrorCorrectionLevel errorCorrectionLevel=ErrorCorrectionLevel.L;\n  if (hints != null) {\n    ErrorCorrectionLevel requestedECLevel=(ErrorCorrectionLevel)hints.get(EncodeHintType.ERROR_CORRECTION);\n    if (requestedECLevel != null) {\n      errorCorrectionLevel=requestedECLevel;\n    }\n  }\n  QRCode code=new QRCode();\n  Encoder.encode(contents,errorCorrectionLevel,hints,code);\n  return renderResult(code,width,height);\n}\n", "extracted_prediction": "This method encodes a given string into a QR code image. It throws an exception if the input string is null or empty, or if the requested dimensions are too small. It also takes an optional map of hints that can influence the encoding process. The method returns a rendered result of the QR code image."}
{"index": 274, "input": "**User**: \npublic boolean isPronoun(){\n  return typeString.contains(SUFFIX_PRONOUN);\n}\n", "extracted_prediction": "The `isPronoun` method checks if the given string contains the suffix `PRONOUN`."}
{"index": 229, "input": "**User**: \nprivate void checkInteriorIntersections(){\n  for (Iterator i=segStrings.iterator(); i.hasNext(); ) {\n    SegmentString ss0=(SegmentString)i.next();\n    for (Iterator j=segStrings.iterator(); j.hasNext(); ) {\n      SegmentString ss1=(SegmentString)j.next();\n      checkInteriorIntersections(ss0,ss1);\n    }\n  }\n}\n", "extracted_prediction": "The `checkInteriorIntersections` method iterates over a list of `SegmentString` objects, calling itself recursively to check for intersections between each pair of segments."}
{"index": 215, "input": "**User**: \npublic void mouseClicked(MouseEvent e){\n  if (e.getClickCount() > 1) {\n    System.gc();\n  }\n}\n", "extracted_prediction": "The `mouseClicked` method checks if the mouse event has a click count greater than 1. If so, it performs a `System.gc()` to potentially free up memory."}
{"index": 373, "input": "**User**: \n@Override public void mousePressed(MouseEvent e){\n  m_frameLimiter.setRepeats(true);\n  if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0 && !e.isAltDown() && m_mouseState == 0 && m_scaling == 0) {\n    if (((e.getModifiers() & InputEvent.CTRL_MASK) != 0) && ((e.getModifiers() & InputEvent.SHIFT_MASK) == 0)) {\n      m_mouseState=2;\n    }\n else     if (((e.getModifiers() & InputEvent.SHIFT_MASK) != 0) && ((e.getModifiers() & InputEvent.CTRL_MASK) == 0)) {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=3;\n      Graphics g=getGraphics();\n      if (m_ZoomBoxColor == null) {\n        g.setColor(Color.black);\n      }\n else {\n        g.setColor(m_ZoomBoxColor);\n      }\n      if (m_ZoomBoxXORColor == null) {\n        g.setXORMode(Color.white);\n      }\n else {\n        g.setXORMode(m_ZoomBoxXORColor);\n      }\n      g.drawRect(m_oldMousePos.width,m_oldMousePos.height,m_newMousePos.width - m_oldMousePos.width,m_newMousePos.height - m_oldMousePos.height);\n      g.dispose();\n    }\n else {\n      m_oldMousePos.width=e.getX();\n      m_oldMousePos.height=e.getY();\n      m_newMousePos.width=e.getX();\n      m_newMousePos.height=e.getY();\n      m_mouseState=1;\n      m_frameLimiter.start();\n    }\n  }\n else   if ((e.getButton() == MouseEvent.BUTTON1) && e.isAltDown() && e.isShiftDown()&& !e.isControlDown()) {\n    saveComponent();\n  }\n else   if (m_mouseState == 0 && m_scaling == 0) {\n  }\n}\n", "extracted_prediction": "The provided code snippet is a method in a Java class that handles mouse events. Here's a concise summary:\n\n- The method `mousePressed` is overridden to respond to mouse press events.\n- It sets the frame limiter to allow repeated mouse presses.\n- It checks if the mouse state is 0, scaling is 0, and the modifier keys (e.g., Ctrl, Shift, Alt) are not pressed.\n- If the conditions are met, it determines the mouse state based on the modifier keys pressed:\n  - If Ctrl and Shift are pressed but Alt is not, the mouse state is set to 2.\n  - If Shift and Ctrl are pressed but Alt is not, the mouse state is set to 3.\n- It stores the old mouse position and updates the new mouse position.\n- It sets the color of the graphics context based on the ZoomBoxColor and ZoomBoxXORColor variables.\n- It draws a rectangle on the component if the mouse state is 3.\n- It starts the frame limiter if the mouse state is 1.\n- If no modifier keys are pressed, the mouse state remains 0, and the frame limiter is not started.\n\nThis method is used to handle mouse interactions and update the state of the application based on the mouse press event."}
{"index": 874, "input": "**User**: \nprotected ArrayList<KeyNamePair> loadRMAData(int C_BPartner_ID){\n  ArrayList<KeyNamePair> list=new ArrayList<KeyNamePair>();\n  String sqlStmt=\"SELECT r.M_RMA_ID, r.DocumentNo || '-' || r.Amt from M_RMA r \" + \"WHERE ISSOTRX='N' AND r.DocStatus in ('CO', 'CL') \" + \"AND r.C_BPartner_ID=? \"+ \"AND NOT EXISTS (SELECT * FROM C_Invoice inv \"+ \"WHERE inv.M_RMA_ID=r.M_RMA_ID AND inv.DocStatus IN ('CO', 'CL'))\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sqlStmt,null);\n    pstmt.setInt(1,C_BPartner_ID);\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      list.add(new KeyNamePair(rs.getInt(1),rs.getString(2)));\n    }\n    rs.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sqlStmt.toString(),e);\n  }\n finally {\n    if (pstmt != null) {\n      try {\n        pstmt.close();\n      }\n catch (      Exception ex) {\n        log.severe(\"Could not close prepared statement\");\n      }\n    }\n  }\n  return list;\n}\n", "extracted_prediction": "This method `loadRMAData` retrieves RMA data for a specified `C_BPartner_ID`. It executes a SQL query to select RMA IDs and document numbers from `M_RMA` table, excluding RMA IDs that are associated with invoices in the `CO` or `CL` status. The data is stored in an `ArrayList<KeyNamePair>` and returned. The code uses a `PreparedStatement` to execute the query safely, and it logs any SQL exceptions. It also ensures that the prepared statement is closed properly, even if an error occurs."}
{"index": 560, "input": "**User**: \npublic SessionWrapper(Session ses){\n  this.ses=ses;\n  this.time=System.currentTimeMillis();\n}\n", "extracted_prediction": "This code snippet creates a `SessionWrapper` class that initializes a `Session` object with a given `ses` parameter. It also records the current time in milliseconds using `System.currentTimeMillis()` as the `time` variable."}
{"index": 244, "input": "**User**: \npublic void closeCursor(Cursor cursor){\n  cursor.close();\n  cursorMap.remove(Integer.valueOf(cursor.getCursorId()));\n}\n", "extracted_prediction": "The `closeCursor` method closes a `Cursor` object and removes it from a map if it has a specific `CursorId`."}
{"index": 96, "input": "**User**: \n@Override public String expect(Pattern pattern){\n  final String token=read(pattern);\n  if (token == null) {\n    throw new ParserException(\"Expected pattern '\" + pattern.pattern() + \"' was not encountered in document: \"+ document);\n  }\n  return token;\n}\n", "extracted_prediction": "This method overrides the `expect` method in a `Parser` class. It reads a pattern from the document and returns it if found. If the pattern is not found, it throws a `ParserException`. The method uses the `pattern.pattern()` method to get the pattern's name."}
{"index": 823, "input": "**User**: \n@Override public final char readChar() throws IOException {\n  dis.readFully(work,0,2);\n  return (char)((work[1] & 0xff) << 8 | (work[0] & 0xff));\n}\n", "extracted_prediction": "This method reads a single character from the input stream `dis` by first reading 2 bytes into the `work` array. It then converts the first byte to a 16-bit integer, the second byte to a 8-bit integer, and combines them to form a single 16-bit integer. Finally, it converts the 16-bit integer back to a character by shifting the 8-bit integer left by 8 bits and combining it with the 8-bit integer from the first byte."}
{"index": 278, "input": "**User**: \npublic void update(){\n  if (lastTime != -1L) {\n    long delta=System.nanoTime() - lastTime;\n    rollingAverage.addValue(delta);\n  }\n  lastTime=System.nanoTime();\n}\n", "extracted_prediction": "The `update()` method updates the rolling average by adding the current time to the existing sum and subtracting the previous time. If the previous time is not -1 (indicating that the rolling average has been computed before), it calculates the difference between the current and previous times in nanoseconds and adds it to the sum. It then updates the `lastTime` variable with the current time."}
{"index": 125, "input": "**User**: \n@Override public void onAdded(final RPObject object){\n  if (isUser(object)) {\n    if (object.has(\"adminlevel\")) {\n      adminlevel=object.getInt(\"adminlevel\");\n    }\n  }\n}\n", "extracted_prediction": "Sure, here's a concise summary of the provided code snippet:\n\n```java\npublic void onAdded(RPObject object) {\n  if (isUser(object)) {\n    if (object.has(\"adminlevel\")) {\n      adminlevel = object.getInt(\"adminlevel\");\n    }\n  }\n}\n```\n\nThis method, `onAdded`, is overridden to handle the addition of a new object. It checks if the object is a user and, if so, retrieves the 'adminlevel' property from the object and assigns it to the variable `adminlevel`."}
{"index": 995, "input": "**User**: \nprivate void fillPicks() throws Exception {\n  MLookup orgL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2223,DisplayType.TableDir);\n  fWarehouse=new VLookup(\"M_Warehouse_ID\",true,false,true,orgL);\n  lWarehouse.setText(Msg.translate(Env.getCtx(),\"M_Warehouse_ID\"));\n  fWarehouse.addVetoableChangeListener(this);\n  m_M_Warehouse_ID=fWarehouse.getValue();\n  MLookup bpL=MLookupFactory.get(Env.getCtx(),m_WindowNo,0,2762,DisplayType.Search);\n  fBPartner=new VLookup(\"C_BPartner_ID\",false,false,true,bpL);\n  lBPartner.setText(Msg.translate(Env.getCtx(),\"C_BPartner_ID\"));\n  fBPartner.addVetoableChangeListener(this);\n  lDocType.setText(Msg.translate(Env.getCtx(),\"C_DocType_ID\"));\n  cmbDocType.addItem(new KeyNamePair(MOrder.Table_ID,Msg.translate(Env.getCtx(),\"Order\")));\n  cmbDocType.addItem(new KeyNamePair(MRMA.Table_ID,Msg.translate(Env.getCtx(),\"VendorRMA\")));\n  cmbDocType.addActionListener(this);\n}\n", "extracted_prediction": "The `fillPicks` method populates the `fWarehouse` and `fBPartner` fields with values from the respective MLookup objects. It also sets the text labels for these fields and adds VetoableChange listeners to capture any changes. The `cmbDocType` is populated with key-value pairs representing different document types, with their translations displayed in the labels. The method concludes by adding an action listener to the `cmbDocType` for handling selection changes."}
{"index": 127, "input": "**User**: \npublic void pathValuesToPixel(List<Path> paths){\n  for (int i=0; i < paths.size(); i++) {\n    pathValueToPixel(paths.get(i));\n  }\n}\n", "extracted_prediction": "The `pathValuesToPixel` method takes a list of `Path` objects and iterates over them, calling the `pathValueToPixel` method for each path."}
{"index": 182, "input": "**User**: \npublic void test_DivideBigDecimalRoundingModeHALF_UP(){\n  String a=\"3736186567876876578956958765675671119238118911893939591735\";\n  String b=\"74723342238476237823787879183470\";\n  RoundingMode rm=RoundingMode.HALF_UP;\n  String c=\"50000260373164286401361913\";\n  BigDecimal aNumber=new BigDecimal(new BigInteger(a));\n  BigDecimal bNumber=new BigDecimal(new BigInteger(b));\n  BigDecimal result=aNumber.divide(bNumber,rm);\n  assertEquals(\"incorrect value\",c,result.toString());\n}\n", "extracted_prediction": "The test_DivideBigDecimalRoundingModeHALF_UP method tests the division of two large numbers using the HALF_UP rounding mode. It creates two large strings representing the numbers, converts them to BigDecimal objects, performs the division, and then asserts that the result matches a predefined string. If the result does not match, an assertion error is thrown."}
{"index": 77, "input": "**User**: \n@SuppressWarnings(\"unchecked\") public static <E extends Enum<? extends Style.HasCssName>>E fromStyleName(final String styleName,final Class<E> enumClass,final E defaultValue){\n  if (styleName == null || enumClass == null) {\n    return defaultValue;\n  }\n  for (  final Enum<? extends Style.HasCssName> constant : enumClass.getEnumConstants()) {\n    final Style.HasCssName anEnum=(Style.HasCssName)constant;\n    final String cssClass=anEnum.getCssName();\n    if (cssClass != null && StyleHelper.containsStyle(styleName,cssClass)) {\n      return (E)anEnum;\n    }\n  }\n  return defaultValue;\n}\n", "extracted_prediction": "This code snippet defines a method `fromStyleName` that takes a `String` representing a style name, a `Class` that extends an `Enum` representing a style, and a `defaultValue` to return if no matching style is found. It checks if the provided `styleName` and `enumClass` are `null`, and if not, iterates over the constants of the `enumClass` to find an `Enum` that matches the `styleName`. If a match is found, it returns the corresponding `E` instance; otherwise, it returns the `defaultValue`. If no match is found, it returns the `defaultValue`."}
{"index": 780, "input": "**User**: \n@Override public void listVolumes(CommandInput input,CompletionHandler completionHandler){\n  createOrUpdateTargetSsl(input);\n  URI uri=UriUtils.extendUri(input.getDockerUri(),\"/volumes\");\n  sendGet(uri,null,completionHandler);\n}\n", "extracted_prediction": "The code snippet overrides the `listVolumes` method in a class that handles commands. It first calls `createOrUpdateTargetSsl` to set up the necessary SSL context for the target Docker container. Then, it constructs a new URI by appending \"/volumes\" to the input's Docker URI. Finally, it sends a GET request to this URI with an empty body, passing the completion handler to handle the response."}
{"index": 349, "input": "**User**: \npublic static double sqrt(double x){\n  return Math.sqrt(x);\n}\n", "extracted_prediction": "The provided code snippet defines a public static method named `sqrt` that takes a `double` parameter `x`. It returns the square root of `x` using the `Math.sqrt` method."}
{"index": 491, "input": "**User**: \npublic static void println(Object x){\n  out.println(x);\n}\n", "extracted_prediction": "The `println` method in Java prints the specified `Object` to the standard output (console) and a newline character."}
{"index": 332, "input": "**User**: \nprivate static String forceNumberStringToTwoDigits(String text){\n  while (text.length() < 2) {\n    text=\"0\" + text;\n  }\n  if (text.length() > 2) {\n    text=text.substring(text.length() - 2,text.length());\n  }\n  return text;\n}\n", "extracted_prediction": "This method, `forceNumberStringToTwoDigits`, takes a `String` as input and ensures that it is always two digits long. If the input string is less than two characters, it is prepended with zeros. If the string is already two or more characters long, it only retains the last two characters. The method returns the modified string."}
{"index": 64, "input": "**User**: \npublic static boolean isValidNCName(String ncName){\n  if (ncName.length() == 0)   return false;\n  char ch=ncName.charAt(0);\n  if (isNCNameStart(ch) == false)   return false;\n  for (int i=1; i < ncName.length(); i++) {\n    ch=ncName.charAt(i);\n    if (isNCName(ch) == false) {\n      return false;\n    }\n  }\n  return true;\n}\n", "extracted_prediction": "The `isValidNCName` method checks if a given `ncName` is a valid NCName. It returns `true` if the `ncName` is not empty and if it starts with a valid character according to the rules of an NCName. If any character in the `ncName` does not conform to the NCName rules, the method returns `false`."}
{"index": 86, "input": "**User**: \n@Override public void draw(Canvas canvas){\n  super.draw(canvas);\n  if (mEdgeGlowTop != null) {\n    final int scrollX=getScrollX();\n    if (!mEdgeGlowTop.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.top + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.bottom + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      int edgeX=Math.min(0,scrollX + mFirstPositionDistanceGuess);\n      canvas.rotate(-90);\n      canvas.translate(-getHeight() + topPadding,edgeX);\n      mEdgeGlowTop.setSize(height,height);\n      if (mEdgeGlowTop.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n    if (!mEdgeGlowBottom.isFinished()) {\n      final int restoreCount=canvas.save();\n      final int topPadding=mListPadding.left + mGlowPaddingTop;\n      final int bottomPadding=mListPadding.right + mGlowPaddingBottom;\n      final int height=getHeight() - topPadding - bottomPadding;\n      final int width=getWidth();\n      int edgeX=Math.max(width,scrollX + mLastPositionDistanceGuess);\n      canvas.rotate(90);\n      canvas.translate(-topPadding,-edgeX);\n      mEdgeGlowBottom.setSize(height,height);\n      if (mEdgeGlowBottom.draw(canvas)) {\n        invalidate();\n      }\n      canvas.restoreToCount(restoreCount);\n    }\n  }\n}\n", "extracted_prediction": "This code snippet overrides the `draw` method in a custom view to draw an edge glow effect on the top and bottom edges of a list. It first checks if the edge glow is not finished and, if so, it calculates the necessary translation and rotation to draw the glow. It then sets the size of the edge glow and calls the `draw` method to draw it. If the edge glow is finished, it checks if the edge glow is not finished again and, if so, it calculates the necessary translation and rotation to draw the glow. It then sets the size of the edge glow and calls the `draw` method to draw it. If the edge glow is finished, it invalidates the view to update the drawing."}
{"index": 650, "input": "**User**: \npublic FieldFrameBodyIMG(Lyrics3Image image){\n  images.add(image);\n}\n", "extracted_prediction": "This method initializes a new instance of `FieldFrameBodyIMG` with a list of `Lyrics3Image` objects."}
{"index": 262, "input": "**User**: \npublic byte[] encode1(final String s){\n  final ByteArrayBuffer tmp=new ByteArrayBuffer(s.length());\n  final int nwritten=uc.encode(s,tmp);\n  final int npack=LongPacker.getByteLength(nwritten);\n  final byte[] a=new byte[npack + nwritten];\n  final DataOutputBuffer dob=new DataOutputBuffer(0,a);\n  try {\n    dob.packLong(nwritten);\n    dob.append(tmp.array(),0,tmp.pos());\n    return a;\n  }\n  finally {\n    try {\n      dob.close();\n    }\n catch (    IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n}\n", "extracted_prediction": "This code snippet defines a method `encode1` that takes a `String` as input and returns a `byte[]`. It first creates a `ByteArrayBuffer` to hold the encoded data. It then uses the `uc.encode` method to encode the input string into the buffer. After that, it retrieves the length of the encoded data using `LongPacker.getByteLength(nwritten)`. Next, it creates a new `byte[]` with a size of the packed data length plus the original length of the encoded data. It also creates a `DataOutputBuffer` to hold the encoded data. Inside a try-catch block, it packs the length of the encoded data into the `DataOutputBuffer` and appends the original data to the buffer. Finally, it returns the resulting `byte[]`. The code also includes a finally block to close the `DataOutputBuffer` in case of an exception."}
{"index": 458, "input": "**User**: \npublic void requestSecondsUntilIdleLockout(){\n  operations.add(PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT);\n}\n", "extracted_prediction": "The code snippet defines a method named `requestSecondsUntilIdleLockout` that adds an operation to a list called `operations`. The operation type is `PasswordPolicyStateOperationType.GET_SECONDS_UNTIL_IDLE_LOCKOUT`."}
{"index": 321, "input": "**User**: \npublic static float r_distance(vec3 a,vec3 b){\n  float x=a.m[0] - b.m[0];\n  float y=a.m[1] - b.m[1];\n  float z=a.m[2] - b.m[2];\n  float result=(float)Math.sqrt(x * x + y * y + z * z);\n  return result;\n}\n", "extracted_prediction": "This function calculates the Euclidean distance between two points in 3D space. It takes two `vec3` vectors, `a` and `b`, as input and returns the distance as a `float`. The distance is calculated by subtracting the corresponding coordinates of `a` and `b`, squaring the result, and then taking the square root of the sum of the squared coordinates."}
{"index": 615, "input": "**User**: \nString destinationFilePath(){\n  return destinationFilePath;\n}\n", "extracted_prediction": "The `destinationFilePath` function returns the `destinationFilePath` without any modification."}
{"index": 850, "input": "**User**: \npublic java.lang.Object newInstance() throws java.lang.InstantiationException, java.lang.IllegalAccessException {\n  Object o=newInstanceImpl();\n  if (o == null) {\n    throw new InstantiationException();\n  }\n  return o;\n}\n", "extracted_prediction": "This code snippet defines a method `newInstance` that attempts to create a new instance of a class. It throws `InstantiationException` if the new instance cannot be created, or `IllegalAccessException` if there is an issue with accessing the class. If the new instance is successfully created, it is returned."}
{"index": 815, "input": "**User**: \npublic static boolean isModule(IResource resource){\n  return (resource != null && TLA_EXTENSION.equals(resource.getFileExtension()));\n}\n", "extracted_prediction": "The `isModule` method checks if a `resource` is a module by verifying if it is not `null` and if its file extension matches `TLA_EXTENSION`."}
{"index": 559, "input": "**User**: \n@Override public void writeExternal(ObjectOutput out) throws IOException {\n  super.writeExternal(out);\n  out.writeDouble(knnDistance);\n}\n", "extracted_prediction": "This code snippet overrides the `writeExternal` method in a class to write the `knnDistance` field to an `ObjectOutput` object, using the `Double` class for the value."}
{"index": 762, "input": "**User**: \nprivate void addDefaultUri() throws IgniteSpiException {\n  assert uriEncodedList != null;\n  URI uri;\n  try {\n    uri=U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false).toURI();\n  }\n catch (  IgniteCheckedException e) {\n    throw new IgniteSpiException(\"Failed to initialize default file scanner\",e);\n  }\n  uriEncodedList.add(uri);\n}\n", "extracted_prediction": "This method attempts to add a default URI to a list. It first checks if the `uriEncodedList` is not null. If not, it tries to resolve the work directory for the default deployment directory using `U.resolveWorkDirectory(DFLT_DEPLOY_DIR,false)`. If this fails, it throws an `IgniteSpiException`. If the resolution is successful, the URI is added to the `uriEncodedList`."}
{"index": 546, "input": "**User**: \nprivate void displayAllStringDefinedInStringXml(){\n  SimpleIconFontTextView textView=(SimpleIconFontTextView)findViewById(R.id.text_view_1);\n  List<String> list=new ArrayList<>();\n  list.add(getString(R.string.gems_logo));\n  String text=TextUtils.join(\" \",list);\n  textView.setText(text);\n}\n", "extracted_prediction": "This method retrieves a list of strings from the resource string defined in the XML file, and then updates the text of a `SimpleIconFontTextView` with the concatenated list of strings."}
{"index": 818, "input": "**User**: \npublic boolean revisionContainsTemplateName(int revId,String templateName) throws WikiApiException {\n  return revisionContainsTemplateNames(revId,Arrays.asList(new String[]{templateName}));\n}\n", "extracted_prediction": "This method checks if a revision with a given ID contains a specified template name. It throws a `WikiApiException` if the check fails."}
{"index": 991, "input": "**User**: \npublic DataProviderEvent(final LocalizableMessage reason,final Set<Type> types){\n  Reject.ifNull(reason,types);\n  Reject.ifTrue(types.isEmpty());\n  this.reason=reason;\n  final EnumSet<Type> tmp=EnumSet.noneOf(Type.class);\n  tmp.addAll(types);\n  this.types=Collections.unmodifiableSet(tmp);\n}\n", "extracted_prediction": "This code initializes a `DataProviderEvent` with a reason and a set of types. It first checks for null values in the reason and an empty type set, then sets the reason and creates a `tmp` set of types, adding all provided types to it. Finally, it converts the `tmp` set into a `Collections.unmodifiableSet` to ensure it's immutable."}
{"index": 361, "input": "**User**: \npublic void hspan(double start,double end,Paint color,String legend){\n  LegendText legendText=new LegendText(color,legend);\n  comments.add(legendText);\n  plotElements.add(new HSpan(start,end,color,legendText));\n}\n", "extracted_prediction": "The `hspan` method adds a horizontal span element to a plot with a specified start and end point, a color, and a legend. It creates a `LegendText` object with the provided color and legend text, then adds it to the `comments` list and the `plotElements` list, respectively."}
{"index": 285, "input": "**User**: \n@Override public boolean isRunning(){\n  return (frame != null && frame.isVisible());\n}\n", "extracted_prediction": "The method `isRunning` checks if the application is running by verifying that a `frame` object is not null and is visible."}
{"index": 407, "input": "**User**: \npublic final double sampleMax(){\n  return _activeCountMax.getAndSet(_activeCount.get());\n}\n", "extracted_prediction": "This code snippet defines a method `sampleMax` that returns the maximum value of the `_activeCount` variable. It uses the `getAndSet` method to safely update the `_activeCountMax` variable with the current value of `_activeCount`. If `_activeCount` is greater than `_activeCountMax`, it updates `_activeCountMax` to `_activeCount`; otherwise, it remains unchanged. The method is declared as `public final` to ensure it is only accessible from within the package and is immutable, meaning its value cannot be changed after it has been set."}
{"index": 423, "input": "**User**: \npublic static CompiereColor parse(String attributes){\n  CompiereColor cc=new CompiereColor();\n  try {\n    if (attributes != null && attributes.length() > 0)     cc.parseAttributres(attributes);\n  }\n catch (  Exception e) {\n    log.severe(\"(\" + attributes + \") - \"+ e.toString());\n  }\n  return cc;\n}\n", "extracted_prediction": "The `parse` method takes a `String` attribute and parses it into a `CompiereColor` object. If the attribute is not null and has a length greater than 0, it attempts to parse the attribute into the `CompiereColor` object. If an exception occurs during parsing, it logs the error message along with the attribute. The method returns the `CompiereColor` object."}
{"index": 78, "input": "**User**: \n@HLEUnimplemented @HLEFunction(nid=0x3C37A7A6,version=150,checkInsideInterrupt=true) public int sceMpegNextAvcRpAu(@CheckArgument(\"checkMpegHandle\") int mpeg,int streamUid){\n  if (!streamMap.containsKey(streamUid)) {\n    log.warn(String.format(\"sceMpegNextAvcRpAu bad stream 0x%X\",streamUid));\n    return -1;\n  }\n  int result=hleMpegGetAvcAu(null);\n  if (result != 0) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(\"sceMpegNextAvcRpAu returning 0x%08X\",result));\n    }\n    return result;\n  }\n  videoFrameCount++;\n  startedMpeg=true;\n  return 0;\n}\n", "extracted_prediction": "The `sceMpegNextAvcRpAu` function is an HLE function that retrieves an AVC audio frame from a stream. It first checks if the stream is valid by looking it up in the `streamMap`. If the stream is not found, it logs a warning and returns -1. If the stream is valid, it retrieves the AVC audio frame using `hleMpegGetAvcAu` and increments the `videoFrameCount`. If the retrieval fails, it logs a debug message and returns the error code. If the stream is valid, it sets `startedMpeg` to true and returns 0."}
{"index": 590, "input": "**User**: \npublic static <T>CompletableFuture<T> exceptionallyCompletedFuture(Throwable throwable){\n  final CompletableFuture<T> future=new CompletableFuture<T>();\n  future.completeExceptionally(throwable);\n  return future;\n}\n", "extracted_prediction": "This method creates a new `CompletableFuture` instance and completes it with an exception, passing the `throwable` as the cause."}
{"index": 552, "input": "**User**: \npublic void updateFromResource(){\n  for (  String resource : resources) {\n    InputStream is=ClassLoader.getSystemResourceAsStream(resource);\n    LinkedHashMap<EntryType,LinkedHashMap<String,ConfigEntry>> parseResult=parse(is);\n    for (    EntryType type : myMap.keySet()) {\n      LinkedHashMap<String,ConfigEntry> dataMappings=myMap.get(type);\n      LinkedHashMap<String,ConfigEntry> resourceMappings=parseResult.get(type);\n      LinkedHashMap<String,ConfigEntry> tempMappings=new LinkedHashMap<String,ConfigEntry>();\n      LinkedHashSet<String> keys=new LinkedHashSet<String>();\n      keys.addAll(dataMappings.keySet());\n      keys.addAll(resourceMappings.keySet());\n      for (      String key : keys) {\n        if (resourceMappings.containsKey(key)) {\n          tempMappings.put(key,resourceMappings.get(key));\n        }\n else {\n          tempMappings.put(key,dataMappings.get(key));\n        }\n      }\n      myMap.put(type,tempMappings);\n    }\n  }\n}\n", "extracted_prediction": "The `updateFromResource` method updates a `myMap` by merging `dataMappings` and `resourceMappings` for each `EntryType`. It reads from `ClassLoader.getSystemResourceAsStream` for each resource, parses the input streams into a `parseResult`, and then merges the mappings into `myMap`. If a key exists in both mappings, it takes the value from `resourceMappings`. If not, it takes the value from `dataMappings`. The merged mappings are then stored in `myMap`."}
{"index": 284, "input": "**User**: \nprivate void initializeLayout(){\n  GridLayout gl=new GridLayout(0,2);\n  gl.setVgap(5);\n  setLayout(gl);\n  add(new JLabel(\"Frozen: \"));\n  add(frozenDD);\n  add(new JLabel(\"Upper Bound:\"));\n  add(tfUpBound);\n  add(new JLabel(\"Lower Bound\"));\n  add(tfLowBound);\n  add(new JLabel(\"Increment:\"));\n  add(tfIncrement);\n  add(new JLabel(\"Delay:\"));\n  add(tfDelay);\n  setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n}\n", "extracted_prediction": "The `initializeLayout` method initializes a JFrame's layout with a GridLayout that has two columns, a vertical gap of 5 pixels, and sets the layout to the frame. It adds components to the frame, including labels and text fields for frosting level, upper bound, lower bound, increment, and delay. The frame's border is set to an empty border with a 5-pixel border around each side."}
{"index": 616, "input": "**User**: \n@Override public void refreshUsersOrGroupsListFromServer(){\n  showLoadingDialog(getString(R.string.common_loading));\n  GetShareWithUsersAsyncTask getTask=new GetShareWithUsersAsyncTask(this);\n  Object[] params={getFile(),getAccount(),getStorageManager()};\n  getTask.execute(params);\n}\n", "extracted_prediction": "This code snippet overrides a method to refresh the list of users or groups from the server. It displays a loading dialog and creates a new `GetShareWithUsersAsyncTask` instance with the necessary parameters to execute the task."}
{"index": 126, "input": "**User**: \nprivate String local_number() throws ParseException {\n  StringBuilder s=new StringBuilder();\n  if (debug)   dbg_enter(\"local_number\");\n  try {\n    int lc=0;\n    while (lexer.hasMoreChars()) {\n      char la=lexer.lookAhead(0);\n      if (la == '*' || la == '#' || la == '-' || la == '.' || la == '(' || la == ')' || Lexer.isHexDigit(la)) {\n        lexer.consume(1);\n        s.append(la);\n        lc++;\n      }\n else       if (lc > 0)       break;\n else       throw createParseException(\"unexepcted \" + la);\n    }\n    return s.toString();\n  }\n  finally {\n    if (debug)     dbg_leave(\"local_number\");\n  }\n}\n", "extracted_prediction": "This method `local_number` attempts to parse a local number from a string. It uses a `StringBuilder` to build the number. If `debug` is true, it logs the entry and exit of the method. The method iterates over the string using a `while` loop, checking each character. If the character is a wildcard (`*`, `#`, `-`, `.`, `(`, or `)`), it skips the next character and appends it to the `StringBuilder`. If the character is a hexadecimal digit, it also skips the next character. If the method encounters an unexpected character, it throws a `ParseException`. The method returns the built number as a string."}
{"index": 677, "input": "**User**: \npublic void load(GeneralSubtrees generalSubtrees){\n  List<GeneralSubtree> generalSubtreesList=generalSubtrees.getGeneralSubtrees();\n  Collections.sort(generalSubtreesList,new GeneralSubtreeBaseComparator());\n  data=new Object[generalSubtreesList.size()][3];\n  int i=0;\n  for (  GeneralSubtree generalSubtree : generalSubtreesList) {\n    data[i][0]=generalSubtree;\n    data[i][1]=generalSubtree;\n    data[i][2]=generalSubtree;\n    i++;\n  }\n  fireTableDataChanged();\n}\n", "extracted_prediction": "The `load` method takes a `GeneralSubtrees` object and populates a two-dimensional array `data` with the elements of the `generalSubtreesList`. It then sorts the list using a custom `GeneralSubtreeBaseComparator` and sets the array to be sorted. The method increments an index `i` for each element in the sorted list and assigns each element to the array. Finally, it calls `fireTableDataChanged()` to update the table view."}
{"index": 143, "input": "**User**: \nprivate Solution largestObjectiveValue(int objective,Population population){\n  Solution largest=null;\n  double value=Double.NEGATIVE_INFINITY;\n  for (  Solution solution : population) {\n    if (solution.getObjective(objective) > value) {\n      largest=solution;\n      value=solution.getObjective(objective);\n    }\n  }\n  return largest;\n}\n", "extracted_prediction": "This method, `largestObjectiveValue`, finds the `Solution` with the highest objective value for a given `objective` in a `Population` of `Solutions`. It initializes `largest` as `null` and `value` to `Double.NEGATIVE_INFINITY`. It then iterates over each `solution` in the `population`, updating `largest` and `value` if a higher objective value is found. Finally, it returns the `largest` `Solution`."}
{"index": 910, "input": "**User**: \npublic void testCompareToZeroZero(){\n  BigInteger aNumber=BigInteger.ZERO;\n  BigInteger bNumber=BigInteger.ZERO;\n  assertEquals(0,aNumber.compareTo(bNumber));\n}\n", "extracted_prediction": "The code snippet tests the `compareTo` method of the `BigInteger` class by comparing two instances of `BigInteger` initialized with the value `0`. It asserts that the result of `aNumber.compareTo(bNumber)` is `0`, indicating that both numbers are equal."}
{"index": 596, "input": "**User**: \n@Override public int read() throws IOException {\nsynchronized (lock) {\n    checkNotClosed();\n    if (pos != count) {\n      return str.charAt(pos++);\n    }\n    return -1;\n  }\n}\n", "extracted_prediction": "This method overrides the `read()` method in a class that handles input streams. It uses a synchronized block to ensure thread safety, checking that the stream is not closed. If the position is not equal to the count, it returns the character at the current position and increments the position. If the position is equal to the count, it returns -1 to indicate the end of the stream."}
{"index": 21, "input": "**User**: \nprivate int determineMaxLevelRec(int level,Node v){\n  int newLevel=level;\n  for (Edge e=v.getFirstOutEdge(); e != null; e=v.getNextOutEdge(e)) {\n    newLevel=Math.max(newLevel,determineMaxLevelRec(level,e.getTarget()) + 1);\n  }\n  return newLevel;\n}\n", "extracted_prediction": "The provided code snippet defines a method `determineMaxLevelRec` that calculates the maximum level of a tree starting from a given node `v`. It uses a recursive approach to traverse the tree and determine the maximum level of each subtree. The method takes two parameters: `level` (the current level of the node being processed) and `v` (the node to start the traversal from). It returns the maximum level found."}
{"index": 721, "input": "**User**: \npublic void calculateDerived(){\n  xStats.calculateDerived();\n  yStats.calculateDerived();\n  differencesStats.calculateDerived();\n  correlation=Double.NaN;\n  if (!Double.isNaN(xStats.stdDev) && !Double.isNaN(yStats.stdDev) && !Utils.eq(xStats.stdDev,0)) {\n    double slope=(xySum - xStats.sum * yStats.sum / count) / (xStats.sumSq - xStats.sum * xStats.mean);\n    if (!Utils.eq(yStats.stdDev,0)) {\n      correlation=slope * xStats.stdDev / yStats.stdDev;\n    }\n else {\n      correlation=1.0;\n    }\n  }\n  if (Utils.gr(differencesStats.stdDev,0)) {\n    double tval=differencesStats.mean * Math.sqrt(count) / differencesStats.stdDev;\n    if (m_degreesOfFreedom >= 1) {\n      differencesProbability=Statistics.FProbability(tval * tval,1,m_degreesOfFreedom);\n    }\n else {\n      if (count > 1) {\n        differencesProbability=Statistics.FProbability(tval * tval,1,(int)count - 1);\n      }\n else {\n        differencesProbability=1;\n      }\n    }\n  }\n else {\n    if (differencesStats.sumSq == 0) {\n      differencesProbability=1.0;\n    }\n else {\n      differencesProbability=0.0;\n    }\n  }\n  differencesSignificance=0;\n  if (differencesProbability <= sigLevel) {\n    if (xStats.mean > yStats.mean) {\n      differencesSignificance=1;\n    }\n else {\n      differencesSignificance=-1;\n    }\n  }\n}\n", "extracted_prediction": "The provided code snippet calculates the slope, correlation, and significance of the differences between two sets of data, `xStats` and `yStats`. It also calculates the significance of the differences based on the t-test statistic. Here's a concise summary:\n\n- The method `calculateDerived` computes the slope and correlation between `xStats` and `yStats`, provided their standard deviations are not NaN and not zero.\n- If the standard deviations are not zero, the slope is calculated as the difference between the product of the sums of `xStats` and `yStats`, and the product of their means, divided by the sum of squares of `xStats` and the mean of `xStats`.\n- The correlation is then calculated as the slope times the standard deviation of `yStats`, divided by the standard deviation of `xStats`.\n- The method also calculates the t-test statistic for the differences between `xStats` and `yStats`, and if the standard deviation of the differences is not zero, it calculates the probability of observing the given t-value under the null hypothesis.\n- The significance of the differences is determined by comparing the calculated t-value to a significance level (`sigLevel`). If the probability is less than or equal to `sigLevel`, the differences are considered statistically significant.\n- The method returns the calculated slope, correlation, significance probability, and significance level."}
{"index": 269, "input": "**User**: \npublic static <R,A,B>CompletionStage<R> combine(CompletionStage<A> a,CompletionStage<B> b,BiFunction<A,B,R> function){\n  return a.thenCombine(b,function);\n}\n", "extracted_prediction": "This code snippet defines a method `combine` that takes two `CompletionStage` instances, `a` and `b`, and a `BiFunction` that takes two elements of type `A` and `B` and returns a result of type `R`. The method returns a `CompletionStage` that represents the result of combining the two input stages using the provided `BiFunction`."}
{"index": 441, "input": "**User**: \nObject addMarkedOccurrenceHighlight(int start,int end,MarkOccurrencesHighlightPainter p) throws BadLocationException {\n  Document doc=textArea.getDocument();\n  TextUI mapper=textArea.getUI();\n  HighlightInfo i=new LayeredHighlightInfo();\n  i.painter=p;\n  i.p0=doc.createPosition(start);\n  i.p1=doc.createPosition(end - 1);\n  markedOccurrences.add(i);\n  mapper.damageRange(textArea,start,end);\n  return i;\n}\n", "extracted_prediction": "This method adds a marked occurrence highlight to a text area. It creates a new highlight info object with the specified start and end positions, painter, and adds it to the marked occurrences list. It then calls the text area's UI to damage the range, which updates the visual representation of the highlighted text."}
{"index": 326, "input": "**User**: \npublic static void assertProps(UniformPair<EventBean> received,String[] propertyNames,Object[] expectedInsert,Object[] expectedRemoved){\n  assertProps(received.getFirst(),propertyNames,expectedInsert);\n  assertProps(received.getSecond(),propertyNames,expectedRemoved);\n}\n", "extracted_prediction": "The `assertProps` method checks if the properties of a `UniformPair` object match the expected values for insertion and removal. It compares the first and second elements of the `UniformPair` with the provided `propertyNames`, `expectedInsert`, and `expectedRemoved` arrays."}
{"index": 838, "input": "**User**: \npublic static boolean isAndroidSdkDirInLocalPropertiesFile(@NotNull File projectDir){\n  String androidHome=getAndroidHomeFromLocalPropertiesFile(projectDir);\n  if (!Strings.isNullOrEmpty(androidHome)) {\n    String msg=String.format(\"Found Android SDK home at '%1$s' (from local.properties file)\",androidHome);\n    LOG.info(msg);\n    return true;\n  }\n  return false;\n}\n", "extracted_prediction": "This method checks if the Android SDK directory is specified in the local.properties file of the given project directory. It retrieves the Android SDK home from the file and returns true if the home is not null or empty, otherwise false."}
{"index": 970, "input": "**User**: \npublic void removeCategoriesListener(SnapshotCategoriesListener listener){\n  listeners.remove(listener);\n}\n", "extracted_prediction": "This method removes a `SnapshotCategoriesListener` from a collection of listeners."}
{"index": 764, "input": "**User**: \npublic static double distancePointLinePerpendicular(Coordinate p,Coordinate A,Coordinate B){\n  double len2=(B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  double s=((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2);\n}\n", "extracted_prediction": "This method calculates the distance from a point `p` to a line perpendicular to the line segment `AB` defined by points `A` and `B`. It uses the distance formula for lines and the point-to-line distance formula to compute the result. The formula involves calculating the perpendicular distance `s` and then multiplying it by the square root of the sum of the squares of the line segment lengths to get the final distance."}
{"index": 46, "input": "**User**: \nprivate float calcAngle(float value){\n  return value / mData.getYValueSum() * 360f;\n}\n", "extracted_prediction": "The `calcAngle` function calculates the angle in degrees by dividing the input value by the sum of the y-values in the `mData` data structure and then multiplying by 360."}
{"index": 997, "input": "**User**: \npublic void testConstructorSignBytesZeroNull3(){\n  byte aBytes[]={};\n  int aSign=1;\n  byte rBytes[]={0};\n  BigInteger aNumber=new BigInteger(aSign,aBytes);\n  byte resBytes[]=new byte[rBytes.length];\n  resBytes=aNumber.toByteArray();\n  for (int i=0; i < resBytes.length; i++) {\n    assertTrue(resBytes[i] == rBytes[i]);\n  }\n  assertEquals(\"incorrect sign\",0,aNumber.signum());\n}\n", "extracted_prediction": "The code snippet tests the constructor of a class that creates a `BigInteger` object with a sign of 1, a zero-byte array, and a null-byte array. It then compares the resulting byte array with the expected byte array and checks if the sign of the `BigInteger` object is correct."}
{"index": 794, "input": "**User**: \npublic void testInvokeAny4() throws Throwable {\n  CountDownLatch latch=new CountDownLatch(1);\n  ExecutorService e=new ForkJoinPool(1);\n  PoolCleaner cleaner=null;\n  try {\n    cleaner=cleaner(e);\n    List<Callable<String>> l=new ArrayList<Callable<String>>();\n    l.add(latchAwaitingStringTask(latch));\n    l.add(null);\n    try {\n      e.invokeAny(l);\n      shouldThrow();\n    }\n catch (    NullPointerException success) {\n    }\n    latch.countDown();\n  }\n  finally {\n    if (cleaner != null) {\n      cleaner.close();\n    }\n  }\n}\n", "extracted_prediction": "This code snippet tests the `invokeAny` method of the `ForkJoinPool` class. It creates a `CountDownLatch` with one count, an `ExecutorService` with one thread, and a `PoolCleaner` instance. It adds two tasks to a list: a task that waits for a string using `latchAwaitingStringTask`, and a null task. It then invokes `invokeAny` on the `ExecutorService` with the list of tasks. If a `NullPointerException` is thrown, it means the `invokeAny` method was called with a null task. Afterward, it decrements the count of the `CountDownLatch`. If a `PoolCleaner` instance was created, it closes it in the finally block."}
{"index": 958, "input": "**User**: \nprivate void createMissingValues(){\n  String sql=\"SELECT ra.A_RegistrationAttribute_ID \" + \"FROM A_RegistrationAttribute ra\" + \" LEFT OUTER JOIN A_RegistrationProduct rp ON (rp.A_RegistrationAttribute_ID=ra.A_RegistrationAttribute_ID)\"+ \" LEFT OUTER JOIN A_Registration r ON (r.M_Product_ID=rp.M_Product_ID) \"+ \"WHERE r.A_Registration_ID=?\"+ \" AND NOT EXISTS (SELECT A_RegistrationAttribute_ID FROM A_RegistrationValue v \"+ \"WHERE ra.A_RegistrationAttribute_ID=v.A_RegistrationAttribute_ID AND r.A_Registration_ID=v.A_Registration_ID)\";\n  PreparedStatement pstmt=null;\n  try {\n    pstmt=DB.prepareStatement(sql,get_TrxName());\n    pstmt.setInt(1,getA_Registration_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      MRegistrationValue v=new MRegistrationValue(this,rs.getInt(1),\"?\");\n      v.saveEx();\n    }\n    rs.close();\n    pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    log.log(Level.SEVERE,null,e);\n  }\n  try {\n    if (pstmt != null)     pstmt.close();\n    pstmt=null;\n  }\n catch (  Exception e) {\n    pstmt=null;\n  }\n}\n", "extracted_prediction": "The `createMissingValues` method is designed to create missing values for a specified `A_Registration_ID` in the `A_RegistrationValue` table. It uses a SQL query to identify attributes that do not have corresponding values in the `A_RegistrationValue` table. It then creates new `MRegistrationValue` objects with the missing values and saves them. The method handles exceptions and ensures that resources are properly closed."}
{"index": 849, "input": "**User**: \npublic void insertTwin(Instruction inst,Instruction twin){\n  ListIterator<GCIRMapElement> iter=list.listIterator();\n  while (iter.hasNext()) {\n    GCIRMapElement newPtr=iter.next();\n    if (newPtr.getInstruction() == inst) {\n      iter.add(newPtr.createTwin(twin));\n      return;\n    }\n  }\n  throw new OptimizingCompilerException(\"GCIRMap.createTwin: \" + inst + \" not found\");\n}\n", "extracted_prediction": "This code snippet defines a method `insertTwin` that takes an `Instruction` object `inst` and a `Instruction` object `twin`. It iterates through the `GCIRMap` using a `ListIterator` to find an instance of `inst`. If found, it creates a new `GCIRMapElement` object with the twin `twin` and adds it to the list using `iter.add(newPtr.createTwin(twin))`. If the `inst` is not found, it throws an `OptimizingCompilerException` with a message indicating the instruction not found."}
{"index": 157, "input": "**User**: \npublic void addEventListener(SIPDialogEventListener newListener){\n  eventListeners.add(newListener);\n}\n", "extracted_prediction": "The `addEventListener` method in SIP (Session Initiation Protocol) is used to add a new `SIPDialogEventListener` to the existing list of listeners. This method appends the new listener to the `eventListeners` array, allowing it to receive events from the SIP dialog."}
{"index": 404, "input": "**User**: \npublic FileCommandInfo(int fd,String command,int result,String parameters){\n  this(true,fd,command,result,parameters);\n}\n", "extracted_prediction": "This code snippet defines a class `FileCommandInfo` that extends `CommandInfo`. It takes five parameters: `fd` (file descriptor), `command` (the command string), `result` (the result of the command execution), `parameters` (the command parameters), and `this` (a boolean flag indicating if the command is a file command). The constructor initializes the superclass `CommandInfo` with these parameters."}
{"index": 247, "input": "**User**: \npublic static String xmlNode(String name,String attributes,String content,boolean indent){\n  String start=attributes == null ? name : name + attributes;\n  if (content == null) {\n    return \"<\" + start + \"/>\\n\";\n  }\n  if (indent && content.indexOf('\\n') >= 0) {\n    content=\"\\n\" + indent(content);\n  }\n  return \"<\" + start + \">\"+ content+ \"</\"+ name+ \">\\n\";\n}\n", "extracted_prediction": "This method creates an XML element with a given name, attributes, content, and indentation. If attributes are not provided, the name is used as is. If content is null, it returns a simple opening and closing tag. If content contains newlines, it adds indentation. The method returns the XML string with the appropriate tags and content."}
{"index": 670, "input": "**User**: \nprivate boolean startsWithSpace(String str){\n  return str.length() != 0 && str.charAt(0) == ' ';\n}\n", "extracted_prediction": "The `startsWithSpace` method checks if a given string `str` starts with a space character. It returns `true` if the string is not empty and the first character is a space, and `false` otherwise."}
{"index": 256, "input": "**User**: \nprotected boolean checkCoverage(){\n  int i;\n  int n;\n  int[] count;\n  Range r;\n  String attrIndex;\n  SubspaceClusterDefinition cl;\n  count=new int[getNumAttributes()];\n  for (i=0; i < getNumAttributes(); i++) {\n    for (n=0; n < getClusters().length; n++) {\n      cl=(SubspaceClusterDefinition)getClusters()[n];\n      r=new Range(cl.getAttrIndexRange());\n      r.setUpper(getNumAttributes());\n      if (r.isInRange(i)) {\n        count[i]++;\n      }\n    }\n  }\n  attrIndex=\"\";\n  for (i=0; i < count.length; i++) {\n    if (count[i] == 0) {\n      if (attrIndex.length() != 0) {\n        attrIndex+=\",\";\n      }\n      attrIndex+=(i + 1);\n    }\n  }\n  if (attrIndex.length() != 0) {\n    throw new IllegalArgumentException(\"The following attributes are not covered by a cluster \" + \"definition: \" + attrIndex + \"\\n\");\n  }\n  return true;\n}\n", "extracted_prediction": "This method checks if all attributes are covered by a cluster definition. It creates an array of counts for each attribute, iterates over the clusters, and increments the count for each attribute that is within the range of the cluster. It then checks if any attributes have a count of 0 and throws an exception if so. If all attributes are covered, it returns true."}
{"index": 249, "input": "**User**: \nvoid notifyFailure(Throwable exception){\nsynchronized (waitObject) {\n    isComplete=true;\n    if (exception instanceof MqttException) {\n      pendingException=(MqttException)exception;\n    }\n else {\n      pendingException=new MqttException(exception);\n    }\n    waitObject.notifyAll();\n    if (exception instanceof MqttException) {\n      lastException=(MqttException)exception;\n    }\n    if (listener != null) {\n      listener.onFailure(this,exception);\n    }\n  }\n}\n", "extracted_prediction": "The `notifyFailure` method handles a failure by marking the task as complete, storing the exception, and notifying any waiting threads. If the exception is an `MqttException`, it updates the `pendingException` and `lastException` variables. If a listener is present, it calls the listener's `onFailure` method with the current object and the exception. The method uses synchronization to ensure thread safety when accessing shared resources."}
{"index": 577, "input": "**User**: \nprivate static void decodeAnsiX12Segment(BitSource bits,StringBuilder result) throws FormatException {\n  int[] cValues=new int[3];\n  do {\n    if (bits.available() == 8) {\n      return;\n    }\n    int firstByte=bits.readBits(8);\n    if (firstByte == 254) {\n      return;\n    }\n    parseTwoBytes(firstByte,bits.readBits(8),cValues);\n    for (int i=0; i < 3; i++) {\n      int cValue=cValues[i];\n      if (cValue == 0) {\n        result.append('\\r');\n      }\n else       if (cValue == 1) {\n        result.append('*');\n      }\n else       if (cValue == 2) {\n        result.append('>');\n      }\n else       if (cValue == 3) {\n        result.append(' ');\n      }\n else       if (cValue < 14) {\n        result.append((char)(cValue + 44));\n      }\n else       if (cValue < 40) {\n        result.append((char)(cValue + 51));\n      }\n else {\n        throw FormatException.getFormatInstance();\n      }\n    }\n  }\n while (bits.available() > 0);\n}\n", "extracted_prediction": "This method decodes an ANSI X12 segment from a `BitSource`. It reads 8-bit bytes, parses them into control characters, and appends them to a `StringBuilder` result. If a segment is complete (indicated by a byte of 254), the method returns. If any other byte is encountered, it appends the corresponding character to the result. If an unexpected byte is encountered, a `FormatException` is thrown."}
{"index": 17, "input": "**User**: \npublic static Long[] valuesOf(long[] array){\n  Long[] dest=new Long[array.length];\n  for (int i=0; i < array.length; i++) {\n    dest[i]=Long.valueOf(array[i]);\n  }\n  return dest;\n}\n", "extracted_prediction": "This method converts an array of `long` values into a new array of `Long` values. It creates a new array `dest` with the same length as the input array `array`. It then iterates over each element in the input array, converting each `long` to a `Long` and storing it in the corresponding position in the new array `dest`. Finally, it returns the new array `dest`."}
{"index": 50, "input": "**User**: \n@Override protected void doGet(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {\n  resp.setContentType(\"text/plain\");\n  PrintWriter sendToClient=resp.getWriter();\n  for (  Video v : this.videos) {\n    sendToClient.write(v.getName() + \" : \" + v.getUrl()+ \"\\n\");\n  }\n}\n", "extracted_prediction": "This code snippet overrides the `doGet` method in a servlet to send the names and URLs of videos to the client as plain text. It sets the response content type to \"text/plain,\" retrieves a `PrintWriter` to write to the response, and iterates over the `videos` list to print each video's name and URL to the client."}
{"index": 45, "input": "**User**: \npublic static boolean copyStream(InputStream is,OutputStream os,CopyListener listener,int bufferSize) throws IOException {\n  int current=0;\n  int total=is.available();\n  if (total <= 0) {\n    total=DEFAULT_IMAGE_TOTAL_SIZE;\n  }\n  final byte[] bytes=new byte[bufferSize];\n  int count;\n  if (shouldStopLoading(listener,current,total))   return false;\n  while ((count=is.read(bytes,0,bufferSize)) != -1) {\n    os.write(bytes,0,count);\n    current+=count;\n    if (shouldStopLoading(listener,current,total))     return false;\n  }\n  os.flush();\n  return true;\n}\n", "extracted_prediction": "This method copies data from an `InputStream` to an `OutputStream` using a `CopyListener`. It uses a buffer size of `bufferSize` bytes. If the total amount of data in the `InputStream` is less than or equal to 0, it defaults to `DEFAULT_IMAGE_TOTAL_SIZE`. The method reads data from the `InputStream` into the `OutputStream` until it reaches the total amount of data or the listener indicates that the copying should stop. It then flushes the `OutputStream` to ensure all data is written. If the listener indicates that the copying should stop, the method returns `false`. Otherwise, it returns `true`."}
{"index": 327, "input": "**User**: \npublic int size(){\n  return al.size();\n}\n", "extracted_prediction": "The `size()` method returns the size of the `al` array."}
{"index": 949, "input": "**User**: \nString format(Object obj,StringBuffer toAppendTo) throws IllegalArgumentException {\n  Date source=null;\n  if (obj instanceof Date) {\n    source=(Date)obj;\n  }\n else   if (obj instanceof String) {\n    try {\n      source=parse((String)obj);\n    }\n catch (    ParseException pe) {\n      throw new RuntimeException(pe.toString());\n    }\n  }\n  if (source == null) {\n    throw new IllegalArgumentException((obj == null) ? \"null\" : obj.toString());\n  }\n  return format(source,toAppendTo);\n}\n", "extracted_prediction": "This method takes an object and a `StringBuffer` as parameters. It attempts to cast the object to a `Date` if it's of that type. If not, it tries to parse a string representation of a `Date` using a `ParseException` catch block. If the `source` is `null`, it throws an `IllegalArgumentException`. Otherwise, it returns the formatted `source` using the provided `StringBuffer`."}
{"index": 201, "input": "**User**: \npublic static String map2OID(String algName){\n  return alg2OidMap.get(algName.toUpperCase(Locale.US));\n}\n", "extracted_prediction": "This method, `map2OID`, takes a string `algName` and returns the corresponding OID (Object Identifier) from a predefined map `alg2OidMap`. The method converts the input `algName` to uppercase using `toUpperCase(Locale.US)` to ensure case-insensitive matching in the map. It then uses the `get` method to retrieve the OID from the map based on the uppercase version of the `algName`."}
{"index": 296, "input": "**User**: \npublic Node(Coordinate pt){\n  this(pt,new DirectedEdgeStar());\n}\n", "extracted_prediction": "The constructor for `Node` creates a new instance of `Node` with a given `Coordinate` point and initializes it with a `DirectedEdgeStar` edge."}
{"index": 714, "input": "**User**: \npublic Request header(String key,String value){\n  Objects.requireNonNull(key);\n  Objects.requireNonNull(value);\n  _headers.put(key,value);\n  return this;\n}\n", "extracted_prediction": "This method adds a new header to the request object. It ensures that both the key and value are not null before adding them to the headers map."}
{"index": 116, "input": "**User**: \nprivate boolean isFieldPackagePrivate(Element attribute){\n  Set<Modifier> modifiers=attribute.getModifiers();\n  return !modifiers.contains(PUBLIC) && !modifiers.contains(PROTECTED) && !modifiers.contains(PRIVATE);\n}\n", "extracted_prediction": "The `isFieldPackagePrivate` method checks if a field's modifier is `PRIVATE`. It returns `true` if the field is not public, protected, or has any other modifiers."}
{"index": 524, "input": "**User**: \npublic ShortInterleavedRaster(SampleModel sampleModel,DataBuffer dataBuffer,Point origin){\n  this(sampleModel,dataBuffer,new Rectangle(origin.x,origin.y,sampleModel.getWidth(),sampleModel.getHeight()),origin,null);\n}\n", "extracted_prediction": "The `ShortInterleavedRaster` constructor initializes a new instance of `ShortInterleavedRaster` with the given `sampleModel`, `dataBuffer`, and `rectangle` parameters. The `rectangle` parameter specifies the area of the raster to be initialized, and the `origin` parameter defines the origin of the raster."}
{"index": 506, "input": "**User**: \nvoid addFillComponents(Container panel,int[] cols,int[] rows){\n  Dimension filler=new Dimension(10,10);\n  boolean filled_cell_11=false;\n  CellConstraints cc=new CellConstraints();\n  if (cols.length > 0 && rows.length > 0) {\n    if (cols[0] == 1 && rows[0] == 1) {\n      panel.add(Box.createRigidArea(filler),cc.xy(1,1));\n      filled_cell_11=true;\n    }\n  }\n  for (int index=0; index < cols.length; index++) {\n    if (cols[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(cols[index],1));\n  }\n  for (int index=0; index < rows.length; index++) {\n    if (rows[index] == 1 && filled_cell_11) {\n      continue;\n    }\n    panel.add(Box.createRigidArea(filler),cc.xy(1,rows[index]));\n  }\n}\n", "extracted_prediction": "The `addFillComponents` method fills a `Container` panel with a 10x10 `filler` component. It checks if the panel is empty and fills the top-left corner if the first row and column are both 1. It then iterates through the columns and rows, adding a 10x10 `filler` component to each cell if it's not the first cell in the row or column, respectively."}
{"index": 745, "input": "**User**: \nprivate void traverseInternal(Object root,boolean yieldRoot,IdentityHashMap<Object,Object> seen){\n  if (root == null || seen.containsKey(root)) {\n    return;\n  }\n  if (yieldRoot) {\n    if (!visit(root)) {\n      return;\n    }\n  }\n  seen.put(root,root);\n  if (root instanceof JSONObject) {\n    JSONObject json=(JSONObject)root;\n    Iterator<String> keys=json.keys();\n    while (keys.hasNext()) {\n      String key=keys.next();\n      try {\n        traverseInternal(json.get(key),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof JSONArray) {\n    JSONArray array=(JSONArray)root;\n    for (int i=0; i < array.length(); ++i) {\n      try {\n        traverseInternal(array.get(i),true,seen);\n      }\n catch (      JSONException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n else   if (root instanceof Map) {\n    Map<?,?> map=(Map<?,?>)root;\n    for (    Object value : map.values()) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof List) {\n    List<?> list=(List<?>)root;\n    for (    Object value : list) {\n      traverseInternal(value,true,seen);\n    }\n  }\n else   if (root instanceof ParseObject) {\n    if (traverseParseObjects) {\n      ParseObject object=(ParseObject)root;\n      for (      String key : object.keySet()) {\n        traverseInternal(object.get(key),true,seen);\n      }\n    }\n  }\n else   if (root instanceof ParseACL) {\n    ParseACL acl=(ParseACL)root;\n    ParseUser user=acl.getUnresolvedUser();\n    if (user != null && user.isCurrentUser()) {\n      traverseInternal(user,true,seen);\n    }\n  }\n}\n", "extracted_prediction": "This method `traverseInternal` recursively visits objects within a given root, yielding the root if specified. It uses an `IdentityHashMap` to keep track of visited objects to avoid infinite loops. The method handles different types of objects, such as `JSONObject`, `JSONArray`, `Map`, `List`, and `ParseObject/ParseACL`, and traverses their respective keys or values. If a `ParseObject` or `ParseACL` is encountered, it will also visit the associated `ParseUser` if the current user is the same as the one in the `ParseACL`. If an exception occurs during traversal, it is caught and rethrown as a `RuntimeException`."}
{"index": 163, "input": "**User**: \nprivate void pullEvent(){\n  final int newScrollValue;\n  final int itemDimension;\n  final float initialMotionValue, lastMotionValue;\nswitch (getPullToRefreshScrollDirection()) {\ncase HORIZONTAL:\n    initialMotionValue=mInitialMotionX;\n  lastMotionValue=mLastMotionX;\nbreak;\ncase VERTICAL:\ndefault :\ninitialMotionValue=mInitialMotionY;\nlastMotionValue=mLastMotionY;\nbreak;\n}\nswitch (mCurrentMode) {\ncase PULL_FROM_END:\nnewScrollValue=Math.round(Math.max(initialMotionValue - lastMotionValue,0) / FRICTION);\nitemDimension=getFooterSize();\nbreak;\ncase PULL_FROM_START:\ndefault :\nnewScrollValue=Math.round(Math.min(initialMotionValue - lastMotionValue,0) / FRICTION);\nitemDimension=getHeaderSize();\nbreak;\n}\nsetHeaderScroll(newScrollValue);\nif (newScrollValue != 0 && !isRefreshing()) {\nfloat scale=Math.abs(newScrollValue) / (float)itemDimension;\nswitch (mCurrentMode) {\ncase PULL_FROM_END:\nmFooterLayout.onPull(scale);\nbreak;\ncase PULL_FROM_START:\ndefault :\nmHeaderLayout.onPull(scale);\nbreak;\n}\nif (mState != State.PULL_TO_REFRESH && itemDimension >= Math.abs(newScrollValue)) {\nsetState(State.PULL_TO_REFRESH);\n}\n else if (mState == State.PULL_TO_REFRESH && itemDimension < Math.abs(newScrollValue)) {\nsetState(State.RELEASE_TO_REFRESH);\n}\n}\n}\n", "extracted_prediction": "The `pullEvent` method updates the scroll value and handles the pull-to-refresh functionality. It first determines the direction of the pull (horizontal or vertical) and calculates the new scroll value based on the difference between the initial and last motion values, divided by a friction factor. It then sets the header or footer scroll value accordingly. If the new scroll value is not zero and the refresh is not in progress, it applies the appropriate pull action to the layouts based on the current mode. If the state is not PULL_TO_REFRESH and the item dimension is greater than or equal to the new scroll value, it sets the state to PULL_TO_REFRESH. If the state is PULL_TO_REFRESH and the item dimension is less than the new scroll value, it sets the state to RELEASE_TO_REFRESH."}
{"index": 856, "input": "**User**: \npublic void actionPerformed(ActionEvent e){\n  navigateToPriorDemo();\n}\n", "extracted_prediction": "The `actionPerformed` method is called when an action is performed, and it calls the `navigateToPriorDemo` method to navigate to the previous demo."}
{"index": 365, "input": "**User**: \nprotected void configureFromProperties(InputStream is,String rootDirectory) throws IOException {\n  Properties props=new Properties();\n  props.load(is);\n  props.put(ROOT_DIR_PATH_PROPERTY,rootDirectory);\n  String oldPrefix=getPropertyPrefix();\n  setProperties(null,props);\n  setPropertyPrefix(oldPrefix);\n}\n", "extracted_prediction": "This method loads properties from an input stream, sets a new root directory property, and then reconfigures the properties with the new prefix."}
{"index": 395, "input": "**User**: \npublic double readDouble() throws IOException {\n  return primitiveTypes.readDouble();\n}\n", "extracted_prediction": "This method reads a double value from the input stream and throws an IOException if an error occurs."}
{"index": 778, "input": "**User**: \npublic final boolean equals(Object object){\n  if (object == null) {\n    return false;\n  }\n  if (!(object instanceof KnowledgeEdge)) {\n    return false;\n  }\n  KnowledgeEdge pair=(KnowledgeEdge)object;\n  return from.equals(pair.from) && to.equals(pair.to);\n}\n", "extracted_prediction": "The `equals` method checks if two `KnowledgeEdge` objects are equal. It first checks if the object is `null`. If it is, the method returns `false`. Then, it checks if the object is not an instance of `KnowledgeEdge`. If it is, the method returns `false`. If the object is a `KnowledgeEdge`, it casts it to a `KnowledgeEdge` object and compares the `from` and `to` fields of the two objects. If they are equal, the method returns `true`; otherwise, it returns `false`."}
{"index": 679, "input": "**User**: \npublic boolean isPingDisabled(){\n  return (null != healthcheck && !healthcheck.exists());\n}\n", "extracted_prediction": "The `isPingDisabled` method returns `true` if the health check is not null and does not exist."}
{"index": 678, "input": "**User**: \n@Override public synchronized int read(){\n  return pos < count ? buffer.charAt(pos++) & 0xFF : -1;\n}\n", "extracted_prediction": "This method reads a character from the buffer, returning the character if the position is less than the count, or -1 if the end of the buffer is reached. The read operation is synchronized to ensure thread safety."}
{"index": 16, "input": "**User**: \nprivate void validateSqlStatement(String sql,int jdbcStatementIndex){\n  Assert.isTrue(StringUtils.isNotBlank(sql),\"JDBC statement [\" + jdbcStatementIndex + \"] SQL is required\");\n}\n", "extracted_prediction": "The `validateSqlStatement` method checks if the provided SQL statement is not blank. If it is, the method asserts that the statement is not empty, otherwise, it throws an error with a message indicating the JDBC statement index."}
{"index": 847, "input": "**User**: \n@Override protected void commitToInput(){\n  JmxBeanSensorAssignment assignment=getInput();\n  if (null != assignment) {\n    assignment.setDomain(domainText.getText());\n    assignment.setObjectNameParameters(new HashMap<>(parametersMap));\n    if (allAttributesButton.getSelection()) {\n      assignment.setAttributes(Collections.<String>emptySet());\n    }\n else {\n      assignment.setAttributes(new HashSet<>(attributesSet));\n    }\n  }\n}\n", "extracted_prediction": "This method, `commitToInput`, retrieves an `JmxBeanSensorAssignment` from the input, sets its domain and object name parameters based on the provided text and map, and optionally sets its attributes based on a button selection. If the button is selected, it sets the attributes to an empty set; otherwise, it sets them to a set containing the provided attributes."}
{"index": 66, "input": "**User**: \nprotected void prepareDataSet(){\n  dataSet1=Arrays.asList(new String[]{\"a\",\"b\",\"c\"});\n  dataSet2=Arrays.asList(new String[]{\"d\",\"e\",\"f\"});\n  dataSet3=Arrays.asList(new String[]{\"b\",\"c\",\"a\",\"d\"});\n}\n", "extracted_prediction": "The `prepareDataSet` method initializes three `List` objects, each containing a unique set of strings: `dataSet1` with {\"a\", \"b\", \"c\"}, `dataSet2` with {\"d\", \"e\", \"f\"}, and `dataSet3` with {\"b\", \"c\", \"a\", \"d\"}."}
{"index": 957, "input": "**User**: \npublic double interceptStdErr(){\n  return Math.sqrt(svar0);\n}\n", "extracted_prediction": "The `interceptStdErr` method calculates the standard error of the intercept by taking the square root of the variance of the standardized residuals (`svar0`)."}
{"index": 181, "input": "**User**: \nprivate boolean removeTask(Task t,int min){\n  for (int i=tasks.size(); --i >= min; ) {\n    if (tasks.get(i) == t) {\n      tasks.remove(i);\n      if (i < firstPending) {\n        firstPending--;\n        for (int j=threads.size(); --j >= 0; ) {\n          TaskThread thread=threads.get(j);\n          if (thread.task == t) {\n            if (thread != Thread.currentThread())             thread.interrupt();\n            break;\n          }\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n", "extracted_prediction": "This code snippet defines a method `removeTask` that removes a `Task` from a list of `Task`s and checks if the removal affects the first `Pending` task. If the task is found and removed, it updates the first `Pending` task and interrupts the corresponding `TaskThread`. If the task is not found, it returns `false`."}
{"index": 496, "input": "**User**: \npublic boolean init(){\n  log.config(\"\");\n  MClient client=MClient.get(Env.getCtx());\n  String ASPFilter=\"\";\n  if (client.isUseASP())   ASPFilter=\"   AND (   p.AD_Process_Para_ID IN ( \" + \"              SELECT pp.AD_Process_Para_ID \" + \"                FROM ASP_Process_Para pp, ASP_Process p, ASP_Level l, ASP_ClientLevel cl \"+ \"               WHERE p.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND cl.AD_Client_ID = \" + client.getAD_Client_ID() + \"                 AND cl.ASP_Level_ID = l.ASP_Level_ID \"+ \"                 AND pp.ASP_Process_ID = p.ASP_Process_ID \"+ \"                 AND pp.IsActive = 'Y' \"+ \"                 AND p.IsActive = 'Y' \"+ \"                 AND l.IsActive = 'Y' \"+ \"                 AND cl.IsActive = 'Y' \"+ \"                 AND pp.ASP_Status = 'S') \"+ \"        OR p.AD_Process_Para_ID IN ( \"+ \"              SELECT AD_Process_Para_ID \"+ \"                FROM ASP_ClientException ce \"+ \"               WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"                 AND ce.IsActive = 'Y' \"+ \"                 AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"                 AND ce.AD_Tab_ID IS NULL \"+ \"                 AND ce.AD_Field_ID IS NULL \"+ \"                 AND ce.ASP_Status = 'S') \"+ \"       ) \"+ \"   AND p.AD_Process_Para_ID NOT IN ( \"+ \"          SELECT AD_Process_Para_ID \"+ \"            FROM ASP_ClientException ce \"+ \"           WHERE ce.AD_Client_ID = \"+ client.getAD_Client_ID()+ \"             AND ce.IsActive = 'Y' \"+ \"             AND ce.AD_Process_Para_ID IS NOT NULL \"+ \"             AND ce.AD_Tab_ID IS NULL \"+ \"             AND ce.AD_Field_ID IS NULL \"+ \"             AND ce.ASP_Status = 'H')\";\n  String sql=null;\n  if (Env.isBaseLanguage(Env.getCtx(),\"AD_Process_Para\"))   sql=\"SELECT p.Name, p.Description, p.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND p.IsActive='Y' \" + ASPFilter + \" ORDER BY SeqNo\";\n else   sql=\"SELECT t.Name, t.Description, t.Help, \" + \"p.AD_Reference_ID, p.AD_Process_Para_ID, \" + \"p.FieldLength, p.IsMandatory, p.IsRange, p.ColumnName, \"+ \"p.DefaultValue, p.DefaultValue2, p.VFormat, p.ValueMin, p.ValueMax, \"+ \"p.SeqNo, p.AD_Reference_Value_ID, vr.Code AS ValidationCode, \"+ \"p.ReadOnlyLogic, p.DisplayLogic \"+ \"FROM AD_Process_Para p\"+ \" INNER JOIN AD_Process_Para_Trl t ON (p.AD_Process_Para_ID=t.AD_Process_Para_ID)\"+ \" LEFT OUTER JOIN AD_Val_Rule vr ON (p.AD_Val_Rule_ID=vr.AD_Val_Rule_ID) \"+ \"WHERE p.AD_Process_ID=?\"+ \" AND t.AD_Language='\" + Env.getAD_Language(Env.getCtx()) + \"'\"+ \" AND p.IsActive='Y' \"+ ASPFilter+ \" ORDER BY SeqNo\";\n  boolean hasFields=false;\n  Rows rows=new Rows();\n  try {\n    PreparedStatement pstmt=DB.prepareStatement(sql,null);\n    pstmt.setInt(1,m_processInfo.getAD_Process_ID());\n    ResultSet rs=pstmt.executeQuery();\n    while (rs.next()) {\n      hasFields=true;\n      createField(rs,rows);\n      isPair=!isPair;\n    }\n    rs.close();\n    pstmt.close();\n  }\n catch (  SQLException e) {\n    log.log(Level.SEVERE,sql,e);\n  }\n  if (m_mFields.size() != m_mFields2.size() || m_mFields.size() != m_wEditors.size() || m_mFields2.size() != m_wEditors2.size())   log.log(Level.SEVERE,\"View & Model vector size is different\");\n  if (hasFields) {\n    centerPanel.appendChild(rows);\n    dynamicDisplay();\n  }\n else   dispose();\n  return hasFields;\n}\n", "extracted_prediction": "The provided code snippet is a method in a Java class that is responsible for initializing a data model and a view. Here's a concise summary:\n\n- The method `init` is called to initialize the data model and view.\n- It starts by configuring the logging system.\n- It retrieves the client object from the context, which is used to check if ASP (Application Server Pages) are enabled.\n- It constructs a filter string based on whether ASP is enabled and the client's ASP level.\n- It then creates a SQL query depending on whether the base language is AD_Process_Para or AD_Process_Para_Trl.\n- The method executes the query to retrieve fields from the database, creating a `Rows` object to hold the data.\n- It checks if there are any fields to display and updates the view accordingly.\n- Finally, it compares the sizes of the data model and view vectors and disposes of the view if they are different, or appends the fields to the view if they are the same.\n\nPlease note that the code snippet is not complete, and some parts are missing, such as the `Rows` object creation and the actual SQL query execution."}
{"index": 431, "input": "**User**: \npublic static String removeNewLineChars(String s){\n  String retString=null;\n  if ((s != null) && (s.length() > 0) && (s.indexOf('\\n') != -1)) {\n    char[] chars=s.toCharArray();\n    int len=chars.length;\n    StringBuffer sb=new StringBuffer(len);\n    for (int i=0; i < len; i++) {\n      char c=chars[i];\n      if (c != '\\n') {\n        sb.append(c);\n      }\n    }\n    retString=sb.toString();\n  }\n else {\n    retString=s;\n  }\n  return retString;\n}\n", "extracted_prediction": "This code snippet defines a method `removeNewLineChars` that takes a `String` as input and returns a new `String` with all newline characters removed. If the input string is not null, has a length greater than zero, and contains a newline character, the method converts the string to a character array, iterates through the array, and appends non-newline characters to a `StringBuffer`. Finally, it converts the `StringBuffer` back to a string and returns it. If the input string is null or empty or does not contain newline characters, it returns the original string unchanged."}
{"index": 303, "input": "**User**: \nvoid writeTo(byte[] b,int off){\n  System.arraycopy(buf,0,b,off,count);\n}\n", "extracted_prediction": "The `writeTo` method takes a byte array `b`, an index `off`, and an integer `count`. It copies the contents of the `buf` array starting at index `0` to the byte array `b` starting at index `off`, with a count of `count` elements."}
{"index": 301, "input": "**User**: \npublic void ascendTree(){\n  if (null != parentPath) {\n    parentPath.append(PARENT_PATH);\n    return;\n  }\n  File parentTree=calcParentTree();\n  if (null != parentTree) {\n    treeFile=parentTree;\n    return;\n  }\n  parentPath=new StringBuilder(provideLastName());\n  parentPath.append(PARENT_PATH);\n}\n", "extracted_prediction": "The `ascendTree` method checks if a `parentPath` is provided. If it is, it appends `PARENT_PATH` to the `parentPath` and returns. If not, it calculates the `parentTree` using `calcParentTree` and assigns it to `treeFile` if it's not `null`. If neither `parentPath` nor `treeFile` is `null`, it creates a new `StringBuilder` with the last name using `provideLastName` and appends `PARENT_PATH` to it, assigning the result to `parentPath`."}
