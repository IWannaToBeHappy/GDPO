{"index": 231, "input": "**User**: \nvoid test_merge_trees_trivial__initialize(void)\n{\n\trepo = cl_git_sandbox_init(TEST_REPO_PATH);\n}", "extracted_prediction": "The `test_merge_trees_trivial__initialize` function initializes a Git repository using `cl_git_sandbox_init` with the specified test path (`TEST_REPO_PATH`), setting up a sandboxed environment for testing merge tree operations."}
{"index": 711, "input": "**User**: \nvoid devm_gpiod_put_array(struct device *dev, struct gpio_descs *descs)\n{\n\tWARN_ON(devres_release(dev, devm_gpiod_release_array,\n\t\t\t       devm_gpiod_match_array, &descs));\n}", "extracted_prediction": "The function `devm_gpiod_put_array` releases GPIO descriptors allocated with `devm_gpiod_allocate_array` and warns against calling it when resources are already released. It uses `devres_release` to free the descriptors, with parameters `devm_gpiod_release_array`, `devm_gpiod_match_array`, and the `descs` structure. The warning ensures no redundant calls to `devres_release`."}
{"index": 469, "input": "**User**: \nstatic int load_default_rx_configuration(struct fmdev *fmdev)\n{\n\tint ret;\n\n\tret = fm_rx_set_volume(fmdev, FM_DEFAULT_RX_VOLUME);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn fm_rx_set_rssi_threshold(fmdev, FM_DEFAULT_RSSI_THRESHOLD);\n}", "extracted_prediction": "The function sets the default RX volume and RSSI threshold for the FM device, returning an error if either configuration step fails."}
{"index": 174, "input": "**User**: \nint get_comp() {\n    return comp;\n}", "extracted_prediction": "The `get_comp()` function returns the value of the `comp` integer variable, serving as a getter method to access its public value."}
{"index": 628, "input": "**User**: \nbackend_handle_default(struct connection *c)\n{\n\treturn (kore_connection_handle(c));\n}", "extracted_prediction": "The `backend_handle_default` function returns the connection handle for the given `connection` structure, acting as a default backend handler in the Kore web server framework."}
{"index": 153, "input": "**User**: \ncredential_factory_t *credential_factory_create()\n{\n\tprivate_credential_factory_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.create = _create,\n\t\t\t.create_builder_enumerator = _create_builder_enumerator,\n\t\t\t.add_builder = _add_builder,\n\t\t\t.remove_builder = _remove_builder,\n\t\t\t.destroy = _destroy,\n\t\t},\n\t\t.constructors = linked_list_create(),\n\t\t.recursive = thread_value_create(NULL),\n\t\t.lock = rwlock_create(RWLOCK_TYPE_DEFAULT),\n\t);\n\n\treturn &this->public;\n}", "extracted_prediction": "The `credential_factory_create()` function initializes a credential factory structure with essential components:  \n- A linked list for managing builders (`constructors`).  \n- A thread-safe lock (`lock`) for concurrency control.  \n- A recursive value (`recursive`) for handling nested operations.  \n- Public methods (`create`, `create_builder_enumerator`, etc.) for factory operations.  \nIt returns a pointer to the factory's public interface."}
{"index": 315, "input": "**User**: \nvoid _SlDrvHandleGeneralEvents(SlDeviceEvent_t *slGeneralEvent)\n{\n    _u8 i;\n\n    /* Iterate over all the extenal libs handlers */\n    for ( i = 0 ; i < sizeof(general_callbacks)/sizeof(general_callbacks[0]) ; i++ )\n    {\n        if (EVENT_PROPAGATION_BLOCK == general_callbacks[i](slGeneralEvent) )\n\t\t{\n        \t/* exit immediately and do not call the user specific handler as well */\n            return;\n\t\t}\n    }\n\n/* At last call the Application specific handler if registered */\n#ifdef sl_GeneralEvtHdlr\n    sl_GeneralEvtHdlr(slGeneralEvent);\n#endif\n\n}", "extracted_prediction": "The function `_SlDrvHandleGeneralEvents` processes a general event by:  \n1. Iterating through registered external library handlers to check if the event is propagated.  \n2. Exiting immediately if any handler returns `EVENT_PROPAGATION_BLOCK`.  \n3. Calling the application-specific handler if registered.  \n\n**Key points**:  \n- **Early exit**: Stops processing further handlers if an event is blocked.  \n- **Ordering**: External handlers are checked first, followed by the user-specific handler.  \n- **Conditional call**: The application handler is invoked only if `sl_GeneralEvtHdlr` is defined."}
{"index": 258, "input": "**User**: \nstatic int vfio_virt_config_write(struct vfio_pci_device *vdev, int pos,\n\t\t\t\t  int count, struct perm_bits *perm,\n\t\t\t\t  int offset, __le32 val)\n{\n\tmemcpy(vdev->vconfig + pos, &val, count);\n\treturn count;\n}", "extracted_prediction": "**Summary:**  \nThe function `vfio_virt_config_write` writes a 32-bit value (in little-endian format) to a specific position in the device's configuration space, using the provided permission bits. It returns the number of bytes written."}
{"index": 908, "input": "**User**: \nstatic strbuf strbuf_new( )\n{\n\tstrbuf buffer = calloc( 1, sizeof( struct strbuf_s ) );\n\tbuffer->size = STRBUF_GROWTH;\n\tbuffer->string = calloc( 1, buffer->size );\n\treturn buffer;\n}", "extracted_prediction": "The function `strbuf_new` allocates a new `strbuf` structure with initial size `STRBUF_GROWTH` and a null-terminated string. It uses `calloc` to initialize both the buffer and string to zero, returning the buffer pointer."}
{"index": 344, "input": "**User**: \nstatic void smc91c111_queue_tx(smc91c111_state *s, int packet)\n{\n    if (s->tx_fifo_len == NUM_PACKETS)\n        return;\n    s->tx_fifo[s->tx_fifo_len++] = packet;\n    smc91c111_do_tx(s);\n}", "extracted_prediction": "The function `smc91c111_queue_tx` adds a packet to the transmit FIFO of a network controller if there space remains. If the FIFO is full, it returns. Otherwise, it increments the FIFO index and triggers a transmit operation (`smc91c111_do_tx`). The function ensures packets are queued before transmission, with a maximum capacity defined by `NUM_PACKETS`."}
{"index": 938, "input": "**User**: \nstatic void bind_previous_governor(struct thermal_zone_device *tz,\n\t\t\t\t   const char *failed_gov_name)\n{\n\tif (tz->governor && tz->governor->bind_to_tz) {\n\t\tif (tz->governor->bind_to_tz(tz)) {\n\t\t\tdev_err(&tz->device,\n\t\t\t\t\"governor %s failed to bind and the previous one (%s) failed to bind again, thermal zone %s has no governor\\n\",\n\t\t\t\tfailed_gov_name, tz->governor->name, tz->type);\n\t\t\ttz->governor = NULL;\n\t\t}\n\t}\n}", "extracted_prediction": "The function `bind_previous_governor` checks if the current governor can bind to the thermal zone device. If it succeeds, it logs an error if the previous governor also fails to bind, and sets the governor to `NULL` in that case. The error message includes the failed governor name, the thermal zone type, and indicates no governor is available."}
{"index": 237, "input": "**User**: \nstatic char* CFArrayALPNCopyFirst(CFArrayRef alpnArray)\n{\n    CFIndex count = CFArrayGetCount(alpnArray);\n\n    if (count <= 0)\n        return NULL;\n\n    CFStringRef alpnVal = CFArrayGetValueAtIndex(alpnArray, 0);\n    return FromCFString(alpnVal, kCFStringEncodingASCII);\n}", "extracted_prediction": "**Summary:**  \nThe function retrieves the first element of a `CFArray` (assumed to contain protocol names), checks if the array is non-empty, and returns the first protocol name as an ASCII-encoded C-style string. If the array is empty, it returns `NULL`. This is commonly used in TLS protocol negotiation to select the initial protocol."}
{"index": 471, "input": "**User**: \nvoid kim_st_list_protocols(struct st_data_s *st_gdata, void *buf)\n{\n\tseq_printf(buf, \"[%d]\\nBT=%c\\nFM=%c\\nGPS=%c\\n\",\n\t\t\tst_gdata->protos_registered,\n\t\t\tst_gdata->is_registered[0x04] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x08] == true ? 'R' : 'U',\n\t\t\tst_gdata->is_registered[0x09] == true ? 'R' : 'U');\n}", "extracted_prediction": "The function `kim_st_list_protocols` prints the status of three protocols (BT, FM, GPS) in a formatted string. It uses `seq_printf` to output the protocol count and their registration status (`R` for registered, `U` for unregistered), based on the `st_gdata` structure's register flags. The output is structured as `[d] BT=... FM=... GPS=...`."}
{"index": 249, "input": "**User**: \nSDL_SYS_HapticMouse(void)\n{\n    int fd;\n    int device_index = 0;\n    SDL_hapticlist_item *item;\n\n    for (item = SDL_hapticlist; item; item = item->next) {\n        /* Open the device. */\n        fd = open(item->fname, O_RDWR, 0);\n        if (fd < 0) {\n            return SDL_SetError(\"Haptic: Unable to open %s: %s\",\n                                item->fname, strerror(errno));\n        }\n\n        /* Is it a mouse? */\n        if (EV_IsMouse(fd)) {\n            close(fd);\n            return device_index;\n        }\n\n        close(fd);\n\n        ++device_index;\n    }\n\n    return -1;\n}", "extracted_prediction": "**Summary:**  \nThe `SDL_SYS_HapticMouse` function iterates through a list of haptic device entries to find the first device that is a mouse. It opens each device, checks if it's a mouse using `EV_IsMouse`, and returns the index of the matching device. If no mouse device is found, it returns -1. This function is part of SDL's system-specific code for handling haptic input."}
{"index": 65, "input": "**User**: \nget_range_subtype(Oid rangeOid)\n{\n\tHeapTuple\ttp;\n\n\ttp = SearchSysCache1(RANGETYPE, ObjectIdGetDatum(rangeOid));\n\tif (HeapTupleIsValid(tp))\n\t{\n\t\tForm_pg_range rngtup = (Form_pg_range) GETSTRUCT(tp);\n\t\tOid\t\t\tresult;\n\n\t\tresult = rngtup->rngsubtype;\n\t\tReleaseSysCache(tp);\n\t\treturn result;\n\t}\n\telse\n\t\treturn InvalidOid;\n}", "extracted_prediction": "The function `get_range_subtype` retrieves the subtype of a range type identified by the `Oid` parameter. It uses a system cache to look up the type information, extracts the `rngsubtype` field from the `Form_pg_range` structure, and returns the result. If the cache is invalid, it returns `InvalidOid`. This is commonly used in PostgreSQL to access type-specific metadata."}
{"index": 506, "input": "**User**: \nstatic void add_addr(private_eap_radius_provider_t *this,\n\t\t\t\t\t hashtable_t *hashtable, uintptr_t id, host_t *host)\n{\n\tentry_t *entry;\n\n\tentry = get_or_create_entry(hashtable, id);\n\tentry->addrs->insert_last(entry->addrs, host);\n}", "extracted_prediction": "**Summary:**  \nThe `add_addr` function adds a host address to an entry in a hashtable for a radius provider. It uses `get_or_create_entry` to retrieve or create an entry with the specified ID, then inserts the host into the entry's `addrs` list."}
{"index": 61, "input": "**User**: \nstatic inline void usb_gadget_udc_stop(struct usb_udc *udc)\n{\n\tudc->gadget->ops->udc_stop(udc->gadget);\n}", "extracted_prediction": "The function `usb_gadget_udc_stop` stops the USB gadget by invoking the `udc_stop` method of the gadget's operations structure. It is a helper function within the USB gadget driver, delegating the stop operation to the device-specific implementation."}
{"index": 357, "input": "**User**: \nvoid HAL_PWREx_DisableMainRegulatorLowVoltage(void)\n{\n  *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;\n}", "extracted_prediction": "**Summary:**  \nDisables the main regulator low voltage detection by setting the `CR_MRLVDS_BB` register to `DISABLE` (0x00000000), preventing the system from entering low-voltage states. Part of the STM32 HAL Power Regulation Ex interface."}
{"index": 284, "input": "**User**: \nufshcd_scsi_cmd_status(struct ufshcd_lrb *lrbp, int scsi_status)\n{\n\tint result = 0;\n\n\tswitch (scsi_status) {\n\tcase SAM_STAT_CHECK_CONDITION:\n\t\tufshcd_copy_sense_data(lrbp);\n\t\t/* fallthrough */\n\tcase SAM_STAT_GOOD:\n\t\tresult |= DID_OK << 16 |\n\t\t\t  COMMAND_COMPLETE << 8 |\n\t\t\t  scsi_status;\n\t\tbreak;\n\tcase SAM_STAT_TASK_SET_FULL:\n\tcase SAM_STAT_BUSY:\n\tcase SAM_STAT_TASK_ABORTED:\n\t\tufshcd_copy_sense_data(lrbp);\n\t\tresult |= scsi_status;\n\t\tbreak;\n\tdefault:\n\t\tresult |= DID_ERROR << 16;\n\t\tbreak;\n\t} /* end of switch */\n\n\treturn result;\n}", "extracted_prediction": "**Summary:**  \nThe function `ufshcd_scsi_cmd_status` returns a bitmask representing SCSI command status and error flags based on the input `scsi_status`. It sets flags like `DID_OK`, `COMMAND_COMPLETE`, and `DID_ERROR` depending on the status (e.g., `SAM_STAT_GOOD`, `SAM_STAT_CHECK_CONDITION`, or `SAM_STAT_TASK_SET_FULL`). For non-OK statuses, it includes the actual SCSI status code in the result. The function handles various SCSI status codes and combines them into a single integer for return."}
{"index": 644, "input": "**User**: \nstatic void script__observe_property(js_State *J)\n{\n    const char *fmts[] = {\"none\", \"native\", \"bool\", \"string\", \"number\", NULL};\n    const mpv_format mf[] = {MPV_FORMAT_NONE, MPV_FORMAT_NODE, MPV_FORMAT_FLAG,\n                             MPV_FORMAT_STRING, MPV_FORMAT_DOUBLE};\n\n    mpv_format f = mf[checkopt(J, 3, \"none\", fmts, \"observe type\")];\n    int e = mpv_observe_property(jclient(J), jsL_checkuint64(J, 1),\n                                             js_tostring(J, 2),\n                                             f);\n    push_status(J, e);\n}", "extracted_prediction": "**Summary:**  \nThe `script__observe_property` function observes a property in MPV using a specified format (e.g., `none`, `native`, `bool`, `string`, `number`) and returns a status code. It retrieves the property value from JavaScript, applies the format, and calls MPV's `mpv_observe_property` to track the property's value, then pushes the result to the JavaScript stack."}
{"index": 633, "input": "**User**: \nstatic void make_per_cpu_thp(struct bau_control *smaster)\n{\n\tint cpu;\n\tsize_t hpsz = sizeof(struct hub_and_pnode) * num_possible_cpus();\n\n\tsmaster->thp = kzalloc_node(hpsz, GFP_KERNEL, smaster->osnode);\n\tfor_each_present_cpu(cpu) {\n\t\tsmaster->thp[cpu].pnode = uv_cpu_hub_info(cpu)->pnode;\n\t\tsmaster->thp[cpu].uvhub = uv_cpu_hub_info(cpu)->numa_blade_id;\n\t}\n}", "extracted_prediction": "**Summary:**  \nThe `make_per_cpu_thp` function allocates memory for per-CPU THP (Transparent Huge Pages) data, initializes each CPU's `pnode` and `uvhub` fields using CPU-specific information, and ensures proper memory allocation with `kzalloc_node` for kernel use."}
{"index": 841, "input": "**User**: \nstatic struct qxl_rect *drawable_set_clipping(struct qxl_device *qdev,\n\t\t\t\t\t      unsigned int num_clips,\n\t\t\t\t\t      struct qxl_bo *clips_bo)\n{\n\tstruct qxl_clip_rects *dev_clips;\n\tint ret;\n\n\tret = qxl_bo_kmap(clips_bo, (void **)&dev_clips);\n\tif (ret) {\n\t\treturn NULL;\n\t}\n\tdev_clips->num_rects = num_clips;\n\tdev_clips->chunk.next_chunk = 0;\n\tdev_clips->chunk.prev_chunk = 0;\n\tdev_clips->chunk.data_size = sizeof(struct qxl_rect) * num_clips;\n\treturn (struct qxl_rect *)dev_clips->chunk.data;\n}", "extracted_prediction": "The function `drawable_set_clipping` maps a buffer object (`clips_bo`) to access its data, initializes a structure (`qxl_clip_rects`) with the number of clipping rectangles, and returns a pointer to the data in a chunk. It ensures the buffer is mapped successfully, sets the number of rectangles, and initializes chunk metadata for subsequent use."}
{"index": 52, "input": "**User**: \nstatic enum hrtimer_restart ap_poll_timeout(struct hrtimer *unused)\n{\n\tif (!ap_suspend_flag)\n\t\ttasklet_schedule(&ap_tasklet);\n\treturn HRTIMER_NORESTART;\n}", "extracted_prediction": "**Summary:**  \nThe `ap_poll_timeout` function is an HRTimer handler that schedules a tasklet (`ap_tasklet`) if the `ap_suspend_flag` is not set. It returns `HRTIMER_NORESTART` to prevent re-scheduling, ensuring the timer does not restart upon expiration."}
{"index": 431, "input": "**User**: \nrounddown10(int n)\n{\n    int tens = 0;\n    /* tens = floor(log_10(n)) */\n    while (n >= 10) {\n        n = n / 10;\n        tens++;\n    }\n    /* result = 10**tens */\n    int i, result = 1;\n    for (i = 0; i < tens; i++) {\n        result *= 10;\n    }\n    return result;\n}", "extracted_prediction": "The function `rounddown10` calculates the largest power of 10 less than or equal to the input integer `n`. It works by dividing `n` by 10 repeatedly until it is less than 10, counting the number of divisions (`tens`) and then returns `10^tens`. This effectively rounds down `n` to the nearest power of 10. \n\n**Summary:**  \nThe function determines the largest power of 10 less than or equal to `n` by counting divisions by 10 until `n` is less than 10, then returns `10^tens`."}
{"index": 454, "input": "**User**: \nbool intel_gvt_in_force_nonpriv_whitelist(struct intel_gvt *gvt,\n\t\t\t\t\t  unsigned int offset)\n{\n\treturn in_whitelist(offset);\n}", "extracted_prediction": "The function `intel_gvt_in_force_nonpriv_whitelist` checks if a given `offset` is present in a non-privileged whitelist using the helper function `in_whitelist`. It returns `true` if the offset is in the whitelist, otherwise `false`. The function is used to determine whether a specific offset should be treated as non-privileged in the context of Intel GVT."}
{"index": 148, "input": "**User**: \nstatic rsRetVal doFail(instanceData *pData)\n{\n\tDEFiRet;\n\n\tdbgprintf(\"fail curr %d, frequency %d, bFailed %d\\n\", pData->iCurrCallNbr,\n\t\t  pData->iFailFrequency, pData->bFailed);\n\tif(pData->bFailed) {\n\t\tABORT_FINALIZE(RS_RET_SUSPENDED);\n\t} else {\n\t\tif(pData->iCurrCallNbr++ % pData->iFailFrequency == 0) {\n\t\t\tpData->iCurrRetries = 0;\n\t\t\tpData->bFailed = 1;\n\t\t\tiRet = RS_RET_SUSPENDED;\n\t\t}\n\t}\nfinalize_it:\n\tRETiRet;\n}", "extracted_prediction": "**Summary:**  \nThe `doFail` function checks if a failure has occurred. If `bFailed` is true, it aborts the operation. If not, it increments the current call number. If the call number modulo `iFailFrequency` equals zero, it resets the retry count and sets `bFailed` to true, then returns `RS_RET_SUSPENDED`. The function uses debugging output to track the state."}
{"index": 718, "input": "**User**: \ndup_state_stack (struct unw_reg_state *rs)\n{\n\tstruct unw_reg_state *copy, *prev = NULL, *first = NULL;\n\n\twhile (rs) {\n\t\tcopy = alloc_reg_state();\n\t\tif (!copy) {\n\t\t\tprintk(KERN_ERR \"unwind.dup_state_stack: out of memory\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(copy, rs, sizeof(*copy));\n\t\tif (first)\n\t\t\tprev->next = copy;\n\t\telse\n\t\t\tfirst = copy;\n\t\trs = rs->next;\n\t\tprev = copy;\n\t}\n\treturn first;\n}", "extracted_prediction": "The function `dup_state_stack` creates a copy of a state stack by traversing the original stack, allocating new `unw_reg_state` structures, and linking them in sequence. It allocates memory for each state, copies the data from the original, and returns the first element of the new stack. If memory allocation fails, it returns `NULL`."}
{"index": 475, "input": "**User**: \nstatic int compile(char *src, char *dst) {\n\tcompose(com, clist, append(src, 0), append(dst, 0));\n\treturn callsys(av);\n}", "extracted_prediction": "The `compile` function takes source (`src`) and destination (`dst`) strings, appends null terminators, combines them with a list of commands, and invokes a system call (`callsys(av)`) to execute the compilation. It returns the result of the system call."}
{"index": 299, "input": "**User**: \nstatic chunk_t build_Request(private_x509_ocsp_request_t *this,\n\t\t\t\t\t\t\t chunk_t issuerNameHash, chunk_t issuerKeyHash,\n\t\t\t\t\t\t\t chunk_t serialNumber)\n{\n\treturn asn1_wrap(ASN1_SEQUENCE, \"m\",\n\t\t\t\tasn1_wrap(ASN1_SEQUENCE, \"mmmm\",\n\t\t\t\t\tasn1_algorithmIdentifier(OID_SHA1),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerNameHash),\n\t\t\t\t\tasn1_simple_object(ASN1_OCTET_STRING, issuerKeyHash),\n\t\t\t\t\tasn1_simple_object(ASN1_INTEGER, serialNumber)));\n}", "extracted_prediction": "The `build_Request` function constructs an ASN.1-encoded structure for an OCSP request. It creates a nested sequence (`ASN1_SEQUENCE`) with the following components:\n1. **Outer sequence** (`\"m\"`): Contains a nested sequence (`\"mmmm\"`).\n2. **Inner sequence** (`\"mmmm\"`): Includes:\n   - **SHA1 algorithm identifier** (`OID_SHA1`).\n   - **OCTET_STRING** for `issuerNameHash`.\n   - **OCTET_STRING** for `issuerKeyHash`.\n   - **INTEGER** for `serialNumber`.\n\nThis structure is used to serialize the OCSP request data in ASN.1 format."}
{"index": 366, "input": "**User**: \nstatic inline void lru_add(struct ashmem_range *range)\n{\n\tlist_add_tail(&range->lru, &ashmem_lru_list);\n\tlru_count += range_size(range);\n}", "extracted_prediction": "The function `lru_add` adds a `struct ashmem_range` to the LRU (Least Recently Used) list using `list_add_tail` and increments a global counter `lru_count` by the size of the range."}
{"index": 502, "input": "**User**: \nvoid luaR_next(lua_State *L, ROTable *rotable, TValue *key, TValue *val) {\n  unsigned keypos;\n\n  /* Special case: if key is nil, return the first element of the rotable */\n  if (ttisnil(key))\n    luaR_next_helper(L, rotable, 0, key, val);\n  else if (ttisstring(key)) {\n    /* Find the previous key again */\n    if (ttisstring(key)) {\n      luaR_findentry(rotable, rawtsvalue(key), &keypos);\n    }\n    /* Advance to next key */\n    keypos ++;\n    luaR_next_helper(L, rotable, keypos, key, val);\n  }\n}", "extracted_prediction": "The `luaR_next` function navigates through a table's entries. It handles two cases:  \n1. **Nil key**: Calls a helper function to start from the first element.  \n2. **String key**: Finds the previous key position, advances to the next, and returns the result.  \nThe function uses a helper to manage the actual traversal logic."}
{"index": 974, "input": "**User**: \nvoid frame_vector_destroy(struct frame_vector *vec)\n{\n\t/* Make sure put_vaddr_frames() got called properly... */\n\tVM_BUG_ON(vec->nr_frames > 0);\n\tkvfree(vec);\n}", "extracted_prediction": "**Summary:**  \nThe `frame_vector_destroy` function frees the memory allocated for a frame vector, ensuring it is not empty (via `VM_BUG_ON`) and uses `kvfree` to release the memory."}
{"index": 369, "input": "**User**: \nstatic unsigned ODDescriptorLength( unsigned *pi_data, const uint8_t **pp_data )\n{\n    unsigned int i_b;\n    unsigned int i_len = 0;\n\n    if(*pi_data == 0)\n        return 0;\n\n    do\n    {\n        i_b = **pp_data;\n        (*pp_data)++;\n        (*pi_data)--;\n        i_len = ( i_len << 7 ) + ( i_b&0x7f );\n\n    } while( i_b&0x80 && *pi_data > 0 );\n\n    if (i_len > *pi_data)\n        i_len = *pi_data;\n\n    return i_len;\n}", "extracted_prediction": "The function `ODDescriptorLength` calculates the length of a descriptor by processing bytes from a buffer. It shifts and accumulates 7 bits at a time from the input data, stopping when a byte's 8th bit is set (indicating data continuation) or the input is exhausted. The result is clamped to the remaining data length if it exceeds the available data."}
{"index": 729, "input": "**User**: \nxo_style_is_encoding (xo_handle_t *xop)\n{\n    if (xo_style(xop) == XO_STYLE_JSON\n\t|| xo_style(xop) == XO_STYLE_XML\n\t|| xo_style(xop) == XO_STYLE_SDPARAMS\n\t|| xo_style(xop) == XO_STYLE_ENCODER)\n\treturn 1;\n    return 0;\n}", "extracted_prediction": "The function `xo_style_is_encoding` checks if the xop's style is one of JSON, XML, SDPARAMS, or ENCODER, returning 1 if true (indicating encoding is required) and 0 otherwise."}
{"index": 319, "input": "**User**: \nskl_wa_827(struct drm_i915_private *dev_priv, enum pipe pipe, bool enable)\n{\n\tif (enable)\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) |\n\t\t\t   DUPS1_GATING_DIS | DUPS2_GATING_DIS);\n\telse\n\t\tI915_WRITE(CLKGATE_DIS_PSL(pipe),\n\t\t\t   I915_READ(CLKGATE_DIS_PSL(pipe)) &\n\t\t\t   ~(DUPS1_GATING_DIS | DUPS2_GATING_DIS));\n}", "extracted_prediction": "The function `skl_wa_827` toggles clock gating for a specified pipe (e.g., DP, LVDS, or other) on an Intel i915 GPU. It modifies the `CLKGATE_DIS_PSL` register to enable or disable dual-pump (DUPS) clock gating for the pipe. When `enable` is `true`, the `DUPS1_GATING_DIS` and `DUPS2_GATING_DIS` bits are set; when `false`, they are cleared. This is part of a workaround for SKL GPU hardware limitations."}
{"index": 810, "input": "**User**: \nstatic u32 vfp_single_fmac(int sd, int sn, s32 m, u32 fpscr)\n{\n\treturn vfp_single_multiply_accumulate(sd, sn, m, fpscr, 0, \"fmac\");\n}", "extracted_prediction": "The function `vfp_single_fmac` performs a VFP (Vector Floating Point) single-precision multiply-accumulate operation. It takes parameters `sd`, `sn`, `m`, and `fpscr` (Floating Point Status Register), and returns a 32-bit unsigned integer. The operation uses the \"fmac\" label to denote the operation, likely involving source and destination registers `sd` and `sn` with multiplier `m` and status register `fpscr`."}
{"index": 287, "input": "**User**: \nstatic void UART_EndTxTransfer(UART_HandleTypeDef *huart)\n{\n  /* Disable TXEIE and TCIE interrupts */\n  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));\n\n  /* At end of Tx process, restore huart->gState to Ready */\n  huart->gState = HAL_UART_STATE_READY;\n}", "extracted_prediction": "The function `UART_EndTxTransfer` disables the transmit data register not empty (TXEIE) and transmit complete (TCIE) interrupts, then resets the UART's state to `HAL_UART_STATE_READY` to indicate the transmission is complete."}
{"index": 131, "input": "**User**: \nstatic int smu7_get_memory_type(struct pp_hwmgr *hwmgr)\n{\n\tstruct smu7_hwmgr *data = (struct smu7_hwmgr *)(hwmgr->backend);\n\tstruct amdgpu_device *adev = hwmgr->adev;\n\n\tdata->is_memory_gddr5 = (adev->gmc.vram_type == AMDGPU_VRAM_TYPE_GDDR5);\n\n\treturn 0;\n}", "extracted_prediction": "The function `smu7_get_memory_type` checks if the VRAM type is GDDR5 and sets a flag in the SMU7 HWMGR data structure, returning 0."}
{"index": 928, "input": "**User**: \nstatic void ice_vsi_set_num_desc(struct ice_vsi *vsi)\n{\n\tswitch (vsi->type) {\n\tcase ICE_VSI_PF:\n\t\t/* fall through */\n\tcase ICE_VSI_LB:\n\t\tvsi->num_rx_desc = ICE_DFLT_NUM_RX_DESC;\n\t\tvsi->num_tx_desc = ICE_DFLT_NUM_TX_DESC;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&vsi->back->pdev->dev,\n\t\t\t\"Not setting number of Tx/Rx descriptors for VSI type %d\\n\",\n\t\t\tvsi->type);\n\t\tbreak;\n\t}\n}", "extracted_prediction": "The function `ice_vsi_set_num_desc` sets default number of Rx/Tx descriptors for specific VSI types (PF, LB) and logs a debug message for unsupported types. It assigns `ICE_DFLT_NUM_RX_DESC` and `ICE_DFLT_NUM_TX_DESC` to `vsi->num_rx_desc` and `vsi->num_tx_desc` for PF/LB VSIs, while logging a warning for other VSI types."}
{"index": 736, "input": "**User**: \nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)\n{\n  /* Check the parameters */\n  assert_param(IS_I2C_ALL_PERIPH(I2Cx));\n  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));\n  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)\n  {\n    /* Drive the SMBusAlert pin Low */\n    I2Cx->CR1 |= I2C_SMBusAlert_Low;\n  }\n  else\n  {\n    /* Drive the SMBusAlert pin High  */\n    I2Cx->CR1 &= I2C_SMBusAlert_High;\n  }\n}", "extracted_prediction": "**Summary:**  \nThe `I2C_SMBusAlertConfig` function configures the SMBus alert pin for an I2C peripheral. It validates input parameters and sets the `CR1` register to drive the SMBusAlert pin to either Low or High based on the provided value. The function ensures correct configuration of the I2C peripheral's SMBus alert behavior."}
{"index": 814, "input": "**User**: \nstatic int agent_thread_cmd_listen_reply(int fd,\n                                         uint32_t addr, int32_t udp_port)\n{\n    int ret;\n\n    opal_btl_usnic_connectivity_cmd_listen_reply_t cmd = {\n        .cmd = CONNECTIVITY_AGENT_CMD_LISTEN,\n        .ipv4_addr = addr,\n        .udp_port = udp_port\n    };\n\n    ret = opal_fd_write(fd, sizeof(cmd), &cmd);\n    if (OPAL_SUCCESS != ret) {\n        OPAL_ERROR_LOG(ret);\n        ABORT(\"usnic connectivity agent IPC write failed\");\n        /* Will not return */\n    }\n\n    return OPAL_SUCCESS;\n}", "extracted_prediction": "**Summary:**  \nThe `agent_thread_cmd_listen_reply` function sends a connectivity agent command to a file descriptor, initializing a structure with the specified IP address and UDP port. It writes the structure to the FD using `opal_fd_write`, which returns success or aborts on failure with an error log. The function returns `OPAL_SUCCESS` on success."}
{"index": 647, "input": "**User**: \nstatic int group_can_go_on(struct perf_event *event,\n\t\t\t   struct perf_cpu_context *cpuctx,\n\t\t\t   int can_add_hw)\n{\n\t/*\n\t * Groups consisting entirely of software events can always go on.\n\t */\n\tif (event->group_caps & PERF_EV_CAP_SOFTWARE)\n\t\treturn 1;\n\t/*\n\t * If an exclusive group is already on, no other hardware\n\t * events can go on.\n\t */\n\tif (cpuctx->exclusive)\n\t\treturn 0;\n\t/*\n\t * If this group is exclusive and there are already\n\t * events on the CPU, it can't go on.\n\t */\n\tif (event->attr.exclusive && cpuctx->active_oncpu)\n\t\treturn 0;\n\t/*\n\t * Otherwise, try to add it if all previous groups were able\n\t * to go on.\n\t */\n\treturn can_add_hw;\n}", "extracted_prediction": "The function `group_can_go_on` determines whether a performance event group can proceed based on the following conditions:\n1. **Software events** (via `PERF_EV_CAP_SOFTWARE`) are always allowed.\n2. **Exclusive groups** (via `cpuctx->exclusive`) disallow hardware event addition.\n3. **Exclusive groups with active events** on the CPU prevent further addition.\n4. Returns `can_add_hw` if none of the above conditions apply."}
{"index": 11, "input": "**User**: \nstatic enum ap_wait ap_sm_nop(struct ap_queue *aq)\n{\n\treturn AP_WAIT_NONE;\n}", "extracted_prediction": "The `ap_sm_nop` function returns `AP_WAIT_NONE`, indicating no waiting is required in the application protocol state machine. It is a static helper function that operates on a `struct ap_queue` pointer, likely managing queue operations in the protocol stack."}
{"index": 537, "input": "**User**: \nstatic int dln2_spi_set_mode(struct dln2_spi *dln2, u8 mode)\n{\n\tstruct {\n\t\tu8 port;\n\t\tu8 mode;\n\t} tx;\n\n\ttx.port = dln2->port;\n\ttx.mode = mode;\n\n\treturn dln2_transfer_tx(dln2->pdev, DLN2_SPI_SET_MODE, &tx, sizeof(tx));\n}", "extracted_prediction": "The function `dln2_spi_set_mode` sets the SPI mode for a device by sending a transaction containing the port and mode parameters over the SPI bus. It constructs a structure `tx` with the port value from `dln2->port` and the provided mode, then calls `dln2_transfer_tx` to transmit the data. The function returns the result of the transfer."}
{"index": 348, "input": "**User**: \nBOOL getAccessibleTableRowSelections(long vmID, AccessibleTable table, jint count, jint *selections) {\n        if (theAccessBridgeInitializedFlag == TRUE) {\n            return theAccessBridge.getAccessibleTableRowSelections(vmID, table, count, selections);\n        }\n        return FALSE;\n    }", "extracted_prediction": "The function checks if the AccessBridge is initialized. If true, it calls the bridge's method to retrieve row selections for the specified table and count, otherwise returns false."}
{"index": 275, "input": "**User**: \nscroll_up_dashboard (void)\n{\n  gscroll.dash--;\n}", "extracted_prediction": "The `scroll_up_dashboard` function decrements the `dash` counter in the `gscroll` structure to indicate scrolling up."}
{"index": 764, "input": "**User**: \nvoid rproc_add_subdev(struct rproc *rproc, struct rproc_subdev *subdev)\n{\n\tlist_add_tail(&subdev->node, &rproc->subdevs);\n}", "extracted_prediction": "The function `rproc_add_subdev` adds a subdevice to the list of subdevices within a resource processor (rproc) by appending it to the end of the list using `list_add_tail`. It takes two parameters: a pointer to the rproc structure and a pointer to the subdevice structure."}
{"index": 477, "input": "**User**: \nstatic int tcm_qla2xxx_npiv_extract_wwn(const char *ns, u64 *nm)\n{\n\tunsigned int i, j;\n\tu8 wwn[8];\n\n\tmemset(wwn, 0, sizeof(wwn));\n\n\t/* Validate and store the new name */\n\tfor (i = 0, j = 0; i < 16; i++) {\n\t\tint value;\n\n\t\tvalue = hex_to_bin(*ns++);\n\t\tif (value >= 0)\n\t\t\tj = (j << 4) | value;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (i % 2) {\n\t\t\twwn[i/2] = j & 0xff;\n\t\t\tj = 0;\n\t\t}\n\t}\n\n\t*nm = wwn_to_u64(wwn);\n\treturn 0;\n}", "extracted_prediction": "**Summary:**  \nThe function `tcm_qla2xxx_npiv_extract_wwn` extracts a World Wide Name (WWN) from a hexadecimal string input (`ns`) and stores it in a 64-bit integer (`nm`). It processes 16 characters in pairs, converting each to a 8-bit byte, and converts the resulting 8-byte WWN to a 64-bit integer. Invalid input (non-hex characters) returns `-EINVAL`."}
{"index": 152, "input": "**User**: \nvoid rio_local_set_device_id(struct rio_mport *port, u16 did)\n{\n\trio_local_write_config_32(port, RIO_DID_CSR,\n\t\t\t\t  RIO_SET_DID(port->sys_size, did));\n}", "extracted_prediction": "The function `rio_local_set_device_id` sets the device ID (did) for a port by writing to the `RIO_DID_CSR` register. It calculates the value using `RIO_SET_DID(port->sys_size, did)` to configure the device ID based on the port's system size."}
{"index": 701, "input": "**User**: \nvoid __init omap3_prm_reset_modem(void)\n{\n\tomap2_prm_write_mod_reg(\n\t\tOMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RSTPWRON_MASK |\n\t\tOMAP3430_RM_RSTCTRL_CORE_MODEM_SW_RST_MASK,\n\t\t\t\tCORE_MOD, OMAP2_RM_RSTCTRL);\n\tomap2_prm_write_mod_reg(0, CORE_MOD, OMAP2_RM_RSTCTRL);\n}", "extracted_prediction": "The function `omap3_prm_reset_modem` initializes the modem reset control registers in the OMAP3 hardware. It performs two operations:\n1. **Enables reset and power-on** for the modem by setting specific bits in the reset control register.\n2. **Disables the reset** by writing 0 to the same register. \n\nThis ensures the modem is properly configured for reset and power management during initialization."}
{"index": 33, "input": "**User**: \nsize_t rand_pool_length(RAND_POOL *pool)\n{\n    return pool->len;\n}", "extracted_prediction": "The function `rand_pool_length` returns the length of the random number pool stored in the `len` member of the `RAND_POOL` structure. It provides a read-only access to the size of the pool."}
{"index": 310, "input": "**User**: \nstatic void rs_close(struct tty_struct *tty, struct file * filp)\n{\n\tspin_lock_bh(&timer_lock);\n\tif (tty->count == 1)\n\t\tdel_timer_sync(&serial_timer);\n\tspin_unlock_bh(&timer_lock);\n}", "extracted_prediction": "**Summary:**  \nThe `rs_close` function is called when a file is closed, managing the cleanup of a serial port driver. It locks the timer lock, checks if the tty's reference count is 1 (indicating the device is closed), and removes the timer if necessary. This ensures proper resource cleanup and prevents premature timer expiration."}
{"index": 538, "input": "**User**: \nstatic struct net_device *br2684_find_dev(const struct br2684_if_spec *s)\n{\n\tstruct list_head *lh;\n\tstruct net_device *net_dev;\n\tswitch (s->method) {\n\tcase BR2684_FIND_BYNUM:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (BRPRIV(net_dev)->number == s->spec.devnum)\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\tcase BR2684_FIND_BYIFNAME:\n\t\tlist_for_each(lh, &br2684_devs) {\n\t\t\tnet_dev = list_entry_brdev(lh);\n\t\t\tif (!strncmp(net_dev->name, s->spec.ifname, IFNAMSIZ))\n\t\t\t\treturn net_dev;\n\t\t}\n\t\tbreak;\n\t}\n\treturn NULL;\n}", "extracted_prediction": "**Summary:**  \nThe `br2684_find_dev` function searches for a network device in a list (`br2684_devs`) based on a specified method (e.g., by device number or interface name). It iterates through the list, matching entries against the provided criteria, and returns the first matching device. If no match is found, it returns `NULL`. The function uses a linked list to traverse the devices and leverages `strncmp` for case-insensitive name matching."}
{"index": 228, "input": "**User**: \nstatic void vmw_swap_notify(struct ttm_buffer_object *bo)\n{\n\tvmw_bo_swap_notify(bo);\n\t(void) ttm_bo_wait(bo, false, false);\n}", "extracted_prediction": "The `vmw_swap_notify` function triggers a swap operation on a buffer object and waits for it to be ready, using a helper function and ignoring the return value of the wait operation. It is part of a graphics driver for buffer object management."}
{"index": 298, "input": "**User**: \npb_tnc_msg_t* pb_remediation_parameters_msg_create_from_uri(chunk_t uri)\n{\n\tpen_type_t type = { PEN_IETF, PB_REMEDIATION_URI };\n\n\treturn pb_remediation_parameters_msg_create(type, uri);\n}", "extracted_prediction": "The function `pb_remediation_parameters_msg_create_from_uri` creates a remediation parameters message using the IETF type and a provided URI. It returns a pointer to the newly created message. The function internally uses `pb_remediation_parameters_msg_create` with the specified type and URI."}
{"index": 508, "input": "**User**: \nstatic void list_splice_entire_tail(struct list_head *from,\n\t\t\t\t    struct list_head *to)\n{\n\tstruct list_head *from_last = from->prev;\n\n\tlist_splice_tail(from_last, to);\n\tlist_add_tail(from_last, to);\n}", "extracted_prediction": "The function `list_splice_entire_tail` aims to splice the entire `from` list into the `to` list. It does this by:  \n1. **Finding the last element** of the `from` list (`from->prev`).  \n2. **Splicing the entire `from` list** into `to` using `list_splice_tail(from_last, to)`.  \n3. **Adding the last element** of `from` (i.e., `from_last`) to the tail of `to` again.  \n\n**Note:** This code is likely incorrect, as splicing the entire `from` list via `list_splice_tail(from_last, to)` would only add the last element, and adding `from_last` again would duplicate it. The intended behavior may require a different approach."}
{"index": 761, "input": "**User**: \nvoid print_key(uint8_t *client_id)\n{\n    uint32_t j;\n\n    for (j = 0; j < 32; j++) {\n        printf(\"%02hhX\", client_id[j]);\n    }\n}", "extracted_prediction": "The `print_key` function outputs a client ID in hexadecimal format by iterating through 32 bytes. It uses the format string `%02hhX` to display each byte as two hex digits, resulting in a 64-character output. The function is designed to display the client ID for debugging or display purposes."}
{"index": 816, "input": "**User**: \nstatic void omap4_prm_write_inst_reg(u32 val, s16 inst, u16 reg)\n{\n\twritel_relaxed(val, prm_base.va + inst + reg);\n}", "extracted_prediction": "**Summary:**  \nThe `omap4_prm_write_inst_reg` function writes a value to a specific register in the OMAP4 PRM module. It uses `writel_relaxed` to perform a non-atomic write operation, ensuring safe concurrent access. The function takes three parameters: the value to write (`val`), the instance number (`inst`), and the register offset (`reg`). The write address is calculated as `prm_base.va + inst + reg`."}
{"index": 202, "input": "**User**: \nstatic void __init omap3_ctrl_set_iva_bootmode_idle(void)\n{\n\tomap_ctrl_writel(OMAP3_IVA2_BOOTMOD_IDLE,\n\t\t\t OMAP343X_CONTROL_IVA2_BOOTMOD);\n}", "extracted_prediction": "The function `omap3_ctrl_set_iva_bootmode_idle` sets the IVA2 boot mode to idle by writing a specific value to a kernel initialization register. It is used in the early boot process of the OMAP3 series to configure hardware behavior."}
{"index": 145, "input": "**User**: \nstatic KMETHOD KvirSecretGetUsageType(KonohaContext *kctx,  KonohaStack *sfp)\n{\n\tvirSecretPtr arg0 = To_virSecretPtr(sfp[0]);\n\tint ret = virSecretGetUsageType (arg0);\n\tRETURNint(ret);\n}", "extracted_prediction": "The function `KvirSecretGetUsageType` retrieves the usage type of a secret (via `virSecretGetUsageType`) and returns the result as an integer. It is part of the Konoha library for managing virtualization secrets."}
{"index": 8, "input": "**User**: \nstatic int ni65_open(struct net_device *dev)\n{\n\tstruct priv *p = dev->ml_priv;\n\tint irqval = request_irq(dev->irq, ni65_interrupt,0,\n                        cards[p->cardno].cardname,dev);\n\tif (irqval) {\n\t\tprintk(KERN_ERR \"%s: unable to get IRQ %d (irqval=%d).\\n\",\n\t\t          dev->name,dev->irq, irqval);\n\t\treturn -EAGAIN;\n\t}\n\n\tif(ni65_lance_reinit(dev))\n\t{\n\t\tnetif_start_queue(dev);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfree_irq(dev->irq,dev);\n\t\treturn -EAGAIN;\n\t}\n}", "extracted_prediction": "The `ni65_open` function opens a network device and initializes its interrupt handling:  \n1. **IRQ Request**: Requests an interrupt (IRQ) for the device. If failed, returns `-EAGAIN`.  \n2. **Reinitialization Check**: Calls `ni65_lance_reinit` to reinitialize the device. If successful, starts the queue (`netif_start_queue`) and returns `0`.  \n3. **Resource Cleanup**: If reinitialization fails, frees the IRQ (`free_irq`) and returns `-EAGAIN`.  \n\nKey points:  \n- Uses `request_irq` to allocate IRQs, with error handling.  \n- Depends on `ni65_lance_reinit` for device reconfiguration.  \n- Returns `0` on success or `-EAGAIN` on failure."}
{"index": 812, "input": "**User**: \nvoid clear_keyboard_but_mods_and_keys() {\n    clear_weak_mods();\n    clear_macro_mods();\n    send_keyboard_report();\n#ifdef MOUSEKEY_ENABLE\n    mousekey_clear();\n    mousekey_send();\n#endif\n#ifdef EXTRAKEY_ENABLE\n    host_system_send(0);\n    host_consumer_send(0);\n#endif\n}", "extracted_prediction": "The function `clear_keyboard_but_mods_and_keys` performs the following:  \n1. Clears weak and macro modifiers.  \n2. Sends a keyboard report.  \n3. Clears and sends mouse keys if `MOUSEKEY_ENABLE` is enabled.  \n4. Sends signals to host system and consumer if `EXTRAKEY_ENABLE` is enabled.  \n\nThis function handles keyboard and peripheral (mouse/extra keys) state clearing based on hardware enable flags."}
{"index": 254, "input": "**User**: \nvoid OS_COM_Send1(OS_U8 c) {\n  OS_USEPARA(c);           // Avoid compiler warning\n  OS_COM_ClearTxActive();  // Let embOS know that Tx is not busy\n}", "extracted_prediction": "The function `OS_COM_Send1` clears the transmission active status to indicate that the transmission is not in progress, while avoiding a compiler warning via `OS_USEPARA(c)`."}
{"index": 391, "input": "**User**: \nstatic u32 vfp_single_fsub(int sd, int sn, s32 m, u32 fpscr)\n{\n\t/*\n\t * Subtraction is addition with one sign inverted.\n\t */\n\treturn vfp_single_fadd(sd, sn, vfp_single_packed_negate(m), fpscr);\n}", "extracted_prediction": "The function `vfp_single_fsub` performs a single-precision floating-point subtraction using the VFP instruction set. It inverts the sign of the mantissa (`m`) using `vfp_single_packed_negate` and adds it to the operands specified by `sd` and `sn` with the `fpscr` status register. The result is returned as a 32-bit unsigned integer."}
{"index": 580, "input": "**User**: \nstatic void initio_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *host = pci_get_drvdata(pdev);\n\tstruct initio_host *s = (struct initio_host *)host->hostdata;\n\tscsi_remove_host(host);\n\tfree_irq(pdev->irq, host);\n\trelease_region(s->addr, 256);\n\tscsi_host_put(host);\n\tpci_disable_device(pdev);\n}", "extracted_prediction": "The `initio_remove_one` function handles the cleanup of a PCI device when it is removed from the system. It performs the following steps:  \n1. Unregisters the SCSI host and frees associated resources.  \n2. Releases the interrupt line and memory region allocated for the device.  \n3. Decrements the reference count for the SCSI host and releases its resources.  \n4. Disables the PCI device to prevent further use.  \n\nThis function ensures proper resource cleanup and system integrity during device removal."}
{"index": 204, "input": "**User**: \nstatic inline void t_gen_add_flag(TCGv d, int flag)\n{\n    TCGv c;\n\n    c = tcg_temp_new();\n    t_gen_mov_TN_preg(c, PR_CCS);\n    /* Propagate carry into d.  */\n    tcg_gen_andi_tl(c, c, 1 << flag);\n    if (flag) {\n        tcg_gen_shri_tl(c, c, flag);\n    }\n    tcg_gen_add_tl(d, d, c);\n    tcg_temp_free(c);\n}", "extracted_prediction": "The function `t_gen_add_flag` adds a flag to a register `d` by:  \n1. Creating a temporary register `c` and setting it to `1 << flag`.  \n2. If the flag is non-zero, shifting `c` right by `flag` bits (resulting in `1`).  \n3. Adding `c` to `d` to set the flag bit in the result.  \n\n**Summary:**  \nThe function adds a flag to a register `d` by setting a temporary register to `1 << flag`, shifting it to `1` if the flag is non-zero, and then adding it to `d` to set the flag bit."}
{"index": 364, "input": "**User**: \nvips_precision_get_type( void )\n{\n\tstatic GType etype = 0;\n\n\tif( etype == 0 ) {\n\t\tstatic const GEnumValue values[] = {\n\t\t\t{VIPS_PRECISION_INTEGER, \"VIPS_PRECISION_INTEGER\", \"integer\"},\n\t\t\t{VIPS_PRECISION_FLOAT, \"VIPS_PRECISION_FLOAT\", \"float\"},\n\t\t\t{VIPS_PRECISION_APPROXIMATE, \"VIPS_PRECISION_APPROXIMATE\", \"approximate\"},\n\t\t\t{VIPS_PRECISION_LAST, \"VIPS_PRECISION_LAST\", \"last\"},\n\t\t\t{0, NULL, NULL}\n\t\t};\n\t\t\n\t\tetype = g_enum_register_static( \"VipsPrecision\", values );\n\t}\n\n\treturn( etype );\n}", "extracted_prediction": "The function `vips_precision_get_type()` registers a static `GEnumType` for the `VipsPrecision` enum (integer, float, approximate, last) and returns its type ID. It ensures the enum is registered only once, avoiding redundant registration."}
{"index": 218, "input": "**User**: \nvoid hns_mac_get_autoneg(struct hns_mac_cb *mac_cb, u32 *auto_neg)\n{\n\tstruct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);\n\n\tif (mac_ctrl_drv->autoneg_stat)\n\t\tmac_ctrl_drv->autoneg_stat(mac_ctrl_drv, auto_neg);\n\telse\n\t\t*auto_neg = 0;\n}", "extracted_prediction": "The function `hns_mac_get_autoneg` checks if the autonegiation state is enabled for the MAC driver. If enabled, it returns the current autonegiation status via the `auto_neg` pointer. If disabled, it sets `auto_neg` to 0."}
{"index": 381, "input": "**User**: \nvoid gitno_consume_n(gitno_buffer *buf, size_t cons)\n{\n\tmemmove(buf->data, buf->data + cons, buf->len - buf->offset);\n\tmemset(buf->data + cons, 0x0, buf->len - buf->offset);\n\tbuf->offset -= cons;\n}", "extracted_prediction": "The function `gitno_consume_n` consumes `cons` bytes from a buffer by:  \n1. Shifting data from the current position to the end of the buffer.  \n2. Clearing the consumed bytes with zeros.  \n3. Decrementing the buffer's offset to reflect the consumed data.  \n\nThis operation efficiently removes `cons` bytes from the buffer's data."}
{"index": 859, "input": "**User**: \nstatic void adapter_remove_and_free_device(struct AdapterCtlBlk *acb,\n\t\tstruct DeviceCtlBlk *dcb)\n{\n\tif (list_size(&dcb->srb_going_list) > 1) {\n\t\tdprintkdbg(DBG_1, \"adapter_remove_and_free_device: <%02i-%i> \"\n\t\t           \"Won't remove because of %i active requests.\\n\",\n\t\t\t   dcb->target_id, dcb->target_lun,\n\t\t\t   list_size(&dcb->srb_going_list));\n\t\treturn;\n\t}\n\tadapter_remove_device(acb, dcb);\n\tkfree(dcb);\n}", "extracted_prediction": "**Summary:**  \nThe function `adapter_remove_and_free_device` checks if there are active requests (`list_size > 1`) in the `srb_going_list` of a `DeviceCtlBlk` structure. If not, it removes the device using `adapter_remove_device` and frees the `DeviceCtlBlk` structure with `kfree`. The debug message is logged if there are active requests, preventing premature device removal."}
{"index": 833, "input": "**User**: \nunsigned long long kbuffer_timestamp(struct kbuffer *kbuf)\n{\n\treturn kbuf->timestamp;\n}", "extracted_prediction": "The function `kbuffer_timestamp` returns the timestamp stored in the `kbuffer` structure, typically used to track time-based data in a kernel module."}
{"index": 28, "input": "**User**: \nstatic int amd76x_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tedac_dbg(0, \"\\n\");\n\n\t/* don't need to call pci_enable_device() */\n\treturn amd76x_probe1(pdev, ent->driver_data);\n}", "extracted_prediction": "The `amd76x_init_one` function initializes a PCI device for the AMD76x driver. It logs a debug message and calls `amd76x_probe1` with the device and driver data, returning the result of the probe. The function does not explicitly enable the PCI device, implying the driver handles this internally."}
{"index": 593, "input": "**User**: \nstatic int mei_cl_device_remove(struct device *dev)\n{\n\tstruct mei_cl_device *cldev = to_mei_cl_device(dev);\n\tstruct mei_cl_driver *cldrv;\n\tint ret = 0;\n\n\tif (!cldev || !dev->driver)\n\t\treturn 0;\n\n\tcldrv = to_mei_cl_driver(dev->driver);\n\tif (cldrv->remove)\n\t\tret = cldrv->remove(cldev);\n\n\tmei_cldev_unregister_callbacks(cldev);\n\n\tmei_cl_bus_module_put(cldev);\n\tmodule_put(THIS_MODULE);\n\tdev->driver = NULL;\n\treturn ret;\n\n}", "extracted_prediction": "**Summary:**  \nThe `mei_cl_device_remove` function removes a device from the system, calling the driver's `remove` function, unregistering callbacks, releasing bus module and module references, and setting the device's driver to `NULL`. It returns 0 unless the driver's `remove` function returns a non-zero value."}
{"index": 794, "input": "**User**: \ncontain4D(RectBox *rect_box, RangeBox *query)\n{\n\treturn contain2D(&rect_box->range_box_x, &query->left) &&\n\t\tcontain2D(&rect_box->range_box_y, &query->right);\n}", "extracted_prediction": "The function `contain4D` checks if the x-range of the `RectBox` contains the `left` value of the `Query` and the y-range of the `RectBox` contains the `right` value of the `Query`. It returns `true` if both conditions are satisfied, otherwise `false`."}
{"index": 101, "input": "**User**: \nppc4xx_edac_check_bank_error(const struct ppc4xx_ecc_status *status,\n\t\t\t     unsigned int bank)\n{\n\tswitch (bank) {\n\tcase 0:\n\t\treturn status->ecces & SDRAM_ECCES_BK0ER;\n\tcase 1:\n\t\treturn status->ecces & SDRAM_ECCES_BK1ER;\n\tdefault:\n\t\treturn false;\n\t}\n}", "extracted_prediction": "The function checks if a specific bank (0 or 1) has an error in the ECCES register by examining the corresponding bit, returning `true` if the bit is set, otherwise `false`."}
{"index": 58, "input": "**User**: \nstatic int is_number(const char* s) {\n  size_t i;\n  for (i = 0; i < strlen(s); i++) { if (!strchr(\"0123456789\", s[i])) { return 0; } }\n  return 1;\n}", "extracted_prediction": "The function `is_number` checks if a string consists solely of digits. It iterates through each character, verifying it is one of the digits `0-9`. If any character is not a digit, it returns `0`; otherwise, it returns `1`. This confirms the string is a valid number (allowing leading zeros)."}
{"index": 77, "input": "**User**: \nstatic inline void set_cpu_wakeup_addr(unsigned int cpu_id, u32 addr)\n{\n\tstruct omap4_cpu_pm_info *pm_info = &per_cpu(omap4_pm_info, cpu_id);\n\n\tif (pm_info->wkup_sar_addr)\n\t\twritel_relaxed(addr, pm_info->wkup_sar_addr);\n}", "extracted_prediction": "The function `set_cpu_wakeup_addr` sets the CPU's wakeup address for a specific CPU ID. It retrieves the `omap4_cpu_pm_info` structure for the given CPU and writes the provided address to the `wkup_sar_addr` field if it exists, using `writel_relaxed` for atomic updates."}
{"index": 205, "input": "**User**: \nenumerator_t *enumerator_create_nested(enumerator_t *outer,\n\t\t\t\t\tenumerator_t *(inner_constructor)(void *outer, void *data),\n\t\t\t\t\tvoid *data, void (*destructor)(void *data))\n{\n\tnested_enumerator_t *this;\n\n\tINIT(this,\n\t\t.public = {\n\t\t\t.enumerate = enumerator_enumerate_default,\n\t\t\t.venumerate = _enumerate_nested,\n\t\t\t.destroy = _destroy_nested,\n\t\t},\n\t\t.outer = outer,\n\t\t.create_inner = inner_constructor,\n\t\t.data = data,\n\t\t.destructor = destructor,\n\t);\n\treturn &this->public;\n}", "extracted_prediction": "The function `enumerator_create_nested` initializes a nested enumerator structure, setting up its public interface with default enumeration logic, a custom inner constructor, and a specified destructor. It returns a pointer to the public structure, enabling clients to use the enumerator's methods. Key parameters include the outer enumerator, inner constructor function, data payload, and destructor."}
{"index": 464, "input": "**User**: \nstatic int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned cpu = dev->id;\n\tint ret;\n\n\tdev_dbg(dev, \"%s: adding CPU%u\\n\", __func__, cpu);\n\n\tif (cpu_online(cpu)) {\n\t\tret = cpufreq_online(cpu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/* Create sysfs link on CPU registration */\n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy)\n\t\tadd_cpu_dev_symlink(policy, cpu);\n\n\treturn 0;\n}", "extracted_prediction": "**Summary:**  \nRegisters a CPU in the cpufreq subsystem, checks if it's online, calls `cpufreq_online`, and creates a sysfs symlink for the CPU. Returns 0 on success."}
{"index": 272, "input": "**User**: \nxfs_btree_is_lastrec(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_btree_block\t*block,\n\tint\t\t\tlevel)\n{\n\tunion xfs_btree_ptr\tptr;\n\n\tif (level > 0)\n\t\treturn 0;\n\tif (!(cur->bc_flags & XFS_BTREE_LASTREC_UPDATE))\n\t\treturn 0;\n\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (!xfs_btree_ptr_is_null(cur, &ptr))\n\t\treturn 0;\n\treturn 1;\n}", "extracted_prediction": "**Summary:**  \nThe function `xfs_btree_is_lastrec` checks if the current block is the last record in an XFS btree by verifying the update flag and the presence of a right sibling pointer. It returns `1` only if the block is the last record (level 0, update flag set, and no right sibling exists)."}
{"index": 589, "input": "**User**: \nunsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {\n    unsigned char *p = ziplistIndex(zl,index);\n    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);\n}", "extracted_prediction": "The function `ziplistDeleteRange` deletes a range of elements from a ziplist starting at a specified index. It returns the modified ziplist if the index is valid; otherwise, it returns the original ziplist. The function checks if the index is valid using `ziplistIndex` and delegates the deletion to `__ziplistDelete` with the number of elements to remove."}
{"index": 79, "input": "**User**: \nvoid fork_handler(void)\n{\n\tforce_flush_all();\n\n\tschedule_tail(current->thread.prev_sched);\n\n\t/*\n\t * XXX: if interrupt_end() calls schedule, this call to\n\t * arch_switch_to isn't needed. We could want to apply this to\n\t * improve performance. -bb\n\t */\n\tarch_switch_to(current);\n\n\tcurrent->thread.prev_sched = NULL;\n\n\tuserspace(&current->thread.regs.regs, current_thread_info()->aux_fp_regs);\n}", "extracted_prediction": "The `fork_handler` function manages the fork process by:  \n1. **Flushing caches** to ensure data consistency.  \n2. **Scheduling** the next thread using `schedule_tail`.  \n3. **Switching to the current thread** via `arch_switch_to`.  \n4. **Updating register state** with `userspace` to copy registers for the new thread.  \nThe function is optimized for performance, with a note that `arch_switch_to` may be redundant if `interrupt_end()` calls `schedule`."}
{"index": 375, "input": "**User**: \ncompare_known_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,\n                                      const smartlist_t *policy)\n{\n  /* We know the address and port, and we know the policy, so we can just\n   * compute an exact match. */\n  SMARTLIST_FOREACH_BEGIN(policy, addr_policy_t *, tmpe) {\n    /* Address is known */\n    if (!tor_addr_compare_masked(addr, &tmpe->addr, tmpe->maskbits,\n                                 CMP_EXACT)) {\n      if (port >= tmpe->prt_min && port <= tmpe->prt_max) {\n        /* Exact match for the policy */\n        return tmpe->policy_type == ADDR_POLICY_ACCEPT ?\n          ADDR_POLICY_ACCEPTED : ADDR_POLICY_REJECTED;\n      }\n    }\n  } SMARTLIST_FOREACH_END(tmpe);\n\n  /* accept all by default. */\n  return ADDR_POLICY_ACCEPTED;\n}", "extracted_prediction": "This function checks if a known Tor address and port match any entry in a policy list. It returns `ADDR_POLICY_ACCEPTED` if a matching policy is found (with port within the policy's range), otherwise it defaults to `ADDR_POLICY_ACCEPTED`. The function uses bitwise address comparison and port range checks to determine matches."}
{"index": 658, "input": "**User**: \nint StreamTcpInlineMode(void)\n{\n    return (stream_config.flags & STREAMTCP_INIT_FLAG_INLINE) ? 1 : 0;\n}", "extracted_prediction": "The function `StreamTcpInlineMode` returns `1` if the `STREAMTCP_INIT_FLAG_INLINE` flag is set in `stream_config.flags`, otherwise `0`. It checks whether inline mode is enabled for the stream."}
{"index": 492, "input": "**User**: \nint arch__compare_symbol_names(const char *namea, const char *nameb)\n{\n\t/* Skip over initial dot */\n\tif (*namea == '.')\n\t\tnamea++;\n\tif (*nameb == '.')\n\t\tnameb++;\n\n\treturn strcmp(namea, nameb);\n}", "extracted_prediction": "The function `arch__compare_symbol_names` skips leading dots in both input strings and compares the resulting names using `strcmp`. It ensures that symbols with leading dots are treated as equal, while differing names are distinguished."}
{"index": 680, "input": "**User**: \nvoid libtpmtss_deinit(void)\n{\n\ttpm_tss_tss2_deinit();\n}", "extracted_prediction": "The `libtpmtss_deinit` function deinitializes the TSS 2.0 library by calling `tpm_tss_tss2_deinit()`, releasing resources and resetting the TPM module."}
{"index": 577, "input": "**User**: \nstatic struct lvname *alloc_lvn(struct parsed_partitions *state, u32 lba)\n{\n\tsize_t count = sizeof(struct lvname) * LVM_MAXLVS;\n\tstruct lvname *p;\n\n\tp = kmalloc(count, GFP_KERNEL);\n\tif (!p)\n\t\treturn NULL;\n\n\tif (read_lba(state, lba, (u8 *) p, count) < count) {\n\t\tkfree(p);\n\t\treturn NULL;\n\t}\n\treturn p;\n}", "extracted_prediction": "**Summary:**  \nThe `alloc_lvn` function allocates memory for a `struct lvname` block, reads data from a specified LBA (Logical Block Address) into the buffer, and returns the pointer if successful. If memory allocation fails or the read operation returns an error, it frees the allocated memory and returns `NULL`. The function is used to populate partition metadata for LVM (Logical Volume Manager) operations."}
{"index": 368, "input": "**User**: \nint isapnp_present(void)\n{\n\tstruct pnp_card *card;\n\n\tpnp_for_each_card(card) {\n\t\tif (card->protocol == &isapnp_protocol)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "extracted_prediction": "The function `isapnp_present()` checks if any PnP (Plug and Play) card in the system is configured with the ISAPNP protocol. It iterates through all available PnP cards using `pnp_for_each_card()` and returns `1` if a card with the `isapnp_protocol` is found, otherwise `0`."}
{"index": 788, "input": "**User**: \nvoid s3c2410_iotiming_getbank(struct s3c_cpufreq_config *cfg,\n\t\t\t      struct s3c2410_iobank_timing *bt)\n{\n\tunsigned long bankcon = bt->bankcon;\n\tunsigned long hclk = cfg->freq.hclk_tns;\n\n\tbt->tcah = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcah_SHIFT);\n\tbt->tcoh = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcoh_SHIFT);\n\tbt->tcos = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tcos_SHIFT);\n\tbt->tacs = get_0124(hclk, bankcon >> S3C2410_BANKCON_Tacs_SHIFT);\n\tbt->tacc = get_tacc(hclk, bankcon >> S3C2410_BANKCON_Tacc_SHIFT);\n}", "extracted_prediction": "The function `s3c2410_iotiming_getbank` retrieves timing parameters for an I/O bank in the S3C2410 microcontroller. It calculates values like `tcah`, `tcoh`, `tcos`, `tacs`, and `tacc` using the current frequency's `hclk` and the bank configuration register (`bankcon`). These values are derived by shifting `bankcon` and applying helper functions (`get_0124` and `get_tacc`) to determine the timing parameters. The results are stored in the provided `struct s3c2410_iobank_timing`."}
{"index": 138, "input": "**User**: \nstatic bool is_pkcs11_uri(const char *string)\n{\n  if(curl_strnequal(string, \"pkcs11:\", 7)) {\n    return TRUE;\n  }\n  else {\n    return FALSE;\n  }\n}", "extracted_prediction": "The function `is_pkcs11_uri` checks if a string begins with the prefix `\"pkcs11:\"` using `curl_strnequal`, returning `true` if the condition is met (indicating a PKCS#11 URI scheme)."}
{"index": 43, "input": "**User**: \nvoid usb_ep_set_maxpacket_limit(struct usb_ep *ep,\n\t\t\t\t\t      unsigned maxpacket_limit)\n{\n\tep->maxpacket_limit = maxpacket_limit;\n\tep->maxpacket = maxpacket_limit;\n\n\ttrace_usb_ep_set_maxpacket_limit(ep, 0);\n}", "extracted_prediction": "The function sets the maximum packet limit and the `maxpacket` field for a USB endpoint, then traces the event."}
{"index": 753, "input": "**User**: \nvoid ccl_image_destroy(CCLImage * img) {\n\n    ccl_wrapper_unref((CCLWrapper *) img, sizeof(CCLImage), NULL,\n        (ccl_wrapper_release_cl_object) clReleaseMemObject, NULL);\n}", "extracted_prediction": "The function `ccl_image_destroy` releases the memory object associated with a `CCLImage` instance by decrementing its reference count using `ccl_wrapper_unref`, with the release callback `clReleaseMemObject`. This properly deallocates the CUDA memory resource."}
{"index": 947, "input": "**User**: \nSDL_SYS_JoystickUpdate(SDL_Joystick * joystick)\n{\n    return;\n}", "extracted_prediction": "This function is a stub for updating joystick input, taking a `SDL_Joystick` pointer as an argument and returning `void`. It currently does not perform any actual operations, likely serving as a placeholder until the system layer implementation is completed."}
{"index": 554, "input": "**User**: \nmlt_property mlt_property_init( )\n{\n\tmlt_property self = calloc( 1, sizeof( *self ) );\n\tif ( self )\n\t\tpthread_mutex_init( &self->mutex, NULL );\n\treturn self;\n}", "extracted_prediction": "The function `mlt_property_init()` allocates memory for a property object and initializes a mutex for thread safety, returning the allocated object."}
{"index": 465, "input": "**User**: \nDataset *DatasetFind(const char *name, enum DatasetTypes type)\n{\n    SCMutexLock(&sets_lock);\n    Dataset *set = DatasetSearchByName(name);\n    if (set) {\n        if (set->type != type) {\n            SCMutexUnlock(&sets_lock);\n            return NULL;\n        }\n    }\n    SCMutexUnlock(&sets_lock);\n    return set;\n}", "extracted_prediction": "The `DatasetFind` function searches for a dataset by name and type, ensuring thread safety with a mutex lock. It returns the dataset if found and matches the specified type; otherwise, it returns `NULL`."}
{"index": 823, "input": "**User**: \nu32 sqlite3ExprListFlags(const ExprList *pList){\n  int i;\n  u32 m = 0;\n  assert( pList!=0 );\n  for(i=0; i<pList->nExpr; i++){\n     Expr *pExpr = pList->a[i].pExpr;\n     assert( pExpr!=0 );\n     m |= pExpr->flags;\n  }\n  return m;\n}", "extracted_prediction": "The function `sqlite3ExprListFlags` returns the bitwise OR of all flags from the expressions in an `ExprList`. It iterates through each expression, combining their flags into a single value using `OR` (bitwise). The function asserts that the input list and expressions are valid to prevent dereferencing errors. The result is a `u32` representing the aggregated flags."}
{"index": 598, "input": "**User**: \nvoid lkdtm_REFCOUNT_INC_NOT_ZERO_OVERFLOW(void)\n{\n\trefcount_t over = REFCOUNT_INIT(REFCOUNT_MAX);\n\n\tpr_info(\"attempting bad refcount_inc_not_zero() overflow\\n\");\n\tif (!refcount_inc_not_zero(&over))\n\t\tpr_warn(\"Weird: refcount_inc_not_zero() reported zero\\n\");\n\n\toverflow_check(&over);\n}", "extracted_prediction": "The function `lkdtm_REFCOUNT_INC_NOT_ZERO_OVERFLOW` tests the behavior of `refcount_inc_not_zero()` in the context of overflow. It initializes a reference count to maximum value, attempts to increment it, and checks if the increment operation correctly handles overflow. If the increment fails (returns false), it warns about an unexpected zero result. The function also invokes `overflow_check()` to validate the overflow scenario."}
{"index": 773, "input": "**User**: \ntext_option_changed(void)\n{\n\tstats_redraw_later();\n}", "extracted_prediction": "The function `text_option_changed` triggers a redraw of statistics when a text option is modified. It calls `stats_redraw_later()` to schedule the redraw operation."}
{"index": 979, "input": "**User**: \ntask_energy(\n\ttask_t\ttask)\n{\n\tuint64_t energy = 0;\n\tthread_t thread;\n\n\ttask_lock(task);\n\tenergy += task->task_energy;\n\n\tqueue_iterate(&task->threads, thread, thread_t, task_threads) {\n\t\tspl_t x;\n\t\tx = splsched();\n\t\tthread_lock(thread);\n\t\tenergy += ml_energy_stat(thread);\n\t\tthread_unlock(thread);\n\t\tsplx(x);\n\t}\n\n\ttask_unlock(task);\n\treturn energy;\n}", "extracted_prediction": "**Summary:**  \nThe `task_energy` function calculates the total energy consumption of a task by:  \n1. Acquiring the task's lock to access its energy value.  \n2. Adding the task's own energy.  \n3. Iterating over all threads in the task, locking each thread, and adding its energy statistic.  \n4. Releasing the task lock and returning the total energy.  \nKey operations include SPL context saving/restoring (`splsched()` and `splx()`) to ensure thread safety during energy calculation."}
{"index": 657, "input": "**User**: \nstatic int pch_gbe_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\n\tstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\n\n\tif (unlikely(!PCH_GBE_DESC_UNUSED(tx_ring))) {\n\t\tnetif_stop_queue(netdev);\n\t\tnetdev_dbg(netdev,\n\t\t\t   \"Return : BUSY  next_to use : 0x%08x  next_to clean : 0x%08x\\n\",\n\t\t\t   tx_ring->next_to_use, tx_ring->next_to_clean);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t/* CRC,ITAG no support */\n\tpch_gbe_tx_queue(adapter, tx_ring, skb);\n\treturn NETDEV_TX_OK;\n}", "extracted_prediction": "**Summary:**  \nThe `pch_gbe_xmit_frame` function checks if there's available space in the TX ring of a network device. If not, it stops the transmit queue and returns `NETDEV_TX_BUSY`. If space is available, it sends the packet (`skb`) through the TX queue and returns `NETDEV_TX_OK`. CRC/ITAG checks are skipped as they are not supported by the hardware."}
